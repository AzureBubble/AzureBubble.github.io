<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fomalhaut🥝</title>
  
  
  <link href="https://azzurebubble.github.io/atom.xml" rel="self"/>
  
  <link href="https://azzurebubble.github.io/"/>
  <updated>2024-07-18T14:54:21.577Z</updated>
  <id>https://azzurebubble.github.io/</id>
  
  <author>
    <name>Rock</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UGUI源码解析——LayoutRebuilder</title>
    <link href="https://azzurebubble.github.io/posts/52e926ac.html"/>
    <id>https://azzurebubble.github.io/posts/52e926ac.html</id>
    <published>2024-07-18T14:43:45.000Z</published>
    <updated>2024-07-18T14:54:21.577Z</updated>
    
    
    <summary type="html">负责布局的刷新(UI对象位置和大小的刷新)</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——CanvasUpdateRegistry</title>
    <link href="https://azzurebubble.github.io/posts/6dcd3730.html"/>
    <id>https://azzurebubble.github.io/posts/6dcd3730.html</id>
    <published>2024-07-18T14:27:22.000Z</published>
    <updated>2024-07-18T14:55:06.910Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>CanvasUpdate：用于描述在Canvas更新过程中可能发生的不同阶段</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> CanvasUpdate</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 布局更新之前调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    Prelayout = <span class="number">0</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 布局更新时调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    Layout = <span class="number">1</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 布局更新之后调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    PostLayout = <span class="number">2</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 渲染之前调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    PreRender = <span class="number">3</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 渲染之前完成后调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    LatePreRender = <span class="number">4</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 表示枚举的范围，边界检测或者迭代</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    MaxUpdateValue = <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ICanvasElement：图像、布局重建接口。几乎所有UI对象都继承自ICanvasElement接口，一个UI对象若要重建都需要继承自ICanvasElement接口。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICanvasElement</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 重构方法，需要在继承类中实现，Graphic和LayoutRebuilder继承了此接口</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;executing&quot;&gt;</span>正在重建的当前的CanvasUpdate阶段<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">Rebuild</span>(<span class="params">CanvasUpdate executing</span>)</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 每个UI都继承自UIBehaviour类，UIBehaviour继承自MonoBehaviour，MonoBehaviour继承自Component类，而Component类实现了transform属性，所以子类可以不再实现这个属性</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     Transform transform &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 布局完成的回调函数</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">LayoutComplete</span>()</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 图像更新完成的回调函数</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">GraphicUpdateComplete</span>()</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 获取UI对象是否销毁</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">     <span class="function"><span class="built_in">bool</span> <span class="title">IsDestroyed</span>()</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>CanvasUpdateRegistry：是一个单例，它监听了Canvas即将渲染的事件，并调用已注册对象的Rebuild、LayoutComplete、GraphicUpdateComplete方法，<font color=red>而其中的Rebuild方法就是每个UI元素的刷新方法。</font></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例获取</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CanvasUpdateRegistry s_Instance;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CanvasUpdateRegistry instance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s_Instance == <span class="literal">null</span>)</span><br><span class="line">            s_Instance = <span class="keyword">new</span> CanvasUpdateRegistry();</span><br><span class="line">        <span class="keyword">return</span> s_Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数：给Canvas的静态事件willRenderCanvases注册一个名为PerformUpdate的方法</span></span><br><span class="line"><span class="comment">// (willRenderCanvases每帧在Canvas渲染前执行)，PerformUpdate中调用了布局和图像的更新</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">CanvasUpdateRegistry</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Canvas.willRenderCanvases += PerformUpdate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个标记是否在进行布局或图像更新的字段</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> m_PerformingLayoutUpdate;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> m_PerformingGraphicUpdate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于在性能分析器中识别和记录Canvas更新过程中的不同阶段的标识符</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span>[] m_CanvasUpdateProfilerStrings = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;CanvasUpdate.Prelayout&quot;</span>, <span class="string">&quot;CanvasUpdate.Layout&quot;</span>, <span class="string">&quot;CanvasUpdate.PostLayout&quot;</span>, <span class="string">&quot;CanvasUpdate.PreRender&quot;</span>, <span class="string">&quot;CanvasUpdate.LatePreRender&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 用于在性能分析器或调试器中标识剪切器注册表中执行裁剪的标识符</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> m_CullingUpdateProfilerString = <span class="string">&quot;ClipperRegistry.Cull&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 布局重建序列和图像重建序列</span></span><br><span class="line"><span class="comment">// 当需要更新布局或图像时，可以调用RegisterCanvasElementForLayoutRebuild和</span></span><br><span class="line"><span class="comment">// RegisterCanvasElementForGraphicRebuild两个方法将对象添加到对应的重建序列中</span></span><br><span class="line"><span class="comment">// PerformUpdate方法会调用Rebuild方法对这两个序列中中的对象进行更新操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> IndexedSet&lt;ICanvasElement&gt; m_LayoutRebuildQueue = <span class="keyword">new</span> IndexedSet&lt;ICanvasElement&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> IndexedSet&lt;ICanvasElement&gt; m_GraphicRebuildQueue = <span class="keyword">new</span> IndexedSet&lt;ICanvasElement&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查指定的Canvas元素是否是Unity的Object，是否可以进行有效更新</span></span><br><span class="line"><span class="comment">// Object是Unity所有对象的基类，object是C#中所有对象的基类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">ObjectValidForUpdate</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> valid = element != <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> isUnityObject = element <span class="keyword">is</span> Object;</span><br><span class="line">    <span class="keyword">if</span> (isUnityObject)</span><br><span class="line">        valid = (element <span class="keyword">as</span> Object) != <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> valid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理两个队列中的无效元素</span></span><br><span class="line"><span class="comment">// MonoBehaviour对空值相等性重载了==操作符，用于检查他们是否被销毁</span></span><br><span class="line"><span class="comment">// 这段代码中处理的是一个ICanvasElement接口类型的列表，而不是具体的MonoBehaviour类型</span></span><br><span class="line"><span class="comment">// 因此直接使用==操作符不能直接转发到MonoBehaviour，而只是检查接口本身是否为null</span></span><br><span class="line"><span class="comment">// IsDestroyed()方法用于检查元素的后端是否被销毁</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CleanInvalidItems</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> layoutRebuildQueueCount = m_LayoutRebuildQueue.Count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = layoutRebuildQueueCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> item = m_LayoutRebuildQueue[i];</span><br><span class="line">        <span class="comment">// 元素是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (item == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_LayoutRebuildQueue.RemoveAt(i);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 元素是否被销毁</span></span><br><span class="line">        <span class="keyword">if</span> (item.IsDestroyed())</span><br><span class="line">        &#123;</span><br><span class="line">            m_LayoutRebuildQueue.RemoveAt(i);</span><br><span class="line">            item.LayoutComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> graphicRebuildQueueCount = m_GraphicRebuildQueue.Count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = graphicRebuildQueueCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> item = m_GraphicRebuildQueue[i];</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_GraphicRebuildQueue.RemoveAt(i);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (item.IsDestroyed())</span><br><span class="line">        &#123;</span><br><span class="line">            m_GraphicRebuildQueue.RemoveAt(i);</span><br><span class="line">            item.GraphicUpdateComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算指定Transform对象的父级层级数目</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">ParentCount</span>(<span class="params">Transform child</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> parent = child.parent;</span><br><span class="line">    <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (parent != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        parent = parent.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个元素的祖先层级深度，祖先层级深度越深，则排在列表的更后面</span></span><br><span class="line"><span class="comment">// 决定元素的布局和图像重建顺序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">SortLayoutList</span>(<span class="params">ICanvasElement x, ICanvasElement y</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Transform t1 = x.transform;</span><br><span class="line">    Transform t2 = y.transform;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ParentCount(t1) - ParentCount(t2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个Canvas元素注册到布局重建队列中，一个带返回值一个不带返回值方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RegisterCanvasElementForLayoutRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    instance.InternalRegisterCanvasElementForLayoutRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">TryRegisterCanvasElementForLayoutRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> instance.InternalRegisterCanvasElementForLayoutRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">InternalRegisterCanvasElementForLayoutRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断元素是否存在布局重建队列中</span></span><br><span class="line">    <span class="keyword">if</span> (m_LayoutRebuildQueue.Contains(element))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 向布局重建队列中添加元素，确保不会重复添加</span></span><br><span class="line">    <span class="keyword">return</span> m_LayoutRebuildQueue.AddUnique(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个Canvas元素注册到图像重建队列中，一个带返回值一个不带返回值方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RegisterCanvasElementForGraphicRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    instance.InternalRegisterCanvasElementForGraphicRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">TryRegisterCanvasElementForGraphicRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> instance.InternalRegisterCanvasElementForGraphicRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">InternalRegisterCanvasElementForGraphicRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 是否正在进行图像重建更新操作，是的话将不会将元素添加到图像重建队列中</span></span><br><span class="line">    <span class="keyword">if</span> (m_PerformingGraphicUpdate)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="built_in">string</span>.Format(<span class="string">&quot;Trying to add &#123;0&#125; for graphic rebuild while we are already inside a graphic rebuild loop. This is not supported.&quot;</span>, element));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 向图像重建队列中添加元素，确保不会重复添加</span></span><br><span class="line">    <span class="keyword">return</span> m_GraphicRebuildQueue.AddUnique(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从布局和重建的队列中移除指定的Canvas元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnRegisterCanvasElementForRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    instance.InternalUnRegisterCanvasElementForLayoutRebuild(element);</span><br><span class="line">    instance.InternalUnRegisterCanvasElementForGraphicRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InternalUnRegisterCanvasElementForLayoutRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果正在进行布局重建更新操作，将不会移除指定元素</span></span><br><span class="line">    <span class="keyword">if</span> (m_PerformingLayoutUpdate)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="built_in">string</span>.Format(<span class="string">&quot;Trying to remove &#123;0&#125; from rebuild list while we are already inside a rebuild loop. This is not supported.&quot;</span>, element));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 调用元素的布局重建完成函数</span></span><br><span class="line">    element.LayoutComplete();</span><br><span class="line">    <span class="comment">// 从布局重建队列中移除元素</span></span><br><span class="line">    instance.m_LayoutRebuildQueue.Remove(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InternalUnRegisterCanvasElementForGraphicRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果正在进行图像重建更新操作，将不会移除指定元素</span></span><br><span class="line">    <span class="keyword">if</span> (m_PerformingGraphicUpdate)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="built_in">string</span>.Format(<span class="string">&quot;Trying to remove &#123;0&#125; from rebuild list while we are already inside a rebuild loop. This is not supported.&quot;</span>, element));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用元素的图像重建完成函数</span></span><br><span class="line">    element.GraphicUpdateComplete();</span><br><span class="line">    <span class="comment">// 从图像重建队列中移除元素</span></span><br><span class="line">    instance.m_GraphicRebuildQueue.Remove(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从布局和重建的队列中禁用指定的Canvas元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DisableCanvasElementForRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    instance.InternalDisableCanvasElementForLayoutRebuild(element);</span><br><span class="line">    instance.InternalDisableCanvasElementForGraphicRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InternalDisableCanvasElementForLayoutRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果正在进行布局重建更新操作，将不会禁用指定元素</span></span><br><span class="line">    <span class="keyword">if</span> (m_PerformingLayoutUpdate)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="built_in">string</span>.Format(<span class="string">&quot;Trying to remove &#123;0&#125; from rebuild list while we are already inside a rebuild loop. This is not supported.&quot;</span>, element));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 调用元素的布局重建完成函数</span></span><br><span class="line">    element.LayoutComplete();</span><br><span class="line">    <span class="comment">// 禁用指定元素</span></span><br><span class="line">    instance.m_LayoutRebuildQueue.DisableItem(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InternalDisableCanvasElementForGraphicRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果正在进行图像重建更新操作，将不会禁用指定元素</span></span><br><span class="line">    <span class="keyword">if</span> (m_PerformingGraphicUpdate)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="built_in">string</span>.Format(<span class="string">&quot;Trying to remove &#123;0&#125; from rebuild list while we are already inside a rebuild loop. This is not supported.&quot;</span>, element));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用元素的图像重建完成函数</span></span><br><span class="line">    element.GraphicUpdateComplete();</span><br><span class="line">    <span class="comment">// 禁用指定元素</span></span><br><span class="line">    instance.m_GraphicRebuildQueue.DisableItem(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前是否正在计算图形布局</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsRebuildingLayout</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> instance.m_PerformingLayoutUpdate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当前是否正在重建图形</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsRebuildingGraphics</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> instance.m_PerformingGraphicUpdate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接下来着重分析CanvasUpdateRegistry中的PerformUpdate方法的内部实现和执行顺序。<font color=red>可以在Profiler中通过查看标志性函数Canvas.willRenderCanvases的耗时，来了解重建的性能消耗</font></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先定义一个静态只读的比较函数委托</span></span><br><span class="line"><span class="comment">// Comparison&lt;T&gt;是C#已经预定义好的一个用于比较两个类型为T的对象并返回整数的委托</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Comparison&lt;ICanvasElement&gt; s_SortLayoutFunction = SortLayoutList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PerformUpdate</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 用于在代码块开始和结束时记录性能样本，监测布局更新的性能</span></span><br><span class="line">    UISystemProfilerApi.BeginSample(UISystemProfilerApi.SampleType.Layout);</span><br><span class="line">    <span class="comment">// 清理无效的元素或数据</span></span><br><span class="line">    CleanInvalidItems();</span><br><span class="line"><span class="comment">// 标记正在进行布局更新操作</span></span><br><span class="line">    m_PerformingLayoutUpdate = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 对布局重建队列中的元素进行排序</span></span><br><span class="line">    m_LayoutRebuildQueue.Sort(s_SortLayoutFunction);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= (<span class="built_in">int</span>)CanvasUpdate.PostLayout; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 标记每一个元素的性能分析</span></span><br><span class="line">        UnityEngine.Profiling.Profiler.BeginSample(m_CanvasUpdateProfilerStrings[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; m_LayoutRebuildQueue.Count; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> rebuild = m_LayoutRebuildQueue[j];</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 判断元素是否是有效元素</span></span><br><span class="line">                <span class="comment">// 对布局重建序列中的每一个元素进行CanvasUpdate的每个阶段更新</span></span><br><span class="line">                <span class="keyword">if</span> (ObjectValidForUpdate(rebuild))</span><br><span class="line">                    rebuild.Rebuild((CanvasUpdate)i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogException(e, rebuild.transform);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        UnityEngine.Profiling.Profiler.EndSample();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m_LayoutRebuildQueue.Count; ++i)</span><br><span class="line">        <span class="comment">// 调用布局重建完成函数</span></span><br><span class="line">        m_LayoutRebuildQueue[i].LayoutComplete();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空布局重建列表，并修改布局重建标志为false</span></span><br><span class="line">    m_LayoutRebuildQueue.Clear();</span><br><span class="line">    m_PerformingLayoutUpdate = <span class="literal">false</span>;</span><br><span class="line">    UISystemProfilerApi.EndSample(UISystemProfilerApi.SampleType.Layout);</span><br><span class="line">    UISystemProfilerApi.BeginSample(UISystemProfilerApi.SampleType.Render);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now layout is complete do culling...</span></span><br><span class="line">    UnityEngine.Profiling.Profiler.BeginSample(m_CullingUpdateProfilerString);</span><br><span class="line">    <span class="comment">// 执行实际的裁剪操作</span></span><br><span class="line">    ClipperRegistry.instance.Cull();</span><br><span class="line">    UnityEngine.Profiling.Profiler.EndSample();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记正在进行图像更新操作</span></span><br><span class="line">    m_PerformingGraphicUpdate = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = (<span class="built_in">int</span>)CanvasUpdate.PreRender; i &lt; (<span class="built_in">int</span>)CanvasUpdate.MaxUpdateValue; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        UnityEngine.Profiling.Profiler.BeginSample(m_CanvasUpdateProfilerStrings[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; m_GraphicRebuildQueue.Count; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> element = m_GraphicRebuildQueue[k];</span><br><span class="line">                <span class="comment">// 判断元素是否是有效元素</span></span><br><span class="line">                <span class="comment">// 对布局重建序列中的每一个元素进行CanvasUpdate的每个阶段更新</span></span><br><span class="line">                <span class="keyword">if</span> (ObjectValidForUpdate(element))</span><br><span class="line">                    element.Rebuild((CanvasUpdate)i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogException(e, m_GraphicRebuildQueue[k].transform);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        UnityEngine.Profiling.Profiler.EndSample();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m_GraphicRebuildQueue.Count; ++i)</span><br><span class="line">        <span class="comment">// 调用图像重建完成函数</span></span><br><span class="line">        m_GraphicRebuildQueue[i].GraphicUpdateComplete();</span><br><span class="line"><span class="comment">// 清空图像重建序列 并修改图像重建标志为false</span></span><br><span class="line">    m_GraphicRebuildQueue.Clear();</span><br><span class="line">    m_PerformingGraphicUpdate = <span class="literal">false</span>;</span><br><span class="line">    UISystemProfilerApi.EndSample(UISystemProfilerApi.SampleType.Render);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">图像、布局重建注册器</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——ClipperRegistry</title>
    <link href="https://azzurebubble.github.io/posts/c266fbd7.html"/>
    <id>https://azzurebubble.github.io/posts/c266fbd7.html</id>
    <published>2024-07-18T01:46:53.000Z</published>
    <updated>2024-07-18T14:53:52.573Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ClipperRegister：是一个裁剪注册器单例，用于跟踪场景中存在的所有IClipper。</p><p>这在CanvasUpdate循环期间用于剔除可剪裁元素。剪裁在布局之后但在图形更新之前调用。</p></blockquote><h4 id="源码解析">源码解析</h4><blockquote><p>单例</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例获取</span></span><br><span class="line"><span class="keyword">static</span> ClipperRegistry s_Instance;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ClipperRegistry instance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s_Instance == <span class="literal">null</span>)</span><br><span class="line">            s_Instance = <span class="keyword">new</span> ClipperRegistry();</span><br><span class="line">        <span class="keyword">return</span> s_Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>保护类型的构造函数，这里面声明了一个空的带有具体类型的字典，是为了在AOT平台中能够识别使用前面说到的IndexedSet自定义容器中的字典容器。</p><p>类型的可参考xLua热更新就需要给每个泛型容器预先定义一个空的具体类型的容器。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ClipperRegistry</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> disable 168</span></span><br><span class="line">    Dictionary&lt;IClipper, <span class="built_in">int</span>&gt; emptyIClipperDic;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> restore 168</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Register：将裁剪对象添加到m_Clippers序列中</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Register</span>(<span class="params">IClipper c</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    instance.m_Clippers.AddUnique(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Cull：对所有注册的IClipper执行剪辑，在CanvasUpdateRegistry类中的PerformUpdate中调用了这个方法，可回顾查看</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Cull</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; m_Clippers.Count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Clippers[i].PerformClipping();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Unregister：取消注册的IClipper元素</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Unregister</span>(<span class="params">IClipper c</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">instance.m_Clippers.Remove(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一个裁剪注册器单例</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——IClipper</title>
    <link href="https://azzurebubble.github.io/posts/75a13096.html"/>
    <id>https://azzurebubble.github.io/posts/75a13096.html</id>
    <published>2024-07-17T13:10:49.000Z</published>
    <updated>2024-07-18T14:55:39.867Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>IClipper：裁剪接口（裁剪者），RectMask2D继承此接口</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子类实现PerformClipping</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IClipper</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 函数用于筛选/剪辑子元素</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> CanvasUpdateRegistry类中的PerformUpdate里调用了Cull方法执行裁剪</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 在Canvas更新循环的布局之后和图形更新之前调用</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">PerformClipping</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">裁剪接口（裁剪者）</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——IndexedSet</title>
    <link href="https://azzurebubble.github.io/posts/ad6295b1.html"/>
    <id>https://azzurebubble.github.io/posts/ad6295b1.html</id>
    <published>2024-07-17T13:00:16.000Z</published>
    <updated>2024-07-18T14:55:34.060Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>IndexedSet：</p><p>优点：保证容器元素的唯一性，快速随机移除，快速唯一的添加元素到容器尾部，顺序访问</p><p>缺点：使用更多的内存，排序不是持久化的，不支持序列化</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当删除时，我们将最后一项移动到删除项的位置，这样我们只需要更新单个项的索引缓存。(快速删除)</span></span><br><span class="line"><span class="comment">// 不保证元素的顺序。移除将改变项目的顺序。</span></span><br><span class="line"><span class="keyword">readonly</span> List&lt;T&gt; m_List = <span class="keyword">new</span> List&lt;T&gt;();</span><br><span class="line"><span class="comment">// 使用字典来加速列表的查找，这也保证了列表中元素的唯一性</span></span><br><span class="line">Dictionary&lt;T, <span class="built_in">int</span>&gt; m_Dictionary = <span class="keyword">new</span> Dictionary&lt;T, <span class="built_in">int</span>&gt;();</span><br></pre></td></tr></table></figure><blockquote><p>Add：添加元素到列表中</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">T item</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 添加元素到List中</span></span><br><span class="line">    m_List.Add(item);</span><br><span class="line">    <span class="comment">// 以元素作为key，列表中的下标作为value</span></span><br><span class="line">    m_Dictionary.Add(item, m_List.Count - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>AddUnique：确保列表中的元素的唯一性的添加方法</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">AddUnique</span>(<span class="params">T item</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断字典中是否存在key</span></span><br><span class="line">    <span class="keyword">if</span> (m_Dictionary.ContainsKey(item))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    不存在则添加</span><br><span class="line">    m_List.Add(item);</span><br><span class="line">    m_Dictionary.Add(item, m_List.Count - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Remove：删除列表中的元素</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Remove</span>(<span class="params">T item</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 取出对应元素在List中的下标位置</span></span><br><span class="line">    <span class="built_in">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!m_Dictionary.TryGetValue(item, <span class="keyword">out</span> index))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 删除List中该下标元素</span></span><br><span class="line">    RemoveAt(index);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实现以下两个方法以提供foreach遍历</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IEnumerator&lt;T&gt; <span class="title">GetEnumerator</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> System.NotImplementedException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IEnumerator IEnumerable.GetEnumerator()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> GetEnumerator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Clear：清空这个容器类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Clear</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    m_List.Clear();</span><br><span class="line">    m_Dictionary.Clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Contains：查询是否存在某元素</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Contains</span>(<span class="params">T item</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_Dictionary.ContainsKey(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CopyTo：将此容器复制到一个泛型数组中</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定类型的数组 数组索引</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CopyTo</span>(<span class="params">T[] array, <span class="built_in">int</span> arrayIndex</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    m_List.CopyTo(array, arrayIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Count：获得容器大小</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> Count &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_List.Count; &#125; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>IsReadOnly：容器是否只读，这里为不是</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> IsReadOnly &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>Insert：因为语义可能很奇怪，顺序不能保证，所以在这个容器没有实现支持</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span>(<span class="params"><span class="built_in">int</span> index, T item</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NotSupportedException(<span class="string">&quot;Random Insertion is semantically invalid, since this structure does not guarantee ordering.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>RemoveAt：删除指定下标的元素</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveAt</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 找到该下标元素</span></span><br><span class="line">    T item = m_List[index];</span><br><span class="line">    <span class="comment">// 删除字典中的对应值</span></span><br><span class="line">    m_Dictionary.Remove(item);</span><br><span class="line">    <span class="keyword">if</span> (index == m_List.Count - <span class="number">1</span>)</span><br><span class="line">        m_List.RemoveAt(index);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果该下标不是列表的最后一个元素</span></span><br><span class="line">        <span class="comment">// 则将该元素替换到列表的最后一个元素</span></span><br><span class="line">        <span class="comment">// 再进行删除操作</span></span><br><span class="line">        <span class="built_in">int</span> replaceItemIndex = m_List.Count - <span class="number">1</span>;</span><br><span class="line">        T replaceItem = m_List[replaceItemIndex];</span><br><span class="line">        m_List[index] = replaceItem;</span><br><span class="line">        m_Dictionary[replaceItem] = index;</span><br><span class="line">        m_List.RemoveAt(replaceItemIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>索引器实现</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_List[index]; &#125;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">        T item = m_List[index];</span><br><span class="line">        m_Dictionary.Remove(item);</span><br><span class="line">        m_List[index] = <span class="keyword">value</span>;</span><br><span class="line">        m_Dictionary.Add(item, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>RemoveAll：</p><ul><li><p><code>Predicate&lt;T&gt; match</code> 是一个委托，它表示一个方法或 Lambda 表达式，用来确定是否移除列表中的元素。</p></li><li><p>作者提到了一种可能的优化方法，即将需要移除的元素移动到列表的末尾，然后一次性进行移除操作。这种方法可能减少了移动元素的次数，但需要额外的逻辑来管理移动元素和一次性移除的操作。</p></li><li><p>现在的实现方式虽然简单，但如果列表中的元素较多或者频繁调用 <code>RemoveAll</code> 方法，可能会成为性能的瓶颈。</p></li></ul></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveAll</span>(<span class="params">Predicate&lt;T&gt; match</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; m_List.Count)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 判断元素是否匹配传入的委托，匹配则删除</span></span><br><span class="line">        T item = m_List[i];</span><br><span class="line">        <span class="keyword">if</span> (match(item))</span><br><span class="line">            Remove(item);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Sort:</p><ul><li>对内部列表进行排序，这使得暴露的索引访问器也排序。</li><li>但是注意，任何插入或删除都可以再次打乱集合的顺序。</li><li>由上面的插入和删除代码可知道，会打乱排序，所以这个容器的排序不是持久化的</li></ul></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Sort</span>(<span class="params">Comparison&lt;T&gt; sortLayoutFunction</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可能有更好的排序方法，并使得字典的索引保持最新</span></span><br><span class="line">    m_List.Sort(sortLayoutFunction);</span><br><span class="line">    <span class="comment">// 重建字典的索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m_List.Count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        T item = m_List[i];</span><br><span class="line">        m_Dictionary[item] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">UGUI中继承IList实现特定功能的容器</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——UIBehaviour</title>
    <link href="https://azzurebubble.github.io/posts/45311df6.html"/>
    <id>https://azzurebubble.github.io/posts/45311df6.html</id>
    <published>2024-07-15T15:07:52.000Z</published>
    <updated>2024-07-16T14:32:24.539Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>UIBehaviour：是所有UI组件的基类，UI组件都是直接或者间接继承UIBehaviour这个抽象类，<font color=red>它继承自MonoBehaviour，所以拥有和Unity相同的生命周期。</font></p></blockquote><h4 id="源码解析">源码解析</h4><blockquote><p>只会在物体创建时执行一次 ，与Mono Awake调用时机和次数保持一致</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在物体显示时执行一次，与Mono OnEnable一致</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在物体第一次激活时执行一次，在Awake之后，第一帧Update之前执行，与Mono Start一致</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Start</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在物体隐藏时执行一次，与Mono OnDisable 一致</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在当前界面被销毁时调用一次，与Mono Destroy一致</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在编辑器模式下：当脚本被加载(禁用或启用)或者Inspector窗口的值出现变化的时候会被调用，使用时添加#if UNITY_EDITOR</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnValidate</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在编辑器模式下：当脚本恢复默认值时调用，使用时添加#if UNITY_EDITOR</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Reset</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当RectTransform变化时候调用，Anchors、Pivot、Width、Height变化时调用，Transform、Rotation、Scale变化时不调用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnRectTransformDimensionsChange</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在父物体变化之前调用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnBeforeTransformParentChanged</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在父物体变化之后调用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnTransformParentChanged</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在Canvas状态变化时调用，比如禁用Canvas组件</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnDidApplyAnimationProperties</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在Canvas Group变化时调用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnCanvasGroupChanged</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当应用动画属性时调用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnCanvasHierarchyChanged</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>获取GameObject和Component是否处于激活状态</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> <span class="title">IsActive</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> isActiveAndEnabled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>获取GameObject和Component是否被销毁</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsDestroyed</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">UI组件的基类，继承MonoBehaviour</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——目录</title>
    <link href="https://azzurebubble.github.io/posts/42c102bd.html"/>
    <id>https://azzurebubble.github.io/posts/42c102bd.html</id>
    <published>2024-07-05T03:33:56.000Z</published>
    <updated>2024-07-18T14:24:14.273Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://azurebubble.github.io/posts/45311df6.html"><strong>UGUI源码解析——UIBehaviour</strong></a></p><blockquote><p>UIBehaviour：UI组件的基类，继承MonoBehaviour</p></blockquote><p><a href="https://azurebubble.github.io/posts/ad6295b1.html"><strong>UGUI源码解析——IndexedSet</strong></a></p><blockquote><p>IndexedSet：UGUI中继承IList实现特定功能的容器</p></blockquote><p><a href="https://azurebubble.github.io/posts/ad6295b1.html"><strong>UGUI源码解析——IndexedSet</strong></a></p><blockquote><p>IndexedSet：UGUI中继承IList实现特定功能的容器</p></blockquote><p><a href="https://azurebubble.github.io/posts/75a13096.html"><strong>UGUI源码解析——IClipper</strong></a></p><blockquote><p>IClipper：裁剪接口（裁剪者）</p></blockquote><p><a href="https://azurebubble.github.io/posts/c266fbd7.html"><strong>UGUI源码解析——ClipperRegistry</strong></a></p><blockquote><p>ClipperRegistry：一个裁剪注册器单例</p></blockquote><p><a href="https://azurebubble.github.io/posts/6dcd3730.html"><strong>UGUI源码解析——CanvasUpdateRegistry</strong></a></p><blockquote><p>CanvasUpdateRegistry：图像、布局重建注册器</p></blockquote><p><a href="https://azurebubble.github.io/posts/52e926ac.html"><strong>UGUI源码解析——LayoutRebuilder</strong></a></p><blockquote><p>LayoutRebuilder：主要负责布局的刷新(UI对象位置和大小的刷新)</p></blockquote>]]></content>
    
    
    <summary type="html">这是一篇阅读分析UGUI源码的文章分享，欢迎大佬指正，一起学习</summary>
    
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/C/"/>
    
    <category term="学习" scheme="https://azzurebubble.github.io/categories/C/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/C/%E5%AD%A6%E4%B9%A0/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    <category term="Unity3D" scheme="https://azzurebubble.github.io/tags/Unity3D/"/>
    
  </entry>
  
  <entry>
    <title>Untiy游戏框架QZGameFramework</title>
    <link href="https://azzurebubble.github.io/posts/3e60956b.html"/>
    <id>https://azzurebubble.github.io/posts/3e60956b.html</id>
    <published>2024-01-06T10:13:46.000Z</published>
    <updated>2024-07-05T03:39:10.984Z</updated>
    
    <content type="html"><![CDATA[<h3 id="框架仓库链接——《QZGameFramework》">框架仓库链接——<a href="https://github.com/AzureBubble/QZGameFramework"><strong>《QZGameFramework》</strong></a></h3><blockquote><p>本框架的基础是在本人参加多个项目，并且查阅积累了各类优秀代码后，自己总结优化的一个较为通用且易用的简易游戏框架，并会在未来自我能力提升的同时继续优化更新此框架，目标是一个适用于新手入门和中小公司节约成本的前提下的涵盖前后端Unity游戏框架(目前后端服务器还在学习中…)。</p></blockquote><h3 id="Unity-Editor-编辑器工具">Unity Editor 编辑器工具</h3><blockquote><p>本框架中的工具是原创+魔改实现的。</p></blockquote><h4 id="ExcelTool-——-读取-Excel-配置表工具">ExcelTool —— 读取 Excel 配置表工具</h4><blockquote><p>主要包含两种读表方式：Json和Binary。可自定义存储路径。</p><p>配置表规则<br>第一行：字段名(如修改规则，请更改 ExcelTool 脚本中的 BEGIN_VARIABLE_NAME_INDEX 变量)<br>第二行：字段类型(字段类型支持：int,float,bool,string)<br>如需增加新的字段类型读写规则，请在任务列表中找到对应的位置添加对应字段类型处理规则即可<br>(如修改规则，请更改 ExcelTool 脚本中的 BEGIN_VARIABLE_TYPE_INDEX 变量)<br>第三行：主键(key)，通过key来标识唯一主键(Json文件默认 id 为主键，不以自定义key为规则)<br>(如修改规则，请更改 ExcelTool 脚本中的 BEGIN_KEY_INDEX 变量)<br>第四行：描述信息(可选：增加注释，便于阅读理解)<br>(如修改规则，请更改 ExcelTool 脚本中的 BEGIN_DESCRIPTION_INDEX 变量)<br>第五行~第n行：具体数据信息<br>Excel 下的表名决定数据结构类名，容器类名，二进制文件名<br>(如修改规则，请更改 ExcelTool 脚本中的 BEGIN_INDEX 变量)</p><p>目前只支持int、float、bool、string四种数据类型配置表读取，如需增加，可直接打开ExcelTool脚本找到TODO任务列表添加即可。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/QZGameFramework/ExcelTool1.png" alt="ExcelTool1"></p><h4 id="ABTool-——-资源服务器AB包上传工具">ABTool —— 资源服务器AB包上传工具</h4><blockquote><p>本工具提供了AB包一键上传AB资源文件到指定资源服务器。使用的是MD5码加密生成的AB包对比文件。下载配合使用ABUpdateMgr脚本使用即可。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/QZGameFramework/ABTool1.png" alt="ABTool1"></p><h4 id="LuaTool-——-Lua脚本一键生成txt后缀并移动到指定AB包和文件夹工具">LuaTool —— Lua脚本一键生成txt后缀并移动到指定AB包和文件夹工具</h4><blockquote><p>本工具是为了方便Lua文件的迁移。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/QZGameFramework/LuaTool1.png" alt="LuaTool1"></p><h4 id="DialogueTool-——-对话树编辑器工具">DialogueTool —— 对话树编辑器工具</h4><blockquote><p>利用树的特性和UIToolkit编写的一个对话树插件，快速编辑剧情对话分支。对应的每个节点的具体行为逻辑，继承顺序节点和分支节点的基类重写对应方法即可。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/QZGameFramework/DialogueTreeTool.png" alt="DialogueTreeTool"></p><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/QZGameFramework/DialogueTreeTool1.png" alt="DialogueTreeTool"></p><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/QZGameFramework/DialogueTreeTool2.png" alt="DialogueTreeTool"></p><h4 id="BehaviourTreeTool-——-行为树编辑器">BehaviourTreeTool —— 行为树编辑器</h4><blockquote><p>一个简单的可视化行为树编辑器工具，自定义节点，只需要继承指定的Action类，decoration等节点类即可。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/QZGameFramework/BehaviourTool1.png" alt="BehaviourTool"></p><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/QZGameFramework/BehaviourTool2.png" alt="BehaviourTool"></p><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/QZGameFramework/BehaviourTool3.png" alt="BehaviourTool"></p><h3 id="Unity框架">Unity框架</h3><h4 id="成就管理器">成就管理器</h4><blockquote><p>一个简易的使用观察者实现的成就系统，待完善。</p></blockquote><h4 id="事件中心模块">事件中心模块</h4><blockquote><p>分发消息</p></blockquote><h4 id="有限状态机模块">有限状态机模块</h4><blockquote><p>通用的FSM系统：状态包含一个数据黑板。</p></blockquote><h4 id="输入系统">输入系统</h4><blockquote><p>命令模式实现的一个旧输入系统监听操纵。</p></blockquote><h4 id="背包系统">背包系统</h4><blockquote><p>待完善</p></blockquote><h4 id="音乐管理系统">音乐管理系统</h4><blockquote><p>结合对象池和资源加载模块实现的音乐管理器</p></blockquote><h4 id="对象池模块">对象池模块</h4><blockquote></blockquote><h4 id="包管理器模块">包管理器模块</h4><h4 id="数据持久化模块">数据持久化模块</h4><h4 id="场景切换管理器">场景切换管理器</h4><h4 id="单例模式管理器">单例模式管理器</h4><blockquote><p>这是一个管理全局所有单例的模块：管理全局所有的单例，相对于传统的单例模式创建，这样更便于对单例的管理和销毁，且如果需要进行帧更新的单例可以继承IUpdateSingleton接口即可实现单例帧更新函数OnUpdate，且这个帧更新的单例可以单独设置优先级，控制单例的帧更新顺序。</p></blockquote><h4 id="自动化UI框架">自动化UI框架</h4><blockquote><p>搭建好界面后，一键生成通用UI窗口脚本和UI元素脚本并挂载在窗口GameObject上</p></blockquote><h4 id="Timer计时器">Timer计时器</h4><h4 id="SceneName特性">SceneName特性</h4><blockquote><p>[SceneName]特性标记string变量，可快速在Inspector窗口通过下拉框选择场景</p></blockquote><h4 id="ReadOnly特性">ReadOnly特性</h4><blockquote><p>编辑在Inspector显示但只读的变量属性，可通过后面的单选框开启关闭只读绘制。</p></blockquote>]]></content>
    
    
    <summary type="html">这是一个自研框架，目前适用大部分Unity游戏开发，欠缺AB包模块和热更模块。</summary>
    
    
    
    <category term="框架搭建" scheme="https://azzurebubble.github.io/categories/%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/C/"/>
    
    <category term="Unity框架" scheme="https://azzurebubble.github.io/categories/%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/C/Unity%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Unity3D" scheme="https://azzurebubble.github.io/tags/Unity3D/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="游戏框架" scheme="https://azzurebubble.github.io/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>UnityEdior</title>
    <link href="https://azzurebubble.github.io/posts/ec874c57.html"/>
    <id>https://azzurebubble.github.io/posts/ec874c57.html</id>
    <published>2023-12-06T00:56:01.000Z</published>
    <updated>2024-04-20T01:10:48.249Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/UnityEditor/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%8A%A8%E5%9B%BE.gif" alt="插入排序"></p><blockquote><p>UnityEditor编辑器的代码必须放在Editor文件夹下，因为这个文件夹下的代码是不会被打包出去，只允许程序员在Unity编辑器下使用，如果不放在Editor这个文件夹下，打包时若包含UnityEditor的代码，会报错。</p></blockquote><h4 id="MenuItem">MenuItem</h4><h5 id="1-使用方法-MenuItem-“path”">1.使用方法:[MenuItem(“path”)]</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">EditorExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MenuItemExample</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// [MenuItem()] 修饰的必须是一个静态方法</span></span><br><span class="line">        <span class="comment">// 才会在Unity菜单栏出现先对应的按键</span></span><br><span class="line">        <span class="comment">// ()括号里的是这个方法在菜单栏的树形路径</span></span><br><span class="line">        [<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/EditorTest&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EditorTest</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;Hello Editor&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-Application-OpenURL-“path”-打开一个网址或者一个Application应用">2.Application.OpenURL(“path”) 打开一个网址或者一个Application应用</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/OpenBilibili&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenBilibili</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可以通过这个Api接口打开一个网址或者一个Application应用</span></span><br><span class="line">    Application.OpenURL(<span class="string">&quot;Http://bilibili.com&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-EditorUtility-RevealInFinder-“path”-打开一个指定的文件目录">3.EditorUtility.RevealInFinder(“path”) 打开一个指定的文件目录</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/打开策划目录&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenDesignFolder</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打开一个指定的文件目录 参数是一个文件的路径</span></span><br><span class="line">    EditorUtility.RevealInFinder(Application.dataPath.Replace(<span class="string">&quot;Assets&quot;</span>, <span class="string">&quot;Library&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-Menu-SetChecked-“path”-isChecked-可勾选的菜单栏">4.Menu.SetChecked(“path”,isChecked) 可勾选的菜单栏</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> openShotCut = <span class="literal">false</span>; <span class="comment">// 记录菜单栏勾选状态</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/快捷键开关&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ToggleShotCut</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    openShotCut = !openShotCut; <span class="comment">// 切换状态</span></span><br><span class="line">    Menu.SetChecked(<span class="string">&quot;EditorExtensions/MenuItem/快捷键开关&quot;</span>, openShotCut);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-MenuItem的快捷键设置">5.MenuItem的快捷键设置</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/EditorTestWithShotCut _c&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EditorTestWithShotCut</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 常用快捷键码</span></span><br><span class="line">    <span class="comment">// # -&gt; Shift &amp; -&gt; Alt % -&gt; Ctrl/Command</span></span><br><span class="line">    <span class="comment">// _a-z A-Z - a-z A-Z</span></span><br><span class="line">    Debug.Log(<span class="string">&quot;键盘C键的快捷键呼出菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/OpenBilibiliWithShotCut %#e&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenBilibiliWithShotCut</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    EditorUtility.RevealInFinder(Application.persistentDataPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-MenuItem-“path”-validate-true">6.[MenuItem(“path”, validate = true)]</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> openShotCut = <span class="literal">false</span>; <span class="comment">// 记录菜单栏勾选状态</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/快捷键开关&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ToggleShotCut</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    openShotCut = !openShotCut; <span class="comment">// 切换状态</span></span><br><span class="line">    Menu.SetChecked(<span class="string">&quot;EditorExtensions/MenuItem/快捷键开关&quot;</span>, openShotCut);</span><br><span class="line">&#125;</span><br><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/EditorTestWithShotCut _c&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EditorTestWithShotCut</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 常用快捷键码</span></span><br><span class="line">    <span class="comment">// # -&gt; Shift &amp; -&gt; Alt % -&gt; Ctrl/Command</span></span><br><span class="line">    <span class="comment">// _a-z A-Z - a-z A-Z</span></span><br><span class="line">    Debug.Log(<span class="string">&quot;键盘C键的快捷键呼出菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// openShotCut 为true时才能被使用</span></span><br><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/EditorTestWithShotCut %#e&quot;</span>, validate = true)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">EditorTestWithShotCutValidate</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> openShotCut;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/OpenBilibiliWithShotCut %#e&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenBilibiliWithShotCut</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    EditorUtility.RevealInFinder(Application.persistentDataPath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/OpenBilibiliWithShotCut %#e&quot;</span>, validate = true)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">OpenBilibiliWithShotCutValidate</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> openShotCut;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-EditorApplication-ExecuteMenuItem-“同名path”-复用MenuItem">7. EditorApplication.ExecuteMenuItem(“同名path”) 复用MenuItem</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/EditorTestWithShotCut _c&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EditorTestWithShotCut</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"> EditorApplication.ExecuteMenuItem(<span class="string">&quot;EditorExtensions/MenuItem/EditorTest&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="EditorWindow">EditorWindow</h4><h5 id="1-绘制一个编辑器窗口">1.绘制一个编辑器窗口</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/IMGUI/OpenGUILayoutExample&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenGUILayoutExample</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"> GUILayoutExample window = GetWindow&lt;GUILayoutExample&gt;();</span><br><span class="line"> window.Show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"> GUILayout.Label(<span class="string">&quot;Hello IMGUI&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/UnityEditor/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%8A%A8%E5%9B%BE.gif&quot; alt</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="Unity" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/Unity/"/>
    
    
    <category term="Unity" scheme="https://azzurebubble.github.io/tags/Unity/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="UnityEditor" scheme="https://azzurebubble.github.io/tags/UnityEditor/"/>
    
  </entry>
  
  <entry>
    <title>算法——最短路径算法</title>
    <link href="https://azzurebubble.github.io/posts/17cfe08f.html"/>
    <id>https://azzurebubble.github.io/posts/17cfe08f.html</id>
    <published>2023-08-01T12:45:09.000Z</published>
    <updated>2024-04-20T01:10:50.275Z</updated>
    
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="最短路径算法" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="最短路径算法" scheme="https://azzurebubble.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法——最小生成树算法</title>
    <link href="https://azzurebubble.github.io/posts/3cf1d1bf.html"/>
    <id>https://azzurebubble.github.io/posts/3cf1d1bf.html</id>
    <published>2023-08-01T12:44:34.000Z</published>
    <updated>2024-04-20T01:10:50.274Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>线性表</strong>：由同种数据类型的数据元素组成的有序序列。一般用于存储由顺序关系的数据序列。</p><p><strong>树</strong>：树存储结构不允许存在环路。</p><p><strong>图</strong>：图存储结构中可以存在环路。</p><p><strong>连通图</strong>：从任一顶点到另一个顶点都至少存在一条通路。</p><p><strong>非连通图</strong>：只要有某两个顶点之间找不到通路。</p><p><strong>生成树</strong>：包含图中所有的顶点。任意顶点之间有且仅有一条通路。</p><p><strong>最小生成树</strong>：指的就是在连通网中找到的总权值最小的生成树。常用的两种算法：</p><ul><li><strong>普里姆（Prim）算法</strong></li><li><strong>克鲁斯卡尔（kruskal）算法</strong></li></ul></blockquote><h4 id="普里姆（Prim）算法">普里姆（Prim）算法</h4><blockquote><p><strong>普里姆（Prim）算法</strong>：任选一个顶点出发，每次都选权值最小的边的顶点与原顶点相连。</p><p>采用的是贪心算法的思想。</p><ul><li>时间复杂度=O(n<sup>2</sup>)（n 为顶点数）</li><li>适用于<strong>稠密图</strong>，算法思想是选择<strong>点</strong></li></ul><p><strong>实现思路：</strong></p><ol><li>将连通网中的所有顶点分为两类（假设为 A 类和 B 类）。初始状态下，所有顶点位于 B 类；</li><li>选择任意一个顶点，将其从 B 类移动到 A 类；</li><li>从 B 类的所有顶点出发，找出一条连接着 A 类中的某个顶点且权值最小的边，将此边连接着的 A 类中的顶点移动到 B 类；</li><li>重复执行第 3 步，直至 B 类中的所有顶点全部移动到 A 类，恰好可以找到 N-1 条边。</li></ol></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><blockquote></blockquote><hr><h4 id="克鲁斯卡尔（kruskal）算法">克鲁斯卡尔（kruskal）算法</h4><blockquote><p><strong>克鲁斯卡尔（kruskal）算法</strong>：把所有顶点包含在生成树中，对边进行排序，然后直接选取权值最小的边加入到新生成的树中，途中不能形成环，直到所有顶点都连通为止。</p><ul><li>时间复杂度=O(elog<sub>2</sub>e)（e 为边数）</li><li>适用于<strong>稀疏图</strong>，算法思想是选择<strong>边</strong></li></ul></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><blockquote></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;线性表&lt;/strong&gt;：由同种数据类型的数据元素组成的有序序列。一般用于存储由顺序关系的数据序列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;树&lt;/strong&gt;：树存储结构不允许存在环路。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图&lt;/strong&gt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="最小生成树算法" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="最小生成树算法" scheme="https://azzurebubble.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法——查找算法</title>
    <link href="https://azzurebubble.github.io/posts/f43b98cb.html"/>
    <id>https://azzurebubble.github.io/posts/f43b98cb.html</id>
    <published>2023-08-01T12:43:16.000Z</published>
    <updated>2024-04-20T01:10:50.275Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>查找</strong>（<code>Search</code>）：是在一个数据集合中查找满足给定条件的记录。对于查找问题来说，没有一种算法对于任何情况下都是合适的。</p><p><strong>查找表</strong>（<code>Search Table</code>）：是由同一类型的数据元素（或记录）构成的集合。对查找表经常进行的操作：</p><ol><li>查询某个数据元素是否在查找表中**（静态查找表）**</li><li>检索某个数据元素的属性**（静态查找表）**</li><li>向查找表中添加一个数据元素**（动态查找表）**</li><li>向查找表中删除一个数据元素**（动态查找表）**</li></ol></blockquote><hr><h4 id="顺序查找算法">顺序查找算法</h4><blockquote><p><strong>顺序查找</strong>：又称<strong>顺序搜索算法</strong>或者<strong>线性搜索算法</strong>，是所有查找算法中最基本、最简单的。</p><p><strong>基本思想</strong>：从查找表的一端开始，顺序扫描线性表，逐个同记录的关键字作比较，如果匹配成功，则查找成功；反之，直到最后一个关键字都没有匹配成功，则为失败。</p><ul><li>时间复杂度=O(n)，空间复杂度=O(1)；最好时间复杂度为O(1)；</li><li>适用于绝大多数场景，既可以在有序序列中查找目标元素，也可以在无序序列中查找目标元素。</li><li>静态查找表既可以使用顺序表表示，也可以使用链表结构表示。</li><li>优点：算法简单而且使用面广。</li><li>缺点：查找效率较低，特别是当待查找集合中元素较多时，不推荐使用顺序查找。</li></ul></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">10</span>, <span class="number">14</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">31</span>, <span class="number">33</span>, <span class="number">35</span>, <span class="number">42</span>, <span class="number">44</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span> index = linear_search(arr, <span class="number">33</span>);</span><br><span class="line">        <span class="keyword">if</span> (index != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;查找成功！序列为第<span class="subst">&#123;index + <span class="number">1</span>&#125;</span>个元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;查找失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">linear_search</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == <span class="keyword">value</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>查找成功！序列为第7个元素</p></blockquote><hr><h4 id="二分查找算法">二分查找算法</h4><blockquote><p><strong>二分查找</strong>：又称<strong>折半查找、二分搜索、折半搜索</strong>等，是在分治算法基础上设计出来的查找算法。</p><p><strong>基本思想</strong>：将表中间位置记录的关键字与查找关键字比较，若相等，则查找成功；否则利用中间位置记录将表分为前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。</p><ul><li>时间复杂度=O(log<sub>2</sub>n)，循环方式：空间复杂度=O(1)，递归方式：时间复杂度=O(log<sub>2</sub>n)</li><li>数组元素必须有序，查找的数值不能多个，只能一个。必须采用顺序存储结构。</li><li>优点：比较次数少，查找速度块，平均性能好。</li><li>缺点：必须要求待查表为有序表；插入删除困难。</li></ul></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">10</span>, <span class="number">14</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">31</span>, <span class="number">33</span>, <span class="number">35</span>, <span class="number">42</span>, <span class="number">44</span> &#125;;</span><br><span class="line">        <span class="comment">//int index = binary_search1(arr, 0, 9, 31);</span></span><br><span class="line">        <span class="built_in">int</span> index = binary_search2(arr, <span class="number">0</span>, <span class="number">9</span>, <span class="number">31</span>);</span><br><span class="line">        <span class="keyword">if</span> (index != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;查找成功！序列为第<span class="subst">&#123;index + <span class="number">1</span>&#125;</span>个元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;查找失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">binary_search1</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> start, <span class="built_in">int</span> end, <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> == arr[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> &lt; arr[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> binary_search1(arr, start, mid - <span class="number">1</span>, <span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> binary_search1(arr, mid + <span class="number">1</span>, end, <span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非递归</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">binary_search2</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> start, <span class="built_in">int</span> end, <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> left = start;</span><br><span class="line">        <span class="built_in">int</span> right = end;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == <span class="keyword">value</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">value</span> &lt; arr[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>查找成功！序列为第6个元素</p></blockquote><hr><h4 id="插值查找算法">插值查找算法</h4><blockquote><p><strong>插值查找</strong>：又称为<strong>插值搜索算法</strong>，是在二分查找算法的基础上改进的一种查找算法，将查找点的选择改进位自适应选择，提高查找效率。</p><p><strong>基本思想</strong>：插值查找类似平时我们查字典的时候，查一个以 s 开头的单词时，绝对不会用二分查找，从字典的中间第一页开始，因为我们知道它的大概位置是在字典的较后面部分，所以可以从后面的某处查起。我们先从首字母 s 的地方开始查找，然后再根据第二个字母在字母表中的位置，找到对应位置再继续查找，这样重复这个过程，直到找到我们查找的这个单词这就是插值查找的基本思想</p><ul><li>顺序存储的有序数列，根据关键字在数据中均匀分布。</li><li>比较元素的位置公式：</li></ul><p>$$<br>Mid = Begin + ( (End - Begin) / (A[End] - A[Begin]) ) * (X - A[Begin])<br>$$</p><ul><li>Mid：计算得出的元素的位置；</li><li>End：搜索区域内最后一个元素所在的位置；</li><li>Begin：搜索区域内第一个元素所在的位置；</li><li>X：要查找的目标元素；</li><li>A[]：表示整个待搜索序列。</li></ul></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span> index = interpolation_search(arr, <span class="number">0</span>, <span class="number">9</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">if</span> (index != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;查找成功！序列为第<span class="subst">&#123;index + <span class="number">1</span>&#125;</span>个元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;查找失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">interpolation_search</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> begin, <span class="built_in">int</span> end, <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (begin &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果查找表中只有一个元素，则比较该元素和待查元素的值</span></span><br><span class="line">        <span class="keyword">if</span> (begin == end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[begin] == <span class="keyword">value</span> ? begin : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据公式找到中间元素的所在位置</span></span><br><span class="line">        <span class="built_in">int</span> mid = ((end - begin) / (arr[end] - arr[begin]) * (<span class="keyword">value</span> - arr[begin]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归出口</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> == arr[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归查询</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> &lt; arr[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> interpolation_search(arr, begin, mid - <span class="number">1</span>, <span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> interpolation_search(arr, mid + <span class="number">1</span>, end, <span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>查找成功！序列为第5个元素</p></blockquote><hr><h4 id="哈希查找算法">哈希查找算法</h4><blockquote><p><strong>哈希查找</strong>：又称<strong>散列查找算法</strong>，是一种借助哈希表（散列表）查找目标元素的方法，查找效率最高时对应的时间复杂度位O(2)。</p><p><strong>哈希表</strong>：又称散列表，是一种存储结构，通常用来存储多个元素。和其它存储结构（线性表、树等）相比，哈希表查找目标元素的效率非常高。每个存储到哈希表中的元素，都配有一个唯一的标识（又称“索引”或者“键”），用户想查找哪个元素，凭借该元素对应的标识就可以直接找到它，无需遍历整个哈希表。</p><ul><li>适用于大多数场景，既支持有序序列，也支持无序序列。</li><li>常见的散列函数：直接定址法，除留余数法，平方取余法等</li><li>处理冲突的方法：开放定址法，线性探测法，拉链法等</li><li>影响冲突的主要三个因素：<ul><li>散列函数是否均匀</li><li>处理冲突的方法</li><li>散列表的装填因子</li></ul></li></ul></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">5</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">55</span>, <span class="number">50</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span>[] hashArr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>];</span><br><span class="line">        CreateHash(arr, hashArr);</span><br><span class="line">        <span class="built_in">int</span> index = hash_search(hashArr, <span class="number">20</span>);</span><br><span class="line">        <span class="keyword">if</span> (index != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;查找成功！序列为第<span class="subst">&#123;index + <span class="number">1</span>&#125;</span>个元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;查找失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">hash</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">value</span> % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建哈希表</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateHash</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span>[] hashArr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> i, index;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 通过哈希函数计算当前元素在哈希表中的位置</span></span><br><span class="line">            index = hash(arr[i]);</span><br><span class="line">            <span class="keyword">while</span> (hashArr[index] != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            hashArr[index] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">hash_search</span>(<span class="params"><span class="built_in">int</span>[] hashArr, <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过哈希函数计算得到待查元素的下标</span></span><br><span class="line">        <span class="built_in">int</span> hashIndex = hash(<span class="keyword">value</span>);</span><br><span class="line">        <span class="comment">// 如果发生冲突，则使用线性探测法向后探测</span></span><br><span class="line">        <span class="keyword">while</span> (hashArr[hashIndex] != <span class="keyword">value</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            hashIndex = (hashIndex + <span class="number">1</span>) % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 如果探测位置为空</span></span><br><span class="line">            <span class="keyword">if</span> (hashArr[hashIndex] == <span class="number">0</span> || hashIndex == hash(<span class="keyword">value</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hashIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>查找成功！序列为第2个元素</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;查找&lt;/strong&gt;（&lt;code&gt;Search&lt;/code&gt;）：是在一个数据集合中查找满足给定条件的记录。对于查找问题来说，没有一种算法对于任何情况下都是合适的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查找表&lt;/strong&gt;（&lt;code</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="查找算法" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="查找算法" scheme="https://azzurebubble.github.io/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法——归并/计数/基数/桶排序</title>
    <link href="https://azzurebubble.github.io/posts/23241932.html"/>
    <id>https://azzurebubble.github.io/posts/23241932.html</id>
    <published>2023-07-28T14:41:30.000Z</published>
    <updated>2024-04-20T01:10:50.268Z</updated>
    
    <content type="html"><![CDATA[<h4 id="归并排序">归并排序</h4><blockquote><p>归并排序：将两个或两个以上的有序子序列<code>归并</code>为一个有序序列。基于分治思想。</p><ul><li>时间复杂度=O(nlog<sub>2</sub>n)，空间复杂度=O(n)。稳定排序</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" alt="归并排序"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = &#123; <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;未排序前的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        merge_sort(arr, <span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 分割数组</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge_sort</span>(<span class="params"><span class="built_in">int</span>[] arr,<span class="built_in">int</span> start,<span class="built_in">int</span> end</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span>(arr == <span class="literal">null</span> || start &gt;= end)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">int</span> mid = (start + end) / <span class="number">2</span>; <span class="comment">// 取得数组中间值下标</span></span><br><span class="line">         <span class="comment">// 继续分割</span></span><br><span class="line">         merge_sort(arr,start,mid);</span><br><span class="line">         merge_sort(arr,mid + <span class="number">1</span>,end);</span><br><span class="line">         merge(arr,start,mid,end);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="function">privatr <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span>(<span class="params"><span class="built_in">int</span>[] arr,<span class="built_in">int</span> start,<span class="built_in">int</span> mid,<span class="built_in">int</span> end</span>)<span class="comment">// 1 1 2</span></span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">int</span> left = mid - start + <span class="number">1</span>; <span class="comment">// 获得左边数组元素个数 </span></span><br><span class="line">         <span class="built_in">int</span> right = end - mid; <span class="comment">// 获得右边数组元素个数 </span></span><br><span class="line">         <span class="built_in">int</span> leftArr = <span class="keyword">new</span> <span class="built_in">int</span>[left + <span class="number">1</span>]; </span><br><span class="line">         <span class="built_in">int</span> rightArr = <span class="keyword">new</span> <span class="built_in">int</span>[right + <span class="number">1</span>]; </span><br><span class="line">         <span class="built_in">int</span> i;</span><br><span class="line">         <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; left; i++)</span><br><span class="line">         &#123;</span><br><span class="line">             leftArr[i] = arr[start - <span class="number">1</span> + i]; </span><br><span class="line">         &#125;</span><br><span class="line">         leftArr[i] = <span class="number">2147483647</span>; <span class="comment">// 把数组最后一个元素设置为最大值</span></span><br><span class="line">         <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; right; i++)</span><br><span class="line">         &#123;</span><br><span class="line">             rightArr[i] = arr[mid + i];</span><br><span class="line">         &#125;</span><br><span class="line">         leftArr[i] = <span class="number">2147483647</span>; <span class="comment">// 把数组最后一个元素设置为最大值</span></span><br><span class="line">         <span class="built_in">int</span> j = <span class="number">0</span>;</span><br><span class="line">         i = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="built_in">int</span> k = start; k &lt; end; k++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(leftArr[i] &lt;= rightArr[j])</span><br><span class="line">             &#123;</span><br><span class="line">                 arr[k - <span class="number">1</span>] = leftArr[i];</span><br><span class="line">                 i++;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">                 arr[k - <span class="number">1</span>] = rightArr[j];</span><br><span class="line">                 j++;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>未排序前的数组：<br>5 7 3 8 6 9 4 2<br>排序后的数组：<br>2 3 4 5 6 7 8 9</p></blockquote><hr><h4 id="计数排序">计数排序</h4><blockquote><p>计数排序：通过统计序列中各个元素出现的次数，完成对整个序列的升序或降序排序。（元素之间最好是在0~9之间的数值差）</p><ul><li>时间复杂度=O(n+k)，空间复杂度=O(n+k)。稳定排序</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="计数排序"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = &#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;未排序前的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        countingSort(arr);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">get_max</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countingSort</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> length = arr.Length;</span><br><span class="line">        <span class="comment">// 找出数组中的最大值</span></span><br><span class="line">        <span class="built_in">int</span> max = get_max(arr);</span><br><span class="line">        <span class="built_in">int</span>[] array = <span class="keyword">new</span> <span class="built_in">int</span>[max + <span class="number">1</span>]; <span class="comment">// 创建一个统计元素出现次数的数组</span></span><br><span class="line">        <span class="built_in">int</span>[] output = <span class="keyword">new</span> <span class="built_in">int</span>[length]; <span class="comment">// 排序数组</span></span><br><span class="line">        <span class="comment">// 统计元素出现个数，存储在对应的位置上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            array[arr[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 累加出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; max + <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            array[i] += array[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据次数进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            output[array[arr[i]] - <span class="number">1</span>] = arr[i];</span><br><span class="line">            array[arr[i]]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 复制到arr数组中 2, 4, 1, 2, 5, 3, 4, 8, 7</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = output[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>未排序前的数组：<br>2 4 1 2 5 3 4 8 7<br>排序后的数组：<br>1 2 2 3 4 4 5 7 8</p></blockquote><hr><h4 id="基数排序">基数排序</h4><blockquote><p>基数排序：数字逐位比较。</p><ul><li>时间复杂度=O(n×m)，空间复杂度=O(n×m)。稳定排序。n:数据个数，m:数据位数。</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="基数排序"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = &#123; <span class="number">121</span>, <span class="number">432</span>, <span class="number">564</span>, <span class="number">23</span>, <span class="number">1</span>, <span class="number">45</span>, <span class="number">788</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;未排序前的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        radixSort(arr);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">getMax</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countingSort</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> place</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> length = arr.Length;</span><br><span class="line">        <span class="built_in">int</span>[] output = <span class="keyword">new</span> <span class="built_in">int</span>[length];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> max = (arr[<span class="number">0</span>] / place) % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (((arr[i] / place) % <span class="number">10</span>) &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = (arr[i] / place) % <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span>[] count = <span class="keyword">new</span> <span class="built_in">int</span>[max + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            count[(arr[i] / place) % <span class="number">10</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; max + <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一定要从后往前排</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            output[count[(arr[i] / place) % <span class="number">10</span>] - <span class="number">1</span>] = arr[i];</span><br><span class="line">            count[(arr[i] / place) % <span class="number">10</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = output[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> max = getMax(arr);</span><br><span class="line">        <span class="comment">// 根据最高位数，从低位依次进行计数排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; max / i &gt; <span class="number">0</span>; i *= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            countingSort(arr, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>未排序前的数组：<br>121 432 564 23 1 45 788<br>排序后的数组：<br>1 23 45 121 432 564 788</p></blockquote><hr><h4 id="桶-箱排序">桶/箱排序</h4><blockquote><p>桶/箱排序：待排序数组，分配到若干个桶，各自执行排序任务。是一种基于分治思想、效率很高的排序算法。(适用于数据范围较小且分布均匀的浮点数数据)</p><ul><li>时间复杂度=O(n+m+n(logn-logm))，空间复杂度=O(n+m)。稳定排序。n:数据个数，m:数据位数。</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E6%A1%B6%E6%8E%92%E5%BA%8F.gif" alt="桶排序"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;归并排序&quot;&gt;归并排序&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;归并排序：将两个或两个以上的有序子序列&lt;code&gt;归并&lt;/code&gt;为一个有序序列。基于分治思想。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度=O(nlog&lt;sub&gt;2&lt;/sub&gt;n)，空间复杂度=O(n)</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="排序算法" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="排序算法" scheme="https://azzurebubble.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法——选择排序</title>
    <link href="https://azzurebubble.github.io/posts/18d056c9.html"/>
    <id>https://azzurebubble.github.io/posts/18d056c9.html</id>
    <published>2023-07-25T16:08:58.000Z</published>
    <updated>2024-04-20T01:10:50.272Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简单选择排序">简单选择排序</h4><blockquote><p>简单选择排序：在待排序的数据中选出最大（小）的元素放在其最终的位置。</p><ul><li>时间复杂度=O(n<sup>2</sup>)，空间复杂度=O(1)。稳定排序。</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%8A%A8%E5%9B%BE.gif" alt="选择排序动图"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = &#123; <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;未排序前的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        selection_sort(arr);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selection_sort</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> length = arr.Length;</span><br><span class="line">        <span class="built_in">int</span> i, j, min;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            min = i; <span class="comment">// 把第一个元素假设为最小</span></span><br><span class="line">            <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 从第二个元素开始遍历到最后一个</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[min])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 如果期间出现小于最小元素的值，则交换位置</span></span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (min != i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[min];</span><br><span class="line">                arr[min] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>未排序前的数组：<br>5 7 3 8 6 9<br>排序后的数组：<br>3 5 6 7 8 9</p></blockquote><hr><h4 id="堆排序">堆排序</h4><blockquote><p>堆排序：堆的是指就是满足二叉树中任一非叶子结点均小于（大于）它的孩子结点的完全二叉树。</p><ul><li>时间复杂度=O(nlog<sub>2</sub>n)，空间复杂度=O(1)。不稳定排序。</li><li>小根堆：若n个元素的序列{a<sub>1</sub>a<sub>2</sub>…a<sub>n</sub>}满足a<sub>i</sub> ≤ a<sub>2i</sub>和a<sub>i</sub> ≤ a<sub>2i+1</sub>。</li><li>大根堆：若n个元素的序列{a<sub>1</sub>a<sub>2</sub>…a<sub>n</sub>}满足a<sub>i</sub> ≥ a<sub>2i</sub>和a<sub>i</sub> ≥ a<sub>2i+1</sub>。</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E5%A0%86%E6%8E%92%E5%BA%8F.gif" alt="堆排序"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = &#123; <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;未排序前的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        <span class="comment">//big_heap_sort(arr);</span></span><br><span class="line">        small_heap_sort(arr);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">big_heap_sort</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从树的第arr.Length / 2 - 1个结点开始建立大根堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = arr.Length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            big_heap_adjust(arr, i, arr.Length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = arr.Length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 把根结点与最后一个结点进行交换，把最大值放到最后</span></span><br><span class="line">            <span class="built_in">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">            <span class="comment">// 交换后，以根结点开始，重新调整为大根堆</span></span><br><span class="line">            big_heap_adjust(arr, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立大根堆：升序，最大值（根结点）与最后一个结点交换位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">big_heap_adjust</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> parent, <span class="built_in">int</span> length</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 临时存储根结点数值</span></span><br><span class="line">        <span class="built_in">int</span> temp = arr[parent];</span><br><span class="line">        <span class="comment">// 找到根结点的左孩子</span></span><br><span class="line">        <span class="built_in">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 孩子结点不大于数组长度</span></span><br><span class="line">        <span class="keyword">while</span> (child &lt; length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果右孩子在数组长度内 &amp;&amp; 右孩子 &gt; 左孩子</span></span><br><span class="line">            <span class="keyword">if</span> (child + <span class="number">1</span> &lt; length &amp;&amp; arr[child + <span class="number">1</span>] &gt; arr[child])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 设置为右孩子</span></span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果根结点 &gt; 孩子结点</span></span><br><span class="line">            <span class="keyword">if</span> (temp &gt; arr[child])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 退出+</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则，根结点与最大的孩子结点交换位置</span></span><br><span class="line">            arr[parent] = arr[child];</span><br><span class="line">            <span class="comment">// 根结点设置为交换后的孩子结点下标</span></span><br><span class="line">            parent = child;</span><br><span class="line">            <span class="comment">// 找到新的左孩子下标</span></span><br><span class="line">            child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时parent已为最小的孩子结点，把temp放到此位置上</span></span><br><span class="line">        arr[parent] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">small_heap_sort</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = arr.Length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            small_heap_sort(arr, i, arr.Length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = arr.Length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">            small_heap_sort(arr, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小根堆:降序，最小值（根结点）与最后一个结点交换位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">small_heap_sort</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> parent, <span class="built_in">int</span> length</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> temp = arr[parent];</span><br><span class="line">        <span class="built_in">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (child &lt; length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (child + <span class="number">1</span> &lt; length &amp;&amp; arr[child + <span class="number">1</span>] &lt; arr[child])</span><br><span class="line">            &#123;</span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp &lt; arr[child])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[parent] = arr[child];</span><br><span class="line">            parent = child;</span><br><span class="line">            child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[parent] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;简单选择排序&quot;&gt;简单选择排序&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;简单选择排序：在待排序的数据中选出最大（小）的元素放在其最终的位置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度=O(n&lt;sup&gt;2&lt;/sup&gt;)，空间复杂度=O(1)。稳定排序。&lt;/li&gt;
&lt;/u</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="排序算法" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="排序算法" scheme="https://azzurebubble.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="选择排序" scheme="https://azzurebubble.github.io/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序算法——插入排序</title>
    <link href="https://azzurebubble.github.io/posts/cd5503e2.html"/>
    <id>https://azzurebubble.github.io/posts/cd5503e2.html</id>
    <published>2023-07-24T11:43:40.000Z</published>
    <updated>2024-04-20T01:10:50.271Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在有序序列中插入一个元素，保持序列有序，有序长度不断增加。</p></blockquote><h4 id="直接插入排序">直接插入排序</h4><blockquote><p>直接插入排序：采用顺序查找法查找插入位置。</p><ul><li>原始数据越接近有序，排序速度越快。</li><li>时间复杂度=O(n<sup>2</sup>)，空间复杂度=O(1)。稳定排序。</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%8A%A8%E5%9B%BE.gif" alt="插入排序"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = &#123; <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;未排序前的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        insert_sort(arr);</span><br><span class="line">        <span class="comment">// insert_sort1(arr);</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for + while 实现</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert_sort</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> length = arr.Length;</span><br><span class="line">        <span class="comment">// 以第一个元素为基准元素，下标为0</span></span><br><span class="line">        <span class="comment">// 从第二个元素开始进行直接插入排序，下标为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 临时保存需要进行插入的元素</span></span><br><span class="line">            <span class="built_in">int</span> insert_elem = arr[i];</span><br><span class="line">            <span class="comment">// 记录当前需要进行插入排序的元素的位置</span></span><br><span class="line">            <span class="built_in">int</span> position = i;</span><br><span class="line">            <span class="comment">// 从 position 向前遍历，大于插入元素则后移，直至找到目标元素插入位置</span></span><br><span class="line">            <span class="keyword">while</span> (position &gt; <span class="number">0</span> &amp;&amp; arr[position - <span class="number">1</span>] &gt; insert_elem)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 后移</span></span><br><span class="line">                arr[position] = arr[position - <span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 向前遍历</span></span><br><span class="line">                position--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (position != i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将目标元素插入到指定位置</span></span><br><span class="line">                arr[position] = insert_elem;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 两个 for 循环</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert_sort1</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> i, j;</span><br><span class="line">        <span class="built_in">int</span> length = arr.Length;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 临时存储目标元素</span></span><br><span class="line">            <span class="built_in">int</span> temp = arr[i];</span><br><span class="line">            <span class="comment">// 从目标元素的前一个元素开始向前遍历</span></span><br><span class="line">            <span class="comment">// 直到遍历下标 &lt;= 0，并且遍历元素大于目标元素时</span></span><br><span class="line">            <span class="comment">// 将大于目标元素的元素向后移</span></span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将目标元素插入到指定位置</span></span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>未排序前的数组：<br>5 7 3 8 6 9<br>排序后的数组：<br>3 5 6 7 8 9</p></blockquote><hr><h4 id="折半插入排序">折半插入排序</h4><blockquote><p>折半插入排序：减少比较次数，但没有减少移动次数。</p><ul><li><p>平均性能优于直接插入排序。</p></li><li><p>时间复杂度=O(n<sup>2</sup>)，空间复杂度=O(1)。稳定排序。</p></li></ul></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = &#123; <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;未排序前的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        half_sort(arr);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">half_sort</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> temp, low, high, mid;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            low = <span class="number">0</span>; <span class="comment">// 左边第一个元素位置</span></span><br><span class="line">            high = i - <span class="number">1</span>; <span class="comment">// 待排元素的前一个元素</span></span><br><span class="line">            temp = arr[i]; <span class="comment">// 待排元素临时存储</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt;= high) <span class="comment">// 当 high &lt; low 时退出循环</span></span><br><span class="line">            &#123;</span><br><span class="line">                mid = low + (high - low) / <span class="number">2</span>; <span class="comment">// 取排好数组中的中间元素位置</span></span><br><span class="line">                <span class="keyword">if</span> (arr[mid] &gt; temp)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 如果中间元素大于待排元素，则high向前移动，继续比较</span></span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 如果中间元素小于待排元素，则low向后移动，继续比较</span></span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = i - <span class="number">1</span>; j &gt;= high + <span class="number">1</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[high + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>未排序前的数组：<br>5 7 3 8 6 9<br>排序后的数组：<br>3 5 6 7 8 9</p></blockquote><hr><h4 id="希尔排序">希尔排序</h4><blockquote><p>希尔排序：先将整个代排序列分割成若干子序列，分别进行直接插入排序，待整个序列中的记录<code>基本有序</code>时，再对全体记录进行一次直接插入排序。</p><ul><li><p>缩小增量，多遍插入排序。</p></li><li><p>时间复杂度=O(n<sup>1.25</sup>~1.6n<sup>1.25</sup>)，空间复杂度=O(1)，不稳定排序。不适合在链式存储结构上实现。</p></li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif" alt="希尔排序"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = &#123; <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;未排序前的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        shell_sort(arr);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shell_sort</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> length = arr.Length;</span><br><span class="line">        <span class="built_in">int</span> interval = <span class="number">1</span>; <span class="comment">// 初始化间隔为1</span></span><br><span class="line">        <span class="comment">// 计算最大间隔</span></span><br><span class="line">        <span class="keyword">while</span> (interval &lt; length / <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            interval = interval * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据间隔数，不断划分子序列，并对各子序列排序</span></span><br><span class="line">        <span class="keyword">while</span> (interval &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> i, j, temp;</span><br><span class="line">            <span class="keyword">for</span> (i = interval; i &lt; length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = arr[i];</span><br><span class="line">                j = i;</span><br><span class="line">                <span class="keyword">while</span> (j &gt; interval - <span class="number">1</span> &amp;&amp; arr[j - interval] &gt;= temp)</span><br><span class="line">                &#123;</span><br><span class="line">                    arr[j] = arr[j - interval];</span><br><span class="line">                    j -= interval;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j != i)</span><br><span class="line">                &#123;</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算新间隔</span></span><br><span class="line">            interval = (interval - <span class="number">1</span>) / <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>未排序前的数组：<br>5 7 3 8 6 9<br>排序后的数组：<br>3 5 6 7 8 9</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在有序序列中插入一个元素，保持序列有序，有序长度不断增加。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;直接插入排序&quot;&gt;直接插入排序&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;直接插入排序：采用顺序查找法查找插入位置。&lt;/p&gt;
&lt;ul&gt;
&lt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="排序算法" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="排序算法" scheme="https://azzurebubble.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="插入排序" scheme="https://azzurebubble.github.io/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序算法——交换排序</title>
    <link href="https://azzurebubble.github.io/posts/327191a2.html"/>
    <id>https://azzurebubble.github.io/posts/327191a2.html</id>
    <published>2023-07-20T11:42:10.000Z</published>
    <updated>2024-04-20T01:10:50.269Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>交换排序基本思想：两两比较，如果发生逆序则交换，直到所有记录都排好序为止。</p></blockquote><h4 id="冒泡排序">冒泡排序</h4><blockquote><p>冒泡排序：每趟不断将记录两两比较，并按“前小后大”规则交换。</p><ul><li>事件复杂度=O(n<sup>2</sup>)，空间复杂的=O(1)。稳定排序。</li><li>优点：每趟结束，不仅能挤出一个最大值到最后位置，还能同时部分理顺其他元素。</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%8A%A8%E5%9B%BE.gif" alt="冒泡排序动图"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] list = &#123; <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;未排序前的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(list[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        Bubble_sort(list);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(list[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Bubble_sort</span>(<span class="params"><span class="built_in">int</span>[] list</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> temp;</span><br><span class="line">        <span class="comment">// 比较 length - 1 趟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Length - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 每趟比较次数比前一趟少一次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; list.Length - <span class="number">1</span> - i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 两两比较元素，小的前移，大的后移</span></span><br><span class="line">                <span class="keyword">if</span> (list[j] &gt; list[j + <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    temp = list[j];</span><br><span class="line">                    list[j] = list[j + <span class="number">1</span>];</span><br><span class="line">                    list[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>未排序前的数组：<br>1 5 9 7 3<br>排序后的数组：<br>1 3 5 7 9</p></blockquote><hr><h4 id="快速排序">快速排序</h4><blockquote><p>快速排序（分治算法思想）：任取一个元素为中心，所有比它小的元素一律前放，大的后放，形成左右两个子表。</p><ul><li>最坏情况，时间复杂度=O(n<sup>2</sup>)。理想状态，时间复杂度=O(nlog<sub>2</sub>n)，空间复杂度=O(1)，不稳定排序，不是自然排序。</li><li>不适于原本有序或基本有序的记录序列进行排序。</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" alt="快速排序"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 挖坑法：用一个临时变量存储基准元素</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = &#123; <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;未排序前的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        quick_sort(arr, <span class="number">0</span>, arr.Length - <span class="number">1</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick_sort</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> left, <span class="built_in">int</span> right</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> l = left; <span class="comment">// 记录左指针元素</span></span><br><span class="line">        <span class="built_in">int</span> r = right; <span class="comment">// 记录右指针元素</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 递归退出条件：左指针 &gt;= 右指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> pivot = arr[left]; <span class="comment">// 以数组左边第一个元素为基准元素</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从数组最右开始，找到第一个比基准元素小的元素</span></span><br><span class="line">            <span class="keyword">while</span> (arr[right] &gt; pivot &amp;&amp; left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 把右边第一个比基准小的元素，放到数组左边</span></span><br><span class="line">                arr[left++] = arr[right];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从最左边找到第一个比基准元素大的元素</span></span><br><span class="line">            <span class="keyword">while</span> (arr[left] &lt; pivot &amp;&amp; left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 把左边第一个比基准大的元素，放到数组右边</span></span><br><span class="line">                arr[right--] = arr[left];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当左右指针重合退出 while 后，把基准元素放到当前 left 位置</span></span><br><span class="line">        arr[left] = pivot;</span><br><span class="line">        quick_sort(arr, l, left - <span class="number">1</span>); <span class="comment">// 递归调用快速排序，排好基准元素左边的元素</span></span><br><span class="line">        quick_sort(arr, left + <span class="number">1</span>, r); <span class="comment">// 递归调用快速排序，排好基准元素右边的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hoare版：基本思想就是用两个指针分别指向待排序数组的开头和结尾。</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = &#123; <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;未排序前的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        Hoare_quick_sort(arr, <span class="number">0</span>, arr.Length - <span class="number">1</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Hoare_quick_sort</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> left, <span class="built_in">int</span> right</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> pivot = left; <span class="comment">// 存储基准元素的下标</span></span><br><span class="line">        <span class="built_in">int</span> l = left;</span><br><span class="line">        <span class="built_in">int</span> r = right;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= arr[pivot])</span><br><span class="line">            &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= arr[pivot])</span><br><span class="line">            &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, pivot, left);</span><br><span class="line">        Hoare_quick_sort(arr, l, left - <span class="number">1</span>);</span><br><span class="line">        Hoare_quick_sort(arr, left + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> left, <span class="built_in">int</span> right</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> temp = arr[left];</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        arr[right] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>未排序前的数组：<br>5 7 3 8 6 9<br>排序后的数组：<br>3 5 6 7 8 9</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;交换排序基本思想：两两比较，如果发生逆序则交换，直到所有记录都排好序为止。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;冒泡排序&quot;&gt;冒泡排序&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;冒泡排序：每趟不断将记录两两比较，并按“前小后大”规则交</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="排序算法" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="排序算法" scheme="https://azzurebubble.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="交换排序" scheme="https://azzurebubble.github.io/tags/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法——回溯算法</title>
    <link href="https://azzurebubble.github.io/posts/69848392.html"/>
    <id>https://azzurebubble.github.io/posts/69848392.html</id>
    <published>2023-07-15T13:00:58.000Z</published>
    <updated>2024-04-20T01:10:50.274Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>回溯算法的基本思想：实际上是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现不满足求解条件时，就“回溯”返回，尝试别的路径。是一种选优搜索法，按选优条件向前搜索，以达到目标。</p><p>回溯算法经常以递归的方式实现，用来解决以下3类问题：</p><ul><li>决策问题：从众多选择中找到一个可行的解决方案；</li><li>优化问题：从众多选择中找到一个最佳的解决方案；</li><li>枚举问题：找出解决问题的所有方案。</li></ul><p>经典问题有：N皇后问题，迷宫问题等。</p></blockquote><h5 id="找到从A到K的行走路线">找到从A到K的行走路线</h5><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E2%80%94%E6%89%BE%E4%BB%8EA-K%E7%9A%84%E8%A1%8C%E8%B5%B0%E8%B7%AF%E7%BA%BF.png" alt="回溯算法—找从A-K的行走路线"></p><h5 id="解题思路：">解题思路：</h5><blockquote><p>所谓“回溯”，其实就是回退、倒退的意思。仍以图 1 为例，回溯算法查找从 A 到 K 路线的过程是：</p><ul><li>从 A 出发，先选择 A-B 路线；继续从 B 出发，先选择 B-C 路线；到达 C 点后发现无路可选，表明当前路线无法达到 K 点，该算法会立刻回退到上一个节点，也就是 B 点；</li><li>从 B 点出发，选择 B-D 路线，达到 D 点后发现无法到达 K 点，该算法再回退到 B 点；</li><li>从 B 点出发已经没有新的线路可以选择，该算法再次回退到 A 点，选择新的 A-E 路线；</li><li>继续以同样的方式测试 A-E-F-G、A-E-F-H、A-E-J-I 这 3 条线路后，最终找到 A-E-J-K 路线。</li></ul></blockquote><h3 id="回溯算法的经典应用">回溯算法的经典应用</h3><h4 id="迷宫问题">迷宫问题</h4><blockquote><p>迷宫问题是指：在给定区域内，找到一条甚至所有从某个位置到另一个位置的移动路线。如下图：在白色区域内找到一条（甚至所有）从起点到终点的路线。</p><p>解决思路：</p><ol><li>从当前位置开始，分别判断是否可以向 4 个方向（上、下、左、右）移动：</li><li>选择一个方向并移动到下个位置。判断此位置是否为终点，如果是就表示找到了一条移动路线；如果不是，在当前位置继续判断是否可以向 4 个方向移动；</li><li>如果 4 个方向都无法移动，则回退至之前的位置，继续判断其它的方向；</li><li>重复 2、3 步，最终要么成功找到可行的路线，要么回退至起点位置，表明所有的路线都已经判断完毕。</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98.png" alt="迷宫问题"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 1 表示白色区域，用 0 表示黑色区域。</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> ROW = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> COL = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> find = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">char</span>[,] maze = <span class="keyword">new</span> <span class="built_in">char</span>[,]</span><br><span class="line">        &#123;</span><br><span class="line">            &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        maze_puzzle(maze, <span class="number">0</span>, <span class="number">0</span>, ROW - <span class="number">1</span>, COL - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!find)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;该迷宫无解&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 起点：(row, col)     终点：(outRow, outCol)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maze_puzzle</span>(<span class="params"><span class="built_in">char</span>[,] maze, <span class="built_in">int</span> row, <span class="built_in">int</span> col, <span class="built_in">int</span> outRow, <span class="built_in">int</span> outCol</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        maze[row, col] = <span class="string">&#x27;Y&#x27;</span>; <span class="comment">// 将走过的区域标记为 Y</span></span><br><span class="line">        <span class="comment">// 如果走到终点，则表明起点到终点有路线</span></span><br><span class="line">        <span class="keyword">if</span> (row == outRow &amp;&amp; col == outCol)</span><br><span class="line">        &#123;</span><br><span class="line">            find = <span class="literal">true</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;成功走出迷宫，路线图是：&quot;</span>);</span><br><span class="line">            printMaze(maze);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断上方是否可移动</span></span><br><span class="line">        <span class="keyword">if</span> (canMove(maze, row - <span class="number">1</span>, col))</span><br><span class="line">        &#123;</span><br><span class="line">            maze_puzzle(maze, row - <span class="number">1</span>, col, outRow, outCol);</span><br><span class="line">            <span class="comment">// 如果程序不结束，则此路不通，恢复该区域的标志</span></span><br><span class="line">            maze[row - <span class="number">1</span>, col] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断左方是否可移动</span></span><br><span class="line">        <span class="keyword">if</span> (canMove(maze, row, col - <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            maze_puzzle(maze, row, col - <span class="number">1</span>, outRow, outCol);</span><br><span class="line">            <span class="comment">// 如果程序不结束，则此路不通，恢复该区域的标志</span></span><br><span class="line">            maze[row, col - <span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断下方是否可移动</span></span><br><span class="line">        <span class="keyword">if</span> (canMove(maze, row + <span class="number">1</span>, col))</span><br><span class="line">        &#123;</span><br><span class="line">            maze_puzzle(maze, row + <span class="number">1</span>, col, outRow, outCol);</span><br><span class="line">            <span class="comment">// 如果程序不结束，则此路不通，恢复该区域的标志</span></span><br><span class="line">            maze[row + <span class="number">1</span>, col] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断右方是否可移动</span></span><br><span class="line">        <span class="keyword">if</span> (canMove(maze, row, col + <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            maze_puzzle(maze, row, col + <span class="number">1</span>, outRow, outCol);</span><br><span class="line">            <span class="comment">// 如果程序不结束，则此路不通，恢复该区域的标志</span></span><br><span class="line">            maze[row, col + <span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">canMove</span>(<span class="params"><span class="built_in">char</span>[,] maze, <span class="built_in">int</span> row, <span class="built_in">int</span> col</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 判断输入的位置是否在迷宫范围内，且可移动，且还未移动过</span></span><br><span class="line">        <span class="keyword">return</span> row &gt;= <span class="number">0</span> &amp;&amp; row &lt;= ROW - <span class="number">1</span> &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt;= COL - <span class="number">1</span></span><br><span class="line">            &amp;&amp; maze[row, col] != <span class="string">&#x27;0&#x27;</span> &amp;&amp; maze[row, col] != <span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMaze</span>(<span class="params"><span class="built_in">char</span>[,] maze</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; ROW; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; COL; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(maze[i, j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>成功走出迷宫，路线图是：<br>Y 0 Y Y Y<br>Y Y Y 0 Y<br>1 0 0 Y Y<br>1 0 0 Y 0<br>1 0 0 Y Y</p></blockquote><h4 id="N皇后问题">N皇后问题</h4><blockquote><p>N皇后问题源自国际象棋，所有棋子中权力最大的称为皇后，它可以直着走、横着走、斜着走（沿45度角），可以攻击移动途中遇到的任何棋子。N皇后问题的具体内容是：如何将N个皇后摆放在N*N的棋盘中，使它们无法相互攻击。如下图所示。</p><p>解决思路：</p><p>要想使 N 个皇后不相互攻击，应将它们放置在不同的行、不同的列、还不能位于同一条 45°（或 135°）角的斜线上。</p><p>回溯算法解决N皇后问题的具体思路是：将 N 个皇后逐一放置在不同的行，以“回溯”的方式逐一测试出每行皇后所在行的具体位置，最终确定所有皇后的位置。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98.png" alt="N皇后问题"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span>[] q = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">20</span>]; <span class="comment">// 每个皇后的所在列数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> count = <span class="number">0</span>; <span class="comment">// count 种解决方案</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">&quot;请输入皇后的个数：&quot;</span>);</span><br><span class="line">        <span class="built_in">string</span> sc = Console.ReadLine();</span><br><span class="line">        <span class="built_in">int</span> n = <span class="built_in">int</span>.Parse(sc);</span><br><span class="line">        n_queues(<span class="number">1</span>, n);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;共有 &quot;</span> + count + <span class="string">&quot; 种摆放方式&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> N皇后算法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;k&quot;&gt;</span>第几行数<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;n&quot;&gt;</span>皇后个数<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">n_queues</span>(<span class="params"><span class="built_in">int</span> k, <span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> j;</span><br><span class="line">        <span class="comment">// 递归出口：当前行数大于皇后个数</span></span><br><span class="line">        <span class="keyword">if</span> (k &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            print(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 尝试第 k 行的每一列，找到符合要求的列</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (isSafe(k, j))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 存进数组中保存</span></span><br><span class="line">                    q[k] = j;</span><br><span class="line">                    <span class="comment">// 确认第 k 行皇后位置后，继续下一行的皇后的位置判断。</span></span><br><span class="line">                    n_queues(k + <span class="number">1</span>, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">isSafe</span>(<span class="params"><span class="built_in">int</span> k, <span class="built_in">int</span> j</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> i;</span><br><span class="line">        <span class="comment">// 判断是否有其他皇后位置在同一列，或者位于该位置的斜线位置上，如果有，则不能放</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 同一斜线判断规则：|行号差值| = |列号差值|</span></span><br><span class="line">            <span class="keyword">if</span> (q[i] == j || Math.Abs(i - k) == Math.Abs(q[i] - j))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> i, j;</span><br><span class="line">        count++;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;第 &quot;</span> + count + <span class="string">&quot; 个解为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// 行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= n; j++) <span class="comment">// 列</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (q[i] != j)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.Write(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Console.Write(<span class="string">&quot;Q&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输入：4</p><p>第 1 个解为：<br>xxQxx<br>xxxxQ<br>xQxxx<br>xxxQx</p><p>第 2 个解为：<br>xxxQx<br>xQxxx<br>xxxxQ<br>xxQxx</p><p>共有 2 种摆放方式</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;回溯算法的基本思想：实际上是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现不满足求解条件时，就“回溯”返回，尝试别的路径。是一种选优搜索法，按选优条件向前搜索，以达到目标。&lt;/p&gt;
&lt;p&gt;回溯算法经常以递归的方式实现，用来解</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="算法" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="算法" scheme="https://azzurebubble.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="回溯算法" scheme="https://azzurebubble.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法——动态规划算法</title>
    <link href="https://azzurebubble.github.io/posts/d7fe9934.html"/>
    <id>https://azzurebubble.github.io/posts/d7fe9934.html</id>
    <published>2023-06-07T08:18:24.000Z</published>
    <updated>2024-04-20T01:10:50.272Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>动规的基本思想：动规的实质是分治思想和解决冗余。将原问题分解为若干子问题，通过解决子问题的最优解来得到原问题的最优解。是一种解决多阶段决策问题的优化方法。</p><p>与分治算法的不同之处在于，分治算法拆分出的小问题之间是相互独立的，而动规拆分的小问题之间是相互关联的，想要解决问题 A ，就必须先解决问题 B 和 C。</p><p>动态规划算法的关键在于将原问题分解为子问题，并利用子问题的最优解来构造原问题的最优解。通过状态转移方程的定义和递推求解过程，动态规划算法能够避免重复计算，提高问题求解的效率。它适用于那些具有重叠子问题和最优子结构性质的问题，如最短路径问题、背包问题、序列比对等。（空间换时间的算法）</p></blockquote><h3 id="动规算法的解题思路">动规算法的解题思路</h3><p>用 f(n) 表示凑齐面值 n 所需纸币的最少数量，面值 15 的拼凑方案有 3 种，分别是：</p><ul><li>f(15) = f(14) +1：挑选一张面值为 1 的纸币，f(14) 表示拼凑出面值 14 所需要的最少的纸币数量；</li><li>f(15) = f(8) + 1：挑选一张面值为 7 的纸币，f(8) 表示拼凑出面值 8 所需要的最少的纸币数量；</li><li>f(15) = f(5) + 1：选择一张面值为10 的纸币，f(5) 表示拼凑出面值 5 所需要的最少的纸币数量。</li></ul><p>也就是说，f(14)+1、f(8)+1 和 f(5)+1 三者中的最小值就是最优的拼凑方案。采用同样的方法，继续求 f(14)、f(8)、f(5) 的值：</p><ul><li>f(5) = f(4) + 1；</li><li>f(8) = f(7) + 1 = f(1) +1；</li><li>f(14) = f(13)+1 = f(7) + 1 = f(4) +1。</li></ul><h3 id="动态规划算法的经典应用">动态规划算法的经典应用</h3><h4 id="0-1背包问题">0-1背包问题</h4><blockquote><p>虚拟一个场景，商店中拥有 5 件商品，它们各自的重量和收益分别是：</p><ul><li>商品 1：重量 1 斤，收益 1 元；</li><li>商品 2：重量 2 斤，收益 6 元；</li><li>商品 3：重量 5 斤，收益 18 元；</li><li>商品 4：重量 6 斤，收益 22 元；</li><li>商品 5：重量 7 斤，收益 28 元。</li></ul><p>所有商品不可再分，顾客要么“整件”购买商品，要么放弃购买。一个小偷想窃取商品，他的背包只能装 11 斤商品，如何选择商品才能获得最大的收益呢？</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98_1.png" alt="01背包问题_1"></p><blockquote><p>表格中，wi 表示第 i 件商品的重量，vi 表示第 i 件商品的收益值。承重不同的各个背包尚未装入商品时，对应的收益值都为 0。</p></blockquote><ol><li><p>首先考虑将商品一装入各个背包，除了承重值为 0 的背包，其它背包都能装入，且与不装任何商品相比，装入商品一后各个背包的收益更大</p><p><img src="https://cdn.staticaly.com/gh/AzureBubble/PicBed@main/showImg/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98_2.png" alt="01背包问题_2"></p><p>我们用 f(n) 表示承重值为 n 的背包对应的最大收益。从算法的角度，各个背包收益值是这样计算的：f(1)=1+f(0)、f(2)=1+f(1)、…、f(11)=1+f(10)，其中等号右侧表达式中的 1 指的是商品一的收益值，f(0) - f(10) 指的是不装任何商品时承重分别为 0 - 10 的背包对应的收益值，借助表格可以看到，它们的值都为 0。</p></li><li><p>考虑将商品二装入各个背包，除了承重值为 0 和 1 的背包，其它背包都可以装入。我们可以计算出它们各自对应的收益值：</p><blockquote><p>f(2) = 6 + f(0) = 6<br>f(3) = 6 + f(1) = 7<br>f(4) = 6 + f(2) = 7<br>…<br>f(9) = 6 + f(7) = 7<br>f(10) = 6 + f(8) = 7<br>f(11) = 6 + f(9) = 7</p></blockquote><p>等号右侧 f(0)~f(9) 的值是表 2 中装入商品一的各个背包对应的收益值。相比装入商品一统计的各个背包的收益值，装入商品二能使提高各个背包的收益。更新后的表格为：</p><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98_3.png" alt="01背包问题_3"></p></li><li><p>考虑将商品三装入各个背包，除了承重值为小于 5 的背包，其它背包都可以装入。我们可以计算出它们各自对应的收益值：</p><blockquote><p>f(5) = 18 + f(0) = 18<br>f(6) = 18 + f(1) = 19<br>f(7) = 18 + f(2) = 24<br>f(8) = 18 + f(3) = 25<br>f(9) = 18 + f(4) = 25<br>f(10) = 18 + f(5) = 25<br>f(11) = 18 + f(6) = 25</p></blockquote><p>等号右侧 f(0)~f(6) 的值是表 2 中装入商品二的各个背包对应的收益值。和装入商品二时统计的各个背包的收益值相比，装入商品三能提高各个背包的收益。更新后的表格为：</p><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98_4.png" alt="01背包问题_4"></p></li><li><p>采用同样的方法，我们可以将表 4 中缺失的数据补全，最终得到的表格为：</p><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98_5.png" alt="01背包问题_5"></p><blockquote><p>注意，并不是每试图装入一个新商品，背包的收益一定会提高。举个例子，承重为 7 斤的背包装入商品四时的最大收益是：f(7) = 22+f(1) = 23，装入商品三时最大的收益值为：f(7) = 18+f(2) = 24。因此，上图中承重 7 斤的背包装入商品 4 时对应的收益值仍为 24，并未发生改变。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> N = <span class="number">5</span>; <span class="comment">// 商品种类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> W = <span class="number">11</span>; <span class="comment">// 背包的最大承重</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 动态规划算法解决01背包问题</span></span><br><span class="line"><span class="comment">     * result[N + 1][W + 1]：存储最终的结果</span></span><br><span class="line"><span class="comment">     * w[N + 1]：存储各商品的重量</span></span><br><span class="line"><span class="comment">     * v[N + 1]：存储各商品的价值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] w = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span>[] v = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">18</span>, <span class="number">22</span>, <span class="number">28</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span>[,] result = <span class="keyword">new</span> <span class="built_in">int</span>[N + <span class="number">1</span>, W + <span class="number">1</span>];</span><br><span class="line">        knapsack01(result, w, v);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;背包承重为 &#123;0&#125;,最大收益为 &#123;1&#125;&quot;</span>, W, result[N, W]);</span><br><span class="line">        Console.Write(<span class="string">&quot;选择了：&quot;</span>);</span><br><span class="line">        <span class="keyword">select</span>(result, w, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">knapsack01</span>(<span class="params"><span class="built_in">int</span>[,] result, <span class="built_in">int</span>[] w, <span class="built_in">int</span>[] v</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 逐个遍历每个商品</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 求出从 1 到 W 各个称重对应的最大收益</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= W; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果背包载重小于商品总重量，则该商品无法放进背包，收益不变</span></span><br><span class="line">                <span class="keyword">if</span> (j &lt; w[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    result[i, j] = result[i - <span class="number">1</span>, j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 比较装入该商品和不装该商品，哪种情况获得的收益更大，记录最大收益值</span></span><br><span class="line">                    result[i, j] = result[i - <span class="number">1</span>, j] &gt; (v[i] + result[i - <span class="number">1</span>, j - w[i]])</span><br><span class="line">                        ? result[i - <span class="number">1</span>, j] : (v[i] + result[i - <span class="number">1</span>, j - w[i]]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select</span>(<span class="params"><span class="built_in">int</span>[,] result, <span class="built_in">int</span>[] w, <span class="built_in">int</span>[] v</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> n = N;</span><br><span class="line">        <span class="built_in">int</span> bagw = W;</span><br><span class="line">        <span class="comment">// 逐个商品进行判断</span></span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果在指定载重量下，该商品对应的收益和上一个商品对应的收益相同，则表明未选中</span></span><br><span class="line">            <span class="keyword">if</span> (result[n, bagw] == result[n - <span class="number">1</span>, bagw])</span><br><span class="line">            &#123;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 输出被选用商品的重量和价值</span></span><br><span class="line">                Console.Write(<span class="string">$&quot;(<span class="subst">&#123;w[n]&#125;</span>,<span class="subst">&#123;v[n]&#125;</span>) &quot;</span>);</span><br><span class="line">                bagw = bagw - w[n];</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;动规的基本思想：动规的实质是分治思想和解决冗余。将原问题分解为若干子问题，通过解决子问题的最优解来得到原问题的最优解。是一种解决多阶段决策问题的优化方法。&lt;/p&gt;
&lt;p&gt;与分治算法的不同之处在于，分治算法拆分出的小问题之间是相互独立的，而动规拆分的</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="算法" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="算法" scheme="https://azzurebubble.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划算法" scheme="https://azzurebubble.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法——贪心算法</title>
    <link href="https://azzurebubble.github.io/posts/fa27ba66.html"/>
    <id>https://azzurebubble.github.io/posts/fa27ba66.html</id>
    <published>2023-06-07T07:54:22.000Z</published>
    <updated>2024-04-20T01:10:50.276Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>贪心算法基本思想：在对问题求解时，总是做出在当前看来是最好的选择。也就是说不从整体最优上加以考虑，算法得到的是某种意义上的局部最优解。</p><p>注意：贪心算法的每一步都是最优的解决方案，但整个算法并不一定是最优的（局部最优解）。</p></blockquote><h3 id="贪心算法的经典应用">贪心算法的经典应用</h3><h4 id="部分背包问题">部分背包问题</h4><blockquote><p>背包问题：在限定条件下，如何从众多物品中选出收益最高的几件物品。</p><p>背包问题可细分为以下四种：</p><ul><li>0-1 背包问题：每件物品都不可再分，要么整个装入背包，要么放弃，不允许出现类似“将物品的 1/3 装入背包”的情况；</li><li>部分背包问题：每件物品是可再分的，即允许将某件物品的一部分（例如 1/3）放入背包；</li><li>完全背包问题：挑选物品时，每件物品可以选择多个，也就是说不限物品的数量。</li><li>多重背包问题：每件物品的数量是有严格规定的，比如物品 A 有 2 件，物品 B 有 3 件。</li></ul><p>不同背包问题，对应的解决方案也不用，贪心算法主要解决的就是部分背包问题。</p></blockquote><h5 id="部分背包问题-2">部分背包问题</h5><p>假设商店中有三种商品，它们各自的重量和收益：</p><ul><li>商品 1：重量10斤，收益60元；</li><li>商品 2：重量20斤，收益100元；</li><li>商品 3：重量30斤，收益120元；</li></ul><blockquote><p>部分背包问题，对于每一件商品，顾客可以只购买其一部分（可再分）。现</p><p>现在你有一个最多装50斤商品的背包，你如何购买商品才能使背包中的商品收益达到最大化？</p><p>贪心算法思路，计算每个商品的收益率（收益/重量）每次优先选择收益率最大的商品，直到所选商品的总重量达到了50斤。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> N = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// w存储各个商品的重量，p存储各个商品的收益，W表示背包的承重，v是收益率</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Sort</span>(<span class="params"><span class="built_in">float</span>[] w, <span class="built_in">float</span>[] p</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> temp;</span><br><span class="line">        <span class="comment">// 使用一个数组按升序来存放每件商品的收益率</span></span><br><span class="line">        <span class="built_in">float</span>[] v = <span class="keyword">new</span> <span class="built_in">float</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 计算收益率（收益/重量）</span></span><br><span class="line">            v[i] = p[i] / w[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据收益率升序排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = i + <span class="number">1</span>; j &lt; N; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (v[i] &lt; v[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    temp = v[i];</span><br><span class="line">                    v[i] = v[j];</span><br><span class="line">                    v[j] = temp;</span><br><span class="line"></span><br><span class="line">                    temp = w[i];</span><br><span class="line">                    w[i] = w[j];</span><br><span class="line">                    w[j] = temp;</span><br><span class="line"></span><br><span class="line">                    temp = p[i];</span><br><span class="line">                    p[i] = p[j];</span><br><span class="line">                    p[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 贪心算法解决部分背包问题</span></span><br><span class="line"><span class="comment">     * w：记录各个商品的总重量</span></span><br><span class="line"><span class="comment">     * p：记录各个商品的总价值</span></span><br><span class="line"><span class="comment">     * result：记录各个商品装入背包的比例</span></span><br><span class="line"><span class="comment">     * W：背包的容量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fractional_knaspack</span>(<span class="params"><span class="built_in">float</span>[] w, <span class="built_in">float</span>[] p,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">float</span>[] result, <span class="built_in">float</span> W</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 根据收益率排序</span></span><br><span class="line">        Sort(w, p);</span><br><span class="line">        <span class="keyword">while</span> (W &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从排好序的数组中判断选中物品是否可以整个装进背包</span></span><br><span class="line">            temp = W &gt; w[i] ? w[i] : W;</span><br><span class="line">            <span class="comment">// 不可以，则计算出背包容量还能装下多少</span></span><br><span class="line">            result[i] = temp / w[i];</span><br><span class="line">            <span class="comment">// 背包减去装进物品的重量</span></span><br><span class="line">            W -= temp;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 背包总收益</span></span><br><span class="line">        <span class="built_in">float</span> values = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 每个商品的重量</span></span><br><span class="line">        <span class="built_in">float</span>[] w = &#123; <span class="number">10</span>, <span class="number">30</span>, <span class="number">20</span> &#125;;</span><br><span class="line">        <span class="comment">// 每个商品的价值</span></span><br><span class="line">        <span class="built_in">float</span>[] p = &#123; <span class="number">60</span>, <span class="number">100</span>, <span class="number">120</span> &#125;;</span><br><span class="line">        <span class="built_in">float</span>[] result = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="comment">// 背包容量</span></span><br><span class="line">        <span class="built_in">float</span> W = <span class="number">50</span>;</span><br><span class="line">        fractional_knaspack(w, p, result, W);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; w.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 放入比例为1，则为整个商品装入背包</span></span><br><span class="line">            <span class="keyword">if</span> (result[i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;总重量为&#123;0&#125;，总价值为&#123;1&#125;的商品全部装入背包。&quot;</span>, w[i], p[i]);</span><br><span class="line">                values += p[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 放入比例为0，则不装入背包</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (result[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;总重量为&#123;0&#125;，总价值为&#123;1&#125;的商品不装入背包。&quot;</span>, w[i], p[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 某个商品放入多少比例进背包</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;总重量为&#123;0&#125;，总价值为&#123;1&#125;的商品装入&#123;2&#125;%背包。&quot;</span>,</span><br><span class="line">                    w[i], p[i], result[i] * <span class="number">100</span>);</span><br><span class="line">                values += p[i] * result[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;最终收获的商品价值为&#123;0:N6&#125;。&quot;</span>, values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果：</p><p>总重量为10，总价值为60的商品全部装入背包。<br>总重量为20，总价值为120的商品全部装入背包。<br>总重量为30，总价值为100的商品装入66.66667%背包。<br>最终收获的商品价值为246.666672。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;贪心算法基本思想：在对问题求解时，总是做出在当前看来是最好的选择。也就是说不从整体最优上加以考虑，算法得到的是某种意义上的局部最优解。&lt;/p&gt;
&lt;p&gt;注意：贪心算法的每一步都是最优的解决方案，但整个算法并不一定是最优的（局部最优解）。&lt;/p&gt;
&lt;/</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="算法" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="算法" scheme="https://azzurebubble.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="贪心算法" scheme="https://azzurebubble.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法——分治算法</title>
    <link href="https://azzurebubble.github.io/posts/2a9d432c.html"/>
    <id>https://azzurebubble.github.io/posts/2a9d432c.html</id>
    <published>2023-06-07T01:17:46.000Z</published>
    <updated>2024-04-20T01:10:50.273Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>分治算法的基本思想：先将整个问题拆分成多个相互独立且数据量更少的小问题，通过逐一解决这些简单的小问题，最终找到解决整个问题的方案。</p><p>所谓问题间相互独立，简单理解就是每个问题都可以单独处理，不存在“谁先处理，谁后处理”的次序问题。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95.png" alt="分治算法"></p><blockquote><p>如上图所示，分治算法解决问题的过程分为三个阶段：</p><ol><li>分：将整个问题划分成多个相对独立、涉及数据量更少的小问题，有些小问题还可以划分成很多更小的问题，直至每个问题都不可再分；</li><li>治：逐个解决所有的小问题；</li><li>合并：将所有小问题的解决方案合并到一起，找到解决整个问题的方案。</li></ol></blockquote><h3 id="分治算法的经典应用">分治算法的经典应用</h3><h4 id="汉诺塔问题">汉诺塔问题</h4><blockquote><ul><li><p>每次只能移动柱子最顶端的一个圆盘；</p></li><li><p>每个柱子上，小圆盘永远要位于大圆盘之上；</p></li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98.gif" alt="汉诺塔问题"></p><h5 id="分治算法解决汉诺塔问题">分治算法解决汉诺塔问题</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> i = <span class="number">1</span>; <span class="comment">// 统计移动次数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Hanoi(圆盘个数，起始柱子，目标柱子，辅助柱子)</span></span><br><span class="line">        Hanoi(<span class="number">3</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Hanoi</span>(<span class="params"><span class="built_in">int</span> n, <span class="built_in">char</span> sou, <span class="built_in">char</span> tar, <span class="built_in">char</span> aux</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="comment">// 只有一个圆盘，直接从起始柱移动到目标柱</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;第&#123;0&#125;次，从&#123;1&#125;移动到&#123;2&#125;&quot;</span>, i, sou, tar);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 递归调用 Hanoi 方法，将 num-1 个圆盘从起始移动到辅助柱上</span></span><br><span class="line">            Hanoi(n - <span class="number">1</span>, sou, aux, tar);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;第&#123;0&#125;次，从&#123;1&#125;移动到&#123;2&#125;&quot;</span>, i, sou, tar);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="comment">// 将辅助柱上的num-1圆盘移动到目标柱上</span></span><br><span class="line">            Hanoi(n - <span class="number">1</span>, aux, tar, sou);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果：</p><p>第1次，从A移动到B<br>第2次，从A移动到B<br>第3次，从C移动到B<br>第4次，从A移动到B<br>第5次，从C移动到B<br>第6次，从C移动到B<br>第7次，从A移动到B</p></blockquote><h4 id="寻找数组中最大最小值问题">寻找数组中最大最小值问题</h4><blockquote><p>查找数组（序列）中最大值或最小值的算法有很多</p></blockquote><h5 id="普通的迭代算法法求最大最小值">普通的迭代算法法求最大最小值</h5><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%80%BC%E9%97%AE%E9%A2%98_%E6%99%AE%E9%80%9A%E7%AE%97%E6%B3%95.gif" alt="最大最小值问题_普通算法"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> n;</span><br><span class="line">        n = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">        <span class="built_in">int</span>[] a = <span class="keyword">new</span> <span class="built_in">int</span>[n];</span><br><span class="line">        <span class="built_in">string</span>? input = Console.ReadLine();</span><br><span class="line">        <span class="comment">// 通过空格分割输入的字符串</span></span><br><span class="line">        <span class="built_in">string</span>[] inputs = input?.Split(<span class="string">&#x27; &#x27;</span>) ?? <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; inputs.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i] = <span class="built_in">int</span>.Parse(inputs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        GetMaxMin(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetMaxMin</span>(<span class="params"><span class="built_in">int</span>[] a</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> max = a[<span class="number">0</span>], min = a[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 迭代对比，选出其中最大值和最小值存储起来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; a.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; min)</span><br><span class="line">            &#123;</span><br><span class="line">                min = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;最大值为：&quot;</span> + max + <span class="string">&quot;\n最小值为：&quot;</span> + min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输入：</p><p>4</p><p>3 7 2 1</p><p>输入结果：</p><p>最大值为：7<br>最小值为：1</p></blockquote><h5 id="分治算法求解">分治算法求解</h5><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%80%BC%E9%97%AE%E9%A2%98_%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95.png" alt="最大最小值问题_分治算法.png"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> n;</span><br><span class="line">        n = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">        <span class="built_in">int</span>[] a = <span class="keyword">new</span> <span class="built_in">int</span>[n];</span><br><span class="line">        <span class="built_in">string</span>? input = Console.ReadLine();</span><br><span class="line">        <span class="comment">// 通过空格分割输入的字符串</span></span><br><span class="line">        <span class="built_in">string</span>[] inputs = input?.Split(<span class="string">&#x27; &#x27;</span>) ?? <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; inputs.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i] = <span class="built_in">int</span>.Parse(inputs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;最大值为：&quot;</span>GetMax(a, <span class="number">0</span>, n - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">GetMax</span>(<span class="params"><span class="built_in">int</span>[] a, <span class="built_in">int</span> left, <span class="built_in">int</span> right</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> maxLeft = <span class="number">0</span>, maxRight = <span class="number">0</span>, middle = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果数据为空</span></span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果比较的数据只剩下一个数</span></span><br><span class="line">        <span class="keyword">if</span> (right - left == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果比较的数据只剩下两个数</span></span><br><span class="line">        <span class="comment">// 则返回大的那个数</span></span><br><span class="line">        <span class="keyword">if</span> (right - left &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[left] &gt;= a[right])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> a[left];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a[right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取数组中间索引值</span></span><br><span class="line">        middle = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">        <span class="comment">// 递归调用 GetMax 找到数组左边数据中的最大值</span></span><br><span class="line">        maxLeft = GetMax(a, left, middle);</span><br><span class="line">        <span class="comment">// 递归调用 GetMax 找到数组右边数据中的最大值</span></span><br><span class="line">        maxRight = GetMax(a, middle + <span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">// 判断得到的左右两边最后返回的值的大小</span></span><br><span class="line">        <span class="keyword">if</span> (maxLeft &gt;= maxRight)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> maxLeft;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> maxRight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输入：</p><p>4</p><p>3 7 2 1</p><p>输入结果：</p><p>最大值为： 7</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;分治算法的基本思想：先将整个问题拆分成多个相互独立且数据量更少的小问题，通过逐一解决这些简单的小问题，最终找到解决整个问题的方案。&lt;/p&gt;
&lt;p&gt;所谓问题间相互独立，简单理解就是每个问题都可以单独处理，不存在“谁先处理，谁后处理”的次序问题。&lt;/p</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="算法" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="算法" scheme="https://azzurebubble.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="分治算法" scheme="https://azzurebubble.github.io/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
