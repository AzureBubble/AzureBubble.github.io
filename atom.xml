<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fomalhaut🥝</title>
  
  
  <link href="https://azzurebubble.github.io/atom.xml" rel="self"/>
  
  <link href="https://azzurebubble.github.io/"/>
  <updated>2024-08-18T14:23:09.406Z</updated>
  <id>https://azzurebubble.github.io/</id>
  
  <author>
    <name>Rock</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UGUI源码解析——VertexHelper</title>
    <link href="https://azzurebubble.github.io/posts/93fc2cc0.html"/>
    <id>https://azzurebubble.github.io/posts/93fc2cc0.html</id>
    <published>2024-08-18T14:18:07.000Z</published>
    <updated>2024-08-18T14:23:09.406Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——CoroutineTween</title>
    <link href="https://azzurebubble.github.io/posts/59942898.html"/>
    <id>https://azzurebubble.github.io/posts/59942898.html</id>
    <published>2024-08-18T14:17:14.000Z</published>
    <updated>2024-08-18T14:24:13.028Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——SetPropertyUtility</title>
    <link href="https://azzurebubble.github.io/posts/ef6aa33a.html"/>
    <id>https://azzurebubble.github.io/posts/ef6aa33a.html</id>
    <published>2024-08-18T09:00:04.000Z</published>
    <updated>2024-08-18T09:05:37.556Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>SetPropertyUtility：设置UI元素属性的静态工具类。</p></blockquote><h4 id="源码解析">源码解析</h4><blockquote><p>SetColor:修改颜色值，如果新传入的颜色的RGBA和就颜色相同则不进行修改</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">SetColor</span>(<span class="params"><span class="keyword">ref</span> Color currentValue, Color newValue</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (currentValue.r == newValue.r &amp;&amp; currentValue.g == newValue.g &amp;&amp; currentValue.b == newValue.b &amp;&amp; currentValue.a == newValue.a)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    currentValue = newValue;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetStruct:比较两个结构体的值，如果为不一样才进行更新</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">SetStruct</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">ref</span> T currentValue, T newValue</span>) <span class="keyword">where</span> T : <span class="keyword">struct</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (EqualityComparer&lt;T&gt;.Default.Equals(currentValue, newValue))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    currentValue = newValue;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetClass:比较两个类的值，如果不一样且都不为空才进行更新</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">SetClass</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">ref</span> T currentValue, T newValue</span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((currentValue == <span class="literal">null</span> &amp;&amp; newValue == <span class="literal">null</span>) || (currentValue != <span class="literal">null</span> &amp;&amp; currentValue.Equals(newValue)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    currentValue = newValue;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">设置UI元素属性的静态工具类。</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——Graphic</title>
    <link href="https://azzurebubble.github.io/posts/ee37f782.html"/>
    <id>https://azzurebubble.github.io/posts/ee37f782.html</id>
    <published>2024-08-18T08:08:16.000Z</published>
    <updated>2024-08-18T14:22:54.047Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Graphic：是UGUI的核心组件，负责图对象的显示和更新，是MaskableGraphic的基类，而MaskableGraphic是Text、RawImage、Image的基类。Graphic是一个抽象类，意味着不能被实例化，但是它提供了很多可重写的方法可被继承并重写。</p></blockquote><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><blockquote><p>类头：特性，Graphic是继承自UIBehaviour和ICanvasElement，UIBehaviour是所有UGUI组件的最基类，负责接收UnityEditor的事件。ICanvasElement负责接收Canvas重新渲染的事件。</p></blockquote><p><a href="https://azurebubble.github.io/posts/45311df6.html"><strong>UGUI源码解析——UIBehaviour</strong></a></p><p><a href="https://azurebubble.github.io/posts/6dcd3730.html"><strong>UGUI源码解析——CanvasUpdateRegistry</strong></a></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不允许一个对象添加多个相同的组件</span></span><br><span class="line">[<span class="meta">DisallowMultipleComponent</span>]</span><br><span class="line"><span class="comment">// 依赖于CanvasRenderer画布渲染组件</span></span><br><span class="line">[<span class="meta">RequireComponent(typeof(CanvasRenderer))</span>]</span><br><span class="line"><span class="comment">// 依赖于RectTransform组件</span></span><br><span class="line">[<span class="meta">RequireComponent(typeof(RectTransform))</span>]</span><br><span class="line"><span class="comment">// 编辑器模式下可以运行</span></span><br><span class="line">[<span class="meta">ExecuteAlways</span>]</span><br></pre></td></tr></table></figure><blockquote><p>字段</p></blockquote><p><a href="https://azurebubble.github.io/posts/ef6aa33a.html"><strong>UGUI源码解析——SetPropertyUtility</strong></a></p><blockquote><p>SetPropertyUtility：设置UI元素属性的静态工具类。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态的材质和纹理字段，用于存储默认的UI元素材质和纹理，如果没有指定UI元素的材质和纹理，将会用这两个字段作为默认输入</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">protected</span> Material s_DefaultUI = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> Material defaultGraphicMaterial</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s_DefaultUI == <span class="literal">null</span>)</span><br><span class="line">            s_DefaultUI = Canvas.GetDefaultCanvasMaterial();</span><br><span class="line">        <span class="keyword">return</span> s_DefaultUI;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> Material defaultMaterial</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> defaultGraphicMaterial; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">protected</span> Texture2D s_WhiteTexture = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> Texture mainTexture</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> s_WhiteTexture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指示这个字段再序列化时曾经用过不同的名称(&quot;m_Mat&quot;)</span></span><br><span class="line">[<span class="meta">FormerlySerializedAs(<span class="string">&quot;m_Mat&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">protected</span> Material m_Material;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> Material material</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果没有，则直接返回默认材质</span></span><br><span class="line">        <span class="keyword">return</span> (m_Material != <span class="literal">null</span>) ? m_Material : defaultMaterial;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Material == <span class="keyword">value</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        m_Material = <span class="keyword">value</span>;</span><br><span class="line">        <span class="comment">// 脏标记</span></span><br><span class="line">        SetMaterialDirty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认颜色是白色</span></span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">private</span> Color m_Color = Color.white;</span><br><span class="line"><span class="comment">// 如果颜色发生了变化，则标记重新渲染顶点数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> Color color &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_Color; &#125; <span class="keyword">set</span> &#123; <span class="keyword">if</span> (SetPropertyUtility.SetColor(<span class="keyword">ref</span> m_Color, <span class="keyword">value</span>)) SetVerticesDirty(); &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记是否跳过布局更新和材质更新</span></span><br><span class="line">[<span class="meta">NonSerialized</span>] <span class="keyword">protected</span> <span class="built_in">bool</span> m_SkipLayoutUpdate;</span><br><span class="line">[<span class="meta">NonSerialized</span>] <span class="keyword">protected</span> <span class="built_in">bool</span> m_SkipMaterialUpdate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记这个图形对象是否能接收到鼠标射线的信号</span></span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">bool</span> m_RaycastTarget = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> raycastTarget &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_RaycastTarget; &#125; <span class="keyword">set</span> &#123; m_RaycastTarget = <span class="keyword">value</span>; &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RectTransform是必备的组件，不能被销毁，只需要检测它是否为空引用即可</span></span><br><span class="line">[<span class="meta">NonSerialized</span>] <span class="keyword">private</span> RectTransform m_RectTransform;</span><br><span class="line"><span class="keyword">public</span> RectTransform rectTransform</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ReferenceEquals(m_RectTransform, <span class="literal">null</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            m_RectTransform = GetComponent&lt;RectTransform&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_RectTransform;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CanvasRenderer是必备的组件，不能被销毁，只需要检测它是否为空引用即可</span></span><br><span class="line">[<span class="meta">NonSerialized</span>] <span class="keyword">private</span> CanvasRenderer m_CanvasRenderer;</span><br><span class="line"><span class="keyword">public</span> CanvasRenderer canvasRenderer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ReferenceEquals(m_CanvasRenderer, <span class="literal">null</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            m_CanvasRenderer = GetComponent&lt;CanvasRenderer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_CanvasRenderer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图形渲染到的画布引用，取最接近的Canvas</span></span><br><span class="line">[<span class="meta">NonSerialized</span>] <span class="keyword">private</span> Canvas m_Canvas;</span><br><span class="line"><span class="keyword">public</span> Canvas canvas</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Canvas == <span class="literal">null</span>)</span><br><span class="line">            CacheCanvas();</span><br><span class="line">        <span class="keyword">return</span> m_Canvas;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点和材质脏标记</span></span><br><span class="line">[<span class="meta">NonSerialized</span>] <span class="keyword">private</span> <span class="built_in">bool</span> m_VertsDirty;</span><br><span class="line">[<span class="meta">NonSerialized</span>] <span class="keyword">private</span> <span class="built_in">bool</span> m_MaterialDirty;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 布局设置为脏时候的回调函数</span></span><br><span class="line">[<span class="meta">NonSerialized</span>] <span class="keyword">protected</span> UnityAction m_OnDirtyLayoutCallback;</span><br><span class="line"><span class="comment">// 顶点设置为脏时候的回调函数</span></span><br><span class="line">[<span class="meta">NonSerialized</span>] <span class="keyword">protected</span> UnityAction m_OnDirtyVertsCallback;</span><br><span class="line"><span class="comment">// 材质设置为脏时候的回调函数</span></span><br><span class="line">[<span class="meta">NonSerialized</span>] <span class="keyword">protected</span> UnityAction m_OnDirtyMaterialCallback;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态网格字段</span></span><br><span class="line">[<span class="meta">NonSerialized</span>] <span class="keyword">protected</span> <span class="keyword">static</span> Mesh s_Mesh;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> Mesh workerMesh</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s_Mesh == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s_Mesh = <span class="keyword">new</span> Mesh();</span><br><span class="line">            s_Mesh.name = <span class="string">&quot;Shared UI Mesh&quot;</span>;</span><br><span class="line">            <span class="comment">// 使其在 Unity 编辑器中不可见，并且在保存场景时不会被序列化，确保它不会在场景保存时保存，也不会在 Hierarchy 面板中显示</span></span><br><span class="line">            s_Mesh.hideFlags = HideFlags.HideAndDontSave;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s_Mesh;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享帮助类实例，避免重复创建</span></span><br><span class="line">[<span class="meta">NonSerialized</span>] <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> VertexHelper s_VertexHelper = <span class="keyword">new</span> VertexHelper();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网格缓存</span></span><br><span class="line">[<span class="meta">NonSerialized</span>] <span class="keyword">protected</span> Mesh m_CachedMesh;</span><br><span class="line"><span class="comment">// UV坐标缓存</span></span><br><span class="line">[<span class="meta">NonSerialized</span>] <span class="keyword">protected</span> Vector2[] m_CachedUvs;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定颜色变化的插值对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> TweenRunner&lt;ColorTween&gt; m_ColorTweenRunner;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否使用旧版的网格生成方式</span></span><br><span class="line"><span class="keyword">protected</span> <span class="built_in">bool</span> useLegacyMeshGeneration &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 它表示图形的绝对深度，值从最低到最高，用于确定图形的绘制顺序和事件处理顺序。</span></span><br><span class="line"><span class="comment">// 具有较高深度的图形会在较低深度的图形之上绘制，并且接收事件的优先级较高。</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> depth &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> canvasRenderer.absoluteDepth; &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取在渲染过程中实际发送到 CanvasRenderer 的材质</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> Material materialForRendering</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> components = ListPool&lt;Component&gt;.Get();</span><br><span class="line">        GetComponents(<span class="keyword">typeof</span>(IMaterialModifier), components);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> currentMat = material;</span><br><span class="line">        <span class="comment">// 遍历所有 IMaterialModifier 组件，逐个应用材质修改</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; components.Count; i++)</span><br><span class="line">            currentMat = (components[i] <span class="keyword">as</span> IMaterialModifier).GetModifiedMaterial(currentMat);</span><br><span class="line">        ListPool&lt;Component&gt;.Release(components);</span><br><span class="line">        <span class="keyword">return</span> currentMat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>构造函数：创建一个颜色变化的插值对象，并将当前实例传递。指定图形组件在初始化时使用旧版网格生成方式。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Graphic</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_ColorTweenRunner == <span class="literal">null</span>)</span><br><span class="line">        m_ColorTweenRunner = <span class="keyword">new</span> TweenRunner&lt;ColorTween&gt;();</span><br><span class="line">    m_ColorTweenRunner.Init(<span class="keyword">this</span>);</span><br><span class="line">    useLegacyMeshGeneration = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetAllDirty:设置所有的图形属性需要进行重建，如布局，顶点，材质等</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetAllDirty</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断对象的布局是否需要重建</span></span><br><span class="line">    <span class="keyword">if</span> (m_SkipLayoutUpdate)</span><br><span class="line">    &#123;</span><br><span class="line">        m_SkipLayoutUpdate = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        SetLayoutDirty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断对象的材质是否需要更新</span></span><br><span class="line">    <span class="keyword">if</span> (m_SkipMaterialUpdate)</span><br><span class="line">    &#123;</span><br><span class="line">        m_SkipMaterialUpdate = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        SetMaterialDirty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记顶点需要更新</span></span><br><span class="line">    SetVerticesDirty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetLayoutDirty:将布局设置为脏，需要进行布局重建</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetLayoutDirty</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!IsActive())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记当前rectTransform需要进行布局重建</span></span><br><span class="line">    LayoutRebuilder.MarkLayoutForRebuild(rectTransform);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 布局脏标记后的回调</span></span><br><span class="line">    <span class="keyword">if</span> (m_OnDirtyLayoutCallback != <span class="literal">null</span>)</span><br><span class="line">        m_OnDirtyLayoutCallback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetVerticesDirty:将顶点设置为脏，需要进行布局重建</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetVerticesDirty</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!IsActive())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记当前图形元素将在Canvas更新时被重新计算</span></span><br><span class="line">    m_VertsDirty = <span class="literal">true</span>;</span><br><span class="line">    CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶点脏标记后的回调</span></span><br><span class="line">    <span class="keyword">if</span> (m_OnDirtyVertsCallback != <span class="literal">null</span>)</span><br><span class="line">        m_OnDirtyVertsCallback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetMaterialDirty:将材质设置为脏，需要进行布局重建</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetMaterialDirty</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!IsActive())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    m_MaterialDirty = <span class="literal">true</span>;</span><br><span class="line">    CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 材质脏标记后的回调</span></span><br><span class="line">    <span class="keyword">if</span> (m_OnDirtyMaterialCallback != <span class="literal">null</span>)</span><br><span class="line">        m_OnDirtyMaterialCallback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>OnRectTransformDimensionsChange:当RectTransform尺寸发生变化的时候调用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnRectTransformDimensionsChange</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (gameObject.activeInHierarchy)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 防止双重污染…</span></span><br><span class="line">        <span class="comment">// 如果正在布局重建，则只对顶点进行脏标记</span></span><br><span class="line">        <span class="keyword">if</span> (CanvasUpdateRegistry.IsRebuildingLayout())</span><br><span class="line">            SetVerticesDirty();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 否则布局也需要设置为需要重建，确保UI元素的布局和渲染是最新的</span></span><br><span class="line">            SetVerticesDirty();</span><br><span class="line">            SetLayoutDirty();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>OnBeforeTransformParentChanged:父对象变更前调用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnBeforeTransformParentChanged</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从图像重建队列中注销当前对象注册</span></span><br><span class="line">    GraphicRegistry.UnregisterGraphicForCanvas(canvas, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 标记当前rectTransform需要进行布局重建，确保父对象发生变化后，布局系统能够重新计算并更新对象的布局</span></span><br><span class="line">    LayoutRebuilder.MarkLayoutForRebuild(rectTransform);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>OnTransformParentChanged:父对象发生变化的时候调用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnTransformParentChanged</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">base</span>.OnTransformParentChanged();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为父对象的变化意味着当前的画布 (canvas) 可能不再适用，因此需要清空缓存的画布引用。</span></span><br><span class="line">    m_Canvas = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!IsActive())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新缓存当前对象的画布 (canvas)。这一步是为了在父对象变化后，重新获取并缓存正确的画布引用。</span></span><br><span class="line">    CacheCanvas();</span><br><span class="line">    <span class="comment">// 将当前对象注册到 GraphicRegistry 中</span></span><br><span class="line">    GraphicRegistry.RegisterGraphicForCanvas(canvas, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 对当前对象的所有属性进行脏标记</span></span><br><span class="line">    SetAllDirty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CacheCanvas:缓存当前对象的第一个Canvas父对象</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CacheCanvas</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 取对象池</span></span><br><span class="line">    <span class="keyword">var</span> list = ListPool&lt;Canvas&gt;.Get();</span><br><span class="line">    <span class="comment">// 查找父对象中的所有Canvas组件</span></span><br><span class="line">    gameObject.GetComponentsInParent(<span class="literal">false</span>, list);</span><br><span class="line">    <span class="keyword">if</span> (list.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 找到第一个激活的画布</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Count; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (list[i].isActiveAndEnabled)</span><br><span class="line">            &#123;</span><br><span class="line">                m_Canvas = list[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_Canvas = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放对象池</span></span><br><span class="line">    ListPool&lt;Canvas&gt;.Release(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>OnEnable:将图形和画布设置为脏标记</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">base</span>.OnEnable();</span><br><span class="line">            CacheCanvas();</span><br><span class="line">            <span class="comment">// 当前图形组件注册到指定的 Canvas 对象上。这样做可以确保在绘制或更新时，图形组件被正确地管理和处理。</span></span><br><span class="line">            GraphicRegistry.RegisterGraphicForCanvas(canvas, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">    <span class="comment">// 在编辑器模式下跟踪和管理图形重建</span></span><br><span class="line">            GraphicRebuildTracker.TrackGraphic(<span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 初始化白色纹理</span></span><br><span class="line">            <span class="keyword">if</span> (s_WhiteTexture == <span class="literal">null</span>)</span><br><span class="line">                s_WhiteTexture = Texture2D.whiteTexture;</span><br><span class="line"></span><br><span class="line">            SetAllDirty();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><blockquote><p>OnDisable:清空引用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">    <span class="comment">// 取消跟踪</span></span><br><span class="line">            GraphicRebuildTracker.UnTrackGraphic(<span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 注销Canvas和当前对象的图形重建</span></span><br><span class="line">            GraphicRegistry.UnregisterGraphicForCanvas(canvas, <span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 注销画布元素重建</span></span><br><span class="line">            CanvasUpdateRegistry.UnRegisterCanvasElementForRebuild(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (canvasRenderer != <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">// 清空</span></span><br><span class="line">                canvasRenderer.Clear();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 标记当前rectTransform需要进行布局重建</span></span><br><span class="line">            LayoutRebuilder.MarkLayoutForRebuild(rectTransform);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">base</span>.OnDisable();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><blockquote><p>OnDestroy:清空网格引用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_CachedMesh)</span><br><span class="line">        Destroy(m_CachedMesh);</span><br><span class="line">    m_CachedMesh = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">base</span>.OnDestroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>OnCanvasHierarchyChanged:Canvas的层级发生变化的时候调用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCanvasHierarchyChanged</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 缓存当前的Canvas</span></span><br><span class="line">    Canvas currentCanvas = m_Canvas;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空m_Canvas引用</span></span><br><span class="line">    m_Canvas = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!IsActive())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找到第一个父对象中的Canvas</span></span><br><span class="line">    CacheCanvas();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新的Canvas和缓存的Canvas不一样</span></span><br><span class="line">    <span class="keyword">if</span> (currentCanvas != m_Canvas)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注销旧的Canvas</span></span><br><span class="line">        GraphicRegistry.UnregisterGraphicForCanvas(currentCanvas, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只有当我们激活并启用OnCanvasHierarchyChanged时才能注册</span></span><br><span class="line"><span class="comment">// 在对象销毁过程中，我们不想注册自己，然后变成null。</span></span><br><span class="line">        <span class="keyword">if</span> (IsActive())</span><br><span class="line">            <span class="comment">// 注册新的Canvas</span></span><br><span class="line">            GraphicRegistry.RegisterGraphicForCanvas(canvas, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>OnCullingChanged:处理 Canvas 元素在被剔除状态变化时的逻辑</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnCullingChanged</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查是否剔除和属性脏标志</span></span><br><span class="line">    <span class="keyword">if</span> (!canvasRenderer.cull &amp;&amp; (m_VertsDirty || m_MaterialDirty))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将当前Canvas 元素注册到图形重建队列中。</span></span><br><span class="line">        CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Rebuild:根据 <code>CanvasUpdate</code> 类型重新构建图形组件，确保在绘制之前，组件的几何体和材质都是最新的。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Rebuild</span>(<span class="params">CanvasUpdate update</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (canvasRenderer == <span class="literal">null</span> || canvasRenderer.cull)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (update)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> CanvasUpdate.PreRender:</span><br><span class="line">            <span class="keyword">if</span> (m_VertsDirty)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 更新顶点几何体</span></span><br><span class="line">                UpdateGeometry();</span><br><span class="line">                m_VertsDirty = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (m_MaterialDirty)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 更新材质</span></span><br><span class="line">                UpdateMaterial();</span><br><span class="line">                m_MaterialDirty = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>LayoutComplete:布局重建完成事件</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">LayoutComplete</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GraphicUpdateComplete:图形重建完成事件</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GraphicUpdateComplete</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>UpdateMaterial:更新UI的材质和纹理</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">UpdateMaterial</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!IsActive())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置渲染器所用的材质数量为 1 </span></span><br><span class="line">    canvasRenderer.materialCount = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 指定materialForRendering应用到渲染器上</span></span><br><span class="line">    canvasRenderer.SetMaterial(materialForRendering, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 将纹理引用到当前材质上</span></span><br><span class="line">    canvasRenderer.SetTexture(mainTexture);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>UpdateGeometry:更新 UI 元素的几何体。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">UpdateGeometry</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 是否使用旧网格生成方法</span></span><br><span class="line">    <span class="keyword">if</span> (useLegacyMeshGeneration)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用传统的方法来生成或更新 UI 元素的网格。</span></span><br><span class="line">        DoLegacyMeshGeneration();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用新的方法来生成或更新 UI 元素的网格。</span></span><br><span class="line">        DoMeshGeneration();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>DoMeshGeneration:新的生成或更新 UI 元素的网格方法</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoMeshGeneration</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rectTransform != <span class="literal">null</span> &amp;&amp; rectTransform.rect.width &gt;= <span class="number">0</span> &amp;&amp; rectTransform.rect.height &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 调用 OnPopulateMesh 方法将顶点数据填充到 s_VertexHelper 中</span></span><br><span class="line">        OnPopulateMesh(s_VertexHelper);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 清除顶点帮助器，使无效图形不绘制。</span></span><br><span class="line">        s_VertexHelper.Clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有实现了 IMeshModifier 接口的组件</span></span><br><span class="line">    <span class="keyword">var</span> components = ListPool&lt;Component&gt;.Get();</span><br><span class="line">    GetComponents(<span class="keyword">typeof</span>(IMeshModifier), components);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有获取到的 IMeshModifier 组件，并调用它们的 ModifyMesh 方法来修改 s_VertexHelper 中的网格数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; components.Count; i++)</span><br><span class="line">        ((IMeshModifier)components[i]).ModifyMesh(s_VertexHelper);</span><br><span class="line"></span><br><span class="line">    ListPool&lt;Component&gt;.Release(components);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充 workerMesh</span></span><br><span class="line">    s_VertexHelper.FillMesh(workerMesh);</span><br><span class="line">    <span class="comment">// 将这个网格设置到 canvasRenderer 中，以便进行渲染</span></span><br><span class="line">    canvasRenderer.SetMesh(workerMesh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>DoLegacyMeshGeneration:旧的生成或更新 UI 元素的网格方法</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoLegacyMeshGeneration</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (rectTransform != <span class="literal">null</span> &amp;&amp; rectTransform.rect.width &gt;= <span class="number">0</span> &amp;&amp; rectTransform.rect.height &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> disable 618</span></span><br><span class="line">    <span class="comment">// 填充 workerMesh</span></span><br><span class="line">                OnPopulateMesh(workerMesh);</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> restore 618</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 清除网格数据</span></span><br><span class="line">                workerMesh.Clear();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取所有 IMeshModifier 组件</span></span><br><span class="line">            <span class="keyword">var</span> components = ListPool&lt;Component&gt;.Get();</span><br><span class="line">            GetComponents(<span class="keyword">typeof</span>(IMeshModifier), components);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; components.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> disable 618</span></span><br><span class="line">                ((IMeshModifier)components[i]).ModifyMesh(workerMesh);</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> restore 618</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ListPool&lt;Component&gt;.Release(components);</span><br><span class="line">            canvasRenderer.SetMesh(workerMesh);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><blockquote><p>OnPopulateMesh:UI元素需要生成顶点时的回调函数。填充顶点缓冲区数据。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnPopulateMesh</span>(<span class="params">Mesh m</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    OnPopulateMesh(s_VertexHelper);</span><br><span class="line">    s_VertexHelper.FillMesh(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>OnPopulateMesh:UI元素需要生成顶点时的回调函数。填充顶点缓冲区数据。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnPopulateMesh</span>(<span class="params">VertexHelper vh</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取 UI 元素调整后的矩形区域，以确保像素对齐</span></span><br><span class="line">    <span class="keyword">var</span> r = GetPixelAdjustedRect();</span><br><span class="line">    <span class="comment">// 包含矩形的左下角和右上角的坐标</span></span><br><span class="line">    <span class="keyword">var</span> v = <span class="keyword">new</span> Vector4(r.x, r.y, r.x + r.width, r.y + r.height);</span><br><span class="line"></span><br><span class="line">    Color32 color32 = color;</span><br><span class="line">    vh.Clear();</span><br><span class="line">    <span class="comment">// 添加左下角的顶点</span></span><br><span class="line">    vh.AddVert(<span class="keyword">new</span> Vector3(v.x, v.y), color32, <span class="keyword">new</span> Vector2(<span class="number">0f</span>, <span class="number">0f</span>));</span><br><span class="line">    <span class="comment">// 添加左上角的顶点</span></span><br><span class="line">    vh.AddVert(<span class="keyword">new</span> Vector3(v.x, v.w), color32, <span class="keyword">new</span> Vector2(<span class="number">0f</span>, <span class="number">1f</span>));</span><br><span class="line">    <span class="comment">// 添加右上角的顶点</span></span><br><span class="line">    vh.AddVert(<span class="keyword">new</span> Vector3(v.z, v.w), color32, <span class="keyword">new</span> Vector2(<span class="number">1f</span>, <span class="number">1f</span>));</span><br><span class="line">    <span class="comment">// 添加右下角的顶点</span></span><br><span class="line">    vh.AddVert(<span class="keyword">new</span> Vector3(v.z, v.y), color32, <span class="keyword">new</span> Vector2(<span class="number">1f</span>, <span class="number">0f</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个三角形由顶点 0、1 和 2 组成</span></span><br><span class="line">    vh.AddTriangle(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 第二个三角形由顶点 2、3 和 0 组成</span></span><br><span class="line">    vh.AddTriangle(<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GetPixelAdjustedRect：返回最接近图形RectTransform的像素完美矩形。</p><p>注意:只有当图形根画布在屏幕空间时才准确。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Rect <span class="title">GetPixelAdjustedRect</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查 canvas 是否存在、canvas 的渲染模式是否为 WorldSpace、canvas 的 scaleFactor 是否为 0、或 canvas 的 pixelPerfect 属性是否为 false</span></span><br><span class="line">    <span class="keyword">if</span> (!canvas || canvas.renderMode == RenderMode.WorldSpace || canvas.scaleFactor == <span class="number">0.0f</span> || !canvas.pixelPerfect)</span><br><span class="line">        <span class="comment">// 如果条件成立，则返回 rectTransform 的原始矩形</span></span><br><span class="line">        <span class="keyword">return</span> rectTransform.rect;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则，使用 PixelAdjustRect 方法获取调整后的矩形</span></span><br><span class="line">        <span class="keyword">return</span> RectTransformUtility.PixelAdjustRect(rectTransform, canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>OnDidApplyAnimationProperties：动画属性发生改变时调用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnDidApplyAnimationProperties</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    SetAllDirty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetNativeSize：使图形具有其内容的原始大小</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetNativeSize</span>()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Raycast：用于 UI 组件的点击检测</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;sp&quot;&gt;</span>射线的起始点，通常是屏幕坐标<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventCamera&quot;&gt;</span>进行射线检测的相机<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> <span class="title">Raycast</span>(<span class="params">Vector2 sp, Camera eventCamera</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当前对象是否被激活并启用</span></span><br><span class="line">    <span class="keyword">if</span> (!isActiveAndEnabled)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t = transform;</span><br><span class="line">    <span class="keyword">var</span> components = ListPool&lt;Component&gt;.Get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否忽略父级的 CanvasGroup</span></span><br><span class="line">    <span class="built_in">bool</span> ignoreParentGroups = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 控制是否继续遍历父对象</span></span><br><span class="line">    <span class="built_in">bool</span> continueTraversal = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环遍历当前对象及其所有父对象，直到没有更多的父对象为止</span></span><br><span class="line">    <span class="keyword">while</span> (t != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t.GetComponents(components);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; components.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 检查组件是否为 Canvas 类型</span></span><br><span class="line">            <span class="keyword">var</span> canvas = components[i] <span class="keyword">as</span> Canvas;</span><br><span class="line">            <span class="comment">// 如果覆盖父级的SortingLayer</span></span><br><span class="line">            <span class="keyword">if</span> (canvas != <span class="literal">null</span> &amp;&amp; canvas.overrideSorting)</span><br><span class="line">                <span class="comment">// 停止遍历父级</span></span><br><span class="line">                continueTraversal = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 确定射线是否有效的接口</span></span><br><span class="line">            <span class="keyword">var</span> filter = components[i] <span class="keyword">as</span> ICanvasRaycastFilter;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (filter == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 假设射线有效</span></span><br><span class="line">            <span class="keyword">var</span> raycastValid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查组件是否为 CanvasGroup 类型</span></span><br><span class="line">            <span class="keyword">var</span> <span class="keyword">group</span> = components[i] <span class="keyword">as</span> CanvasGroup;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">group</span> != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 当前组件不忽略父级 并且获取到的group也不忽略父级</span></span><br><span class="line">                <span class="keyword">if</span> (ignoreParentGroups == <span class="literal">false</span> &amp;&amp; <span class="keyword">group</span>.ignoreParentGroups)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 忽略父级</span></span><br><span class="line">                    ignoreParentGroups = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 检查射线在当前位置是否有效</span></span><br><span class="line">                    raycastValid = filter.IsRaycastLocationValid(sp, eventCamera);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!ignoreParentGroups) <span class="comment">// 当前组件不忽略父级</span></span><br><span class="line">                    <span class="comment">// 检查射线在当前位置是否有效</span></span><br><span class="line">                    raycastValid = filter.IsRaycastLocationValid(sp, eventCamera);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 组件不是 CanvasGroup 类型</span></span><br><span class="line">                <span class="comment">// 检查射线在当前位置是否有效</span></span><br><span class="line">                raycastValid = filter.IsRaycastLocationValid(sp, eventCamera);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!raycastValid)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 无效射线</span></span><br><span class="line">                ListPool&lt;Component&gt;.Release(components);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否继续遍历父级</span></span><br><span class="line">        t = continueTraversal ? t.parent : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有效射线</span></span><br><span class="line">    ListPool&lt;Component&gt;.Release(components);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PixelAdjustPoint：将给定像素点调整为像素完美。</p><p>注意:只有当图形根画布在屏幕空间时才准确。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Vector2 <span class="title">PixelAdjustPoint</span>(<span class="params">Vector2 point</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!canvas || canvas.renderMode == RenderMode.WorldSpace || canvas.scaleFactor == <span class="number">0.0f</span> || !canvas.pixelPerfect)</span><br><span class="line">        <span class="keyword">return</span> point;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> RectTransformUtility.PixelAdjustPoint(point, transform, canvas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CrossFadeColor：使用RGB模式实现颜色渐变效果的方法</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span><span class="doctag">&lt;param name=&quot;targetColor&quot;&gt;</span>目标颜色。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span><span class="doctag">&lt;param name=&quot;duration&quot;&gt;</span>渐变持续时间。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span><span class="doctag">&lt;param name=&quot;ignoreTimeScale&quot;&gt;</span>是否忽略Time.scale<span class="doctag">&lt; / param &gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span><span class="doctag">&lt;param name=&quot;useAlpha&quot;&gt;</span>是否也应该补间alpha通道<span class="doctag">&lt; / param &gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CrossFadeColor</span>(<span class="params">Color targetColor, <span class="built_in">float</span> duration, <span class="built_in">bool</span> ignoreTimeScale, <span class="built_in">bool</span> useAlpha</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    CrossFadeColor(targetColor, duration, ignoreTimeScale, useAlpha, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CrossFadeColor：将颜色渐变到目标颜色</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span><span class="doctag">&lt;param name=&quot;targetColor&quot;&gt;</span>目标颜色。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span><span class="doctag">&lt;param name=&quot;duration&quot;&gt;</span>渐变持续时间。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span><span class="doctag">&lt;param name=&quot;ignoreTimeScale&quot;&gt;</span>是否忽略Time.scale<span class="doctag">&lt; / param &gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span><span class="doctag">&lt;param name=&quot;useAlpha&quot;&gt;</span>是否也应该补间alpha通道<span class="doctag">&lt; / param &gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;useRGB&quot;&gt;</span>是否使用颜色还是alpha来补间<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CrossFadeColor</span>(<span class="params">Color targetColor, <span class="built_in">float</span> duration, <span class="built_in">bool</span> ignoreTimeScale, <span class="built_in">bool</span> useAlpha, <span class="built_in">bool</span> useRGB</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 既不使用alpha也不使用RGB来补间 没有指定渐变模式</span></span><br><span class="line">    <span class="keyword">if</span> (canvasRenderer == <span class="literal">null</span> || (!useRGB &amp;&amp; !useAlpha))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前颜色</span></span><br><span class="line">    Color currentColor = canvasRenderer.GetColor();</span><br><span class="line">    <span class="comment">// 如果已经是目标颜色 则不进行渐变</span></span><br><span class="line">    <span class="keyword">if</span> (currentColor.Equals(targetColor))</span><br><span class="line">    &#123;</span><br><span class="line">        m_ColorTweenRunner.StopTween();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 决定渐变模式</span></span><br><span class="line">    ColorTween.ColorTweenMode mode = (useRGB &amp;&amp; useAlpha ?</span><br><span class="line">        ColorTween.ColorTweenMode.All :</span><br><span class="line">        (useRGB ? ColorTween.ColorTweenMode.RGB : ColorTween.ColorTweenMode.Alpha));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 ColorTween 实例，并初始化其属性</span></span><br><span class="line">    <span class="keyword">var</span> colorTween = <span class="keyword">new</span> ColorTween &#123;duration = duration, startColor = canvasRenderer.GetColor(), targetColor = targetColor&#125;;</span><br><span class="line">    <span class="comment">// 添加颜色变化时的回调，调用canvasRenderer.SetColor来更新颜色</span></span><br><span class="line">    colorTween.AddOnChangedCallback(canvasRenderer.SetColor);</span><br><span class="line">    <span class="comment">// 设置是否忽略时间缩放</span></span><br><span class="line">    colorTween.ignoreTimeScale = ignoreTimeScale;</span><br><span class="line">    <span class="comment">// 设置渐变模式</span></span><br><span class="line">    colorTween.tweenMode = mode;</span><br><span class="line">    <span class="comment">// 启动颜色渐变</span></span><br><span class="line">    m_ColorTweenRunner.StartTween(colorTween);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CreateColorFromAlpha：根据指定的透明度（<code>alpha</code>）创建一个带有该透明度的黑色颜色对象</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">private</span> Color <span class="title">CreateColorFromAlpha</span>(<span class="params"><span class="built_in">float</span> alpha</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> alphaColor = Color.black;</span><br><span class="line">    alphaColor.a = alpha;</span><br><span class="line">    <span class="keyword">return</span> alphaColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CrossFadeAlpha：使用Alpha模式实现颜色渐变效果的方法</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span><span class="doctag">&lt;param name=&quot;alpha&quot;&gt;</span>目标alpha。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span><span class="doctag">&lt;param name=&quot;duration&quot;&gt;</span>渐变的持续时间，单位为秒。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span><span class="doctag">&lt;param name=&quot;ignoreTimeScale&quot;&gt;</span>是否应该忽略时间缩放<span class="doctag">&lt; / param &gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CrossFadeAlpha</span>(<span class="params"><span class="built_in">float</span> alpha, <span class="built_in">float</span> duration, <span class="built_in">bool</span> ignoreTimeScale</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    CrossFadeColor(CreateColorFromAlpha(alpha), duration, ignoreTimeScale, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>添加事件监听方法</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加布局重建脏标记后回调</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegisterDirtyLayoutCallback</span>(<span class="params">UnityAction action</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    m_OnDirtyLayoutCallback += action;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除布局重建脏标记后回调</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnregisterDirtyLayoutCallback</span>(<span class="params">UnityAction action</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    m_OnDirtyLayoutCallback -= action;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加顶点重建脏标记后回调</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegisterDirtyVerticesCallback</span>(<span class="params">UnityAction action</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    m_OnDirtyVertsCallback += action;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除顶点重建脏标记后回调</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnregisterDirtyVerticesCallback</span>(<span class="params">UnityAction action</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    m_OnDirtyVertsCallback -= action;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加材质更新脏标记后回调</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegisterDirtyMaterialCallback</span>(<span class="params">UnityAction action</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    m_OnDirtyMaterialCallback += action;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除材质更新脏标记后回调</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnregisterDirtyMaterialCallback</span>(<span class="params">UnityAction action</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    m_OnDirtyMaterialCallback -= action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Unity编辑器中的方法"><a href="#Unity编辑器中的方法" class="headerlink" title="Unity编辑器中的方法"></a>Unity编辑器中的方法</h4><blockquote><p>OnRebuildRequested：主要处理在编辑模式下当需要重新构建 UI 图形时的行为。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 如果需要重建图形，Unity会发出仅编辑器的回调。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 当资产被重新导入时当前发送。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnRebuildRequested</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当请求重建时，我们需要重建所有图形</span></span><br><span class="line">            <span class="comment">// 和相关组件…正确的做法是通过</span></span><br><span class="line">            <span class="comment">// 调用OnValidate…因为MB没有公共基类</span></span><br><span class="line">            <span class="comment">// 我们通过反射来完成。它又脏又丑……编辑器。</span></span><br><span class="line">            <span class="keyword">var</span> mbs = gameObject.GetComponents&lt;MonoBehaviour&gt;();</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> mb <span class="keyword">in</span> mbs)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (mb == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">var</span> methodInfo = mb.GetType().GetMethod(<span class="string">&quot;OnValidate&quot;</span>, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);</span><br><span class="line">                <span class="keyword">if</span> (methodInfo != <span class="literal">null</span>)</span><br><span class="line">                    methodInfo.Invoke(mb, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Reset</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            SetAllDirty();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>OnValidate：编辑器模式下，脚本的属性在 Inspector 中被更改时自动调用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnValidate</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">base</span>.OnValidate();</span><br><span class="line">    <span class="comment">// 对所有属性设置为脏标记</span></span><br><span class="line">            SetAllDirty();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">负责图像的更新与显示。</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——LayoutElement</title>
    <link href="https://azzurebubble.github.io/posts/9b0fb5b4.html"/>
    <id>https://azzurebubble.github.io/posts/9b0fb5b4.html</id>
    <published>2024-08-07T14:24:14.000Z</published>
    <updated>2024-08-12T15:17:30.075Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>LayoutElement：继承了ILayoutElement和ILayoutIgnorer接口，作为布局元素组件<br>挂载了Layout Element组件的对象，布局并不会生效，它是受到实现了布局组的控制(HorizontalLayoutGroup、VerticalLayoutGroup、GridLayoutGroup)</p></blockquote><h4 id="源码解析">源码解析</h4><blockquote><p>继承自ILayoutElement的属性</p></blockquote><p><a href="https://azurebubble.github.io/posts/2f5dfff6.html"><strong>UGUI源码解析——ILayoutElement</strong></a></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个RectTransform是否被布局系统忽略</span></span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">bool</span> m_IgnoreLayout = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> ignoreLayout &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_IgnoreLayout; &#125; <span class="keyword">set</span> &#123; <span class="keyword">if</span> (SetPropertyUtility.SetStruct(<span class="keyword">ref</span> m_IgnoreLayout, <span class="keyword">value</span>)) SetDirty(); &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetPropertyUtility.SetStruct(); 的作用是安全的设置一个结构体的值，只有检测到值真正发生变化的时候才会返回True，避免了不要的性能开销</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小宽度，只要设置了值，不管布局组件怎么设置，最小宽度不能小于这个值</span></span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">float</span> m_MinWidth = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">float</span> minWidth &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_MinWidth; &#125; <span class="keyword">set</span> &#123; <span class="keyword">if</span> (SetPropertyUtility.SetStruct(<span class="keyword">ref</span> m_MinWidth, <span class="keyword">value</span>)) SetDirty(); &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小高度，只要设置了值，不管布局组件怎么设置，最小高度不能小于这个值</span></span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">float</span> m_MinHeight = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">float</span> minHeight &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_MinHeight; &#125; <span class="keyword">set</span> &#123; <span class="keyword">if</span> (SetPropertyUtility.SetStruct(<span class="keyword">ref</span> m_MinHeight, <span class="keyword">value</span>)) SetDirty(); &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首选宽度，会优先选择这个值作为布局计算参考</span></span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">float</span> m_PreferredWidth = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">float</span> preferredWidth &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_PreferredWidth; &#125; <span class="keyword">set</span> &#123; <span class="keyword">if</span> (SetPropertyUtility.SetStruct(<span class="keyword">ref</span> m_PreferredWidth, <span class="keyword">value</span>)) SetDirty(); &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首选高度，会优先选择这个值作为布局计算参考</span></span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">float</span> m_PreferredHeight = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">float</span> preferredHeight &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_PreferredHeight; &#125; <span class="keyword">set</span> &#123; <span class="keyword">if</span> (SetPropertyUtility.SetStruct(<span class="keyword">ref</span> m_PreferredHeight, <span class="keyword">value</span>)) SetDirty(); &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是一个比例值，如果有额外的空间，会利用这个比例值获取最后的结果</span></span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">float</span> m_FlexibleWidth = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">float</span> flexibleWidth &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_FlexibleWidth; &#125; <span class="keyword">set</span> &#123; <span class="keyword">if</span> (SetPropertyUtility.SetStruct(<span class="keyword">ref</span> m_FlexibleWidth, <span class="keyword">value</span>)) SetDirty(); &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个比例值，如果有额外的空间，会利用这个比例值获取最后的结果</span></span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">float</span> m_FlexibleHeight = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">float</span> flexibleHeight &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_FlexibleHeight; &#125; <span class="keyword">set</span> &#123; <span class="keyword">if</span> (SetPropertyUtility.SetStruct(<span class="keyword">ref</span> m_FlexibleHeight, <span class="keyword">value</span>)) SetDirty(); &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此元素的布局优先级</span></span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">int</span> m_LayoutPriority = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">int</span> layoutPriority &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_LayoutPriority; &#125; <span class="keyword">set</span> &#123; <span class="keyword">if</span> (SetPropertyUtility.SetStruct(<span class="keyword">ref</span> m_LayoutPriority, <span class="keyword">value</span>)) SetDirty(); &#125; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetDirty:将LayoutElement标记为dirty。这将使自动布局系统在下一次布局时处理该元素。只要有可能影响布局的更改，LayoutElement就应该调用这个方法。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">SetDirty</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!IsActive())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    LayoutRebuilder.MarkLayoutForRebuild(transform <span class="keyword">as</span> RectTransform);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">继承了ILayoutElement和ILayoutIgnorer接口，作为布局元素组件。</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——LayoutUtility</title>
    <link href="https://azzurebubble.github.io/posts/a99e5cea.html"/>
    <id>https://azzurebubble.github.io/posts/a99e5cea.html</id>
    <published>2024-08-07T14:24:02.000Z</published>
    <updated>2024-08-12T15:41:37.086Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>LayoutUtility：布局的工具类，可以获取到对象的minWidth、preferredWidth、flexibleWidth、minHeight、preferredHeight、layoutPriority的属性值。用于查询布局元素的最小、首选和灵活大小的实用程序函数。</p></blockquote><h4 id="源码解析">源码解析</h4><blockquote><p>GetMinSize:返回布局元素的最小大小。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 返回布局元素的最小大小。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;rect&quot;&gt;</span>要查询的布局元素的RectTransform<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;axis&quot;&gt;</span>要查询的轴。可以是0或1<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span>所有在GameObject上实现ILayoutElement的组件都会被查询。使用具有此设置值的具有最高优先级的那个。如果多个组件具有此设置并且具有相同的优先级，则使用其中的最大值<span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">GetMinSize</span>(<span class="params">RectTransform rect, <span class="built_in">int</span> axis</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (axis == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> GetMinWidth(rect);</span><br><span class="line">    <span class="keyword">return</span> GetMinHeight(rect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GetPreferredSize：返回布局元素的首选大小。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 返回布局元素的灵活大小</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 查询GameObject中实现ILayoutElement的所有组件。使用具有此设置值的具有最高优先级的那个。如果多个组件具有此设置并且具有相同的优先级，则使用其中的最大值</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;rect&quot;&gt;</span>要查询的布局元素的RectTransform<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;axis&quot;&gt;</span>要查询的轴。可以是0或1<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">GetPreferredSize</span>(<span class="params">RectTransform rect, <span class="built_in">int</span> axis</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (axis == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> GetPreferredWidth(rect);</span><br><span class="line">    <span class="keyword">return</span> GetPreferredHeight(rect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GetFlexibleSize：返回布局元素的灵活大小</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 返回布局元素的灵活大小</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 查询GameObject中实现ILayoutElement的所有组件。使用具有此设置值的具有最高优先级的那个。如果多个组件具有此设置并且具有相同的优先级，则使用其中的最大值</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;rect&quot;&gt;</span>要查询的布局元素的RectTransform<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;axis&quot;&gt;</span>要查询的轴。可以是0或1<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">GetFlexibleSize</span>(<span class="params">RectTransform rect, <span class="built_in">int</span> axis</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (axis == <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span> GetFlexibleWidth(rect);</span><br><span class="line">     <span class="keyword">return</span> GetFlexibleHeight(rect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GetMinWidth：返回布局元素的最小宽度</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 返回布局元素的最小宽度</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 查询GameObject中实现ILayoutElement的所有组件。使用具有此设置值的具有最高优先级的那个。如果多个组件具有此设置并且具有相同的优先级，则使用其中的最大值</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;rect&quot;&gt;</span>要查询的布局元素的RectTransform<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">GetMinWidth</span>(<span class="params">RectTransform rect</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> GetLayoutProperty(rect, e =&gt; e.minWidth, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GetPreferredWidth:返回布局元素的首选宽度</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 返回布局元素的首选宽度</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 查询GameObject中实现ILayoutElement的所有组件。使用具有此设置值的具有最高优先级的那个。如果多个组件具有此设置并且具有相同的优先级，则使用其中的最大值</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;rect&quot;&gt;</span>要查询的布局元素的RectTransform<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">GetPreferredWidth</span>(<span class="params">RectTransform rect</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Mathf.Max(GetLayoutProperty(rect, e =&gt; e.minWidth, <span class="number">0</span>), GetLayoutProperty(rect, e =&gt; e.preferredWidth, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GetFlexibleWidth:返回布局元素的灵活宽度</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 返回布局元素的灵活宽度</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 查询GameObject中实现ILayoutElement的所有组件。使用具有此设置值的具有最高优先级的那个。如果多个组件具有此设置并且具有相同的优先级，则使用其中的最大值</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;rect&quot;&gt;</span>要查询的布局元素的RectTransform<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">GetFlexibleWidth</span>(<span class="params">RectTransform rect</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> GetLayoutProperty(rect, e =&gt; e.flexibleWidth, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GetMinHeight:返回布局元素的最小高度</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 返回布局元素的最小高度</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 查询GameObject中实现ILayoutElement的所有组件。使用具有此设置值的具有最高优先级的那个。如果多个组件具有此设置并且具有相同的优先级，则使用其中的最大值</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;rect&quot;&gt;</span>要查询的布局元素的RectTransform<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">GetMinHeight</span>(<span class="params">RectTransform rect</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> GetLayoutProperty(rect, e =&gt; e.minHeight, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GetPreferredHeight:返回布局元素的首选高度</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 返回布局元素的首选高度</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 查询GameObject中实现ILayoutElement的所有组件。使用具有此设置值的具有最高优先级的那个。如果多个组件具有此设置并且具有相同的优先级，则使用其中的最大值</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;rect&quot;&gt;</span>要查询的布局元素的RectTransform<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">GetPreferredHeight</span>(<span class="params">RectTransform rect</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Mathf.Max(GetLayoutProperty(rect, e =&gt; e.minHeight, <span class="number">0</span>), GetLayoutProperty(rect, e =&gt; e.preferredHeight, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GetFlexibleHeight:返回布局元素的灵活高度</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 返回布局元素的灵活高度</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 查询GameObject中实现ILayoutElement的所有组件。使用具有此设置值的具有最高优先级的那个。如果多个组件具有此设置并且具有相同的优先级，则使用其中的最大值</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;rect&quot;&gt;</span>要查询的布局元素的RectTransform<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">GetFlexibleHeight</span>(<span class="params">RectTransform rect</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> GetLayoutProperty(rect, e =&gt; e.flexibleHeight, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GetLayoutProperty:获取具有给定RectTransform的布局元素的计算布局属性</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 获取具有给定RectTransform的布局元素的计算布局属性</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;rect&quot;&gt;</span>布局元素的RectTransform，用于获取。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;property&quot;&gt;</span>要计算的属性。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;defaultValue&quot;&gt;</span>如果布局元素上没有组件提供给定属性，则使用的默认值<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span> layout属性的计算值。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">GetLayoutProperty</span>(<span class="params">RectTransform rect, System.Func&lt;ILayoutElement, <span class="built_in">float</span>&gt; property, <span class="built_in">float</span> defaultValue</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ILayoutElement dummy;</span><br><span class="line">    <span class="keyword">return</span> GetLayoutProperty(rect, property, defaultValue, <span class="keyword">out</span> dummy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GetLayoutProperty:遍历对象身上所有的ILayoutElement类型的组件，使用优先级最高组件的属性值，若组件优先级一致，则取数值最大的属性值，注意的是取得Preferred属性时会比较Preferred和Min的大小，取数值大的</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 获取具有给定RectTransform的布局元素的计算布局属性</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;rect&quot;&gt;</span>布局元素的RectTransform，用于获取。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;property&quot;&gt;</span>要计算的属性。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;defaultValue&quot;&gt;</span>如果布局元素上没有组件提供给定属性，则使用的默认值<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;source&quot;&gt;</span>可选的out参数，用于获取提供计算值的组件。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span> layout属性的计算值。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> GetLayoutPropertypublic <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">GetLayoutProperty</span>(<span class="params">RectTransform rect, System.Func&lt;ILayoutElement, <span class="built_in">float</span>&gt; property, <span class="built_in">float</span> defaultValue, <span class="keyword">out</span> ILayoutElement source</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    source = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (rect == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">float</span> min = defaultValue;</span><br><span class="line">    <span class="built_in">int</span> maxPriority = System.Int32.MinValue;</span><br><span class="line">    <span class="keyword">var</span> components = ListPool&lt;Component&gt;.Get();</span><br><span class="line">    rect.GetComponents(<span class="keyword">typeof</span>(ILayoutElement), components);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; components.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> layoutComp = components[i] <span class="keyword">as</span> ILayoutElement;</span><br><span class="line">        <span class="keyword">if</span> (layoutComp <span class="keyword">is</span> Behaviour &amp;&amp; !((Behaviour)layoutComp).isActiveAndEnabled)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> priority = layoutComp.layoutPriority;</span><br><span class="line">        <span class="comment">// 如果这个布局组件的优先级低于先前使用的组件，忽略它</span></span><br><span class="line">        <span class="keyword">if</span> (priority &lt; maxPriority)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">float</span> prop = property(layoutComp);</span><br><span class="line">        <span class="comment">// 如果此布局属性设置为负值，则意味着应该忽略它</span></span><br><span class="line">        <span class="keyword">if</span> (prop &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个布局组件的优先级高于前面所有组件，</span></span><br><span class="line">        <span class="comment">// 用这个值覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (priority &gt; maxPriority)</span><br><span class="line">        &#123;</span><br><span class="line">            min = prop;</span><br><span class="line">            maxPriority = priority;</span><br><span class="line">            source = layoutComp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果布局组件与之前使用的组件具有相同的优先级，</span></span><br><span class="line">        <span class="comment">// 使用具有相同优先级的最大值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (prop &gt; min)</span><br><span class="line">        &#123;</span><br><span class="line">            min = prop;</span><br><span class="line">            source = layoutComp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListPool&lt;Component&gt;.Release(components);</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">布局的工具类</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——ContentSizeFitter</title>
    <link href="https://azzurebubble.github.io/posts/50b8b756.html"/>
    <id>https://azzurebubble.github.io/posts/50b8b756.html</id>
    <published>2024-08-06T13:37:41.000Z</published>
    <updated>2024-08-07T14:26:33.623Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ContentSizeFitter：它用于自适应对象尺寸，根据ILayoutElement接口的子物体调整自身大小。在使用时要注意，挂载ContentSizeFitter后，大小变化可能需要下一帧生效，可通过调用SetLayoutHorizontal或ForceRebuildLayoutImmediate方法强制更新。</p><p>ContentSizeFitter不改变子物体的大小和位置，而是根据子物体(ILayoutElement)来改变自身的尺寸<br>ContentSizeFitter所<a href="https://so.csdn.net/so/search?q=%E6%8C%82%E8%BD%BD&amp;spm=1001.2101.3001.7020">挂载</a>的对象上必须挂载了实现ILayoutElement接口的组件</p></blockquote><h4 id="源码解析">源码解析</h4><blockquote><p>FitMode：自适应尺寸适合模式。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> FitMode</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 不做任何大小调整</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    Unconstrained,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 将大小调整为内容的最小大小</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    MinSize,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 将大小调整为内容的首选大小</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    PreferredSize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一些字段参数</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 用于宽度自适应尺寸适合模式。默认是不做任何调整</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">protected</span> FitMode m_HorizontalFit = FitMode.Unconstrained;</span><br><span class="line"><span class="keyword">public</span> FitMode horizontalFit &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_HorizontalFit; &#125; <span class="keyword">set</span> &#123; <span class="keyword">if</span> (SetPropertyUtility.SetStruct(<span class="keyword">ref</span> m_HorizontalFit, <span class="keyword">value</span>)) SetDirty(); &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 用于高度自适应尺寸适合模式。默认是不做任何调整</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">protected</span> FitMode m_VerticalFit = FitMode.Unconstrained;</span><br><span class="line"><span class="keyword">public</span> FitMode verticalFit &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_VerticalFit; &#125; <span class="keyword">set</span> &#123; <span class="keyword">if</span> (SetPropertyUtility.SetStruct(<span class="keyword">ref</span> m_VerticalFit, <span class="keyword">value</span>)) SetDirty(); &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前挂载ContentSizeFitter组件对象的RectTransform</span></span><br><span class="line">[<span class="meta">System.NonSerialized</span>] <span class="keyword">private</span> RectTransform m_Rect;</span><br><span class="line"><span class="keyword">private</span> RectTransform rectTransform</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Rect == <span class="literal">null</span>)</span><br><span class="line">            m_Rect = GetComponent&lt;RectTransform&gt;();</span><br><span class="line">        <span class="keyword">return</span> m_Rect;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>生命周期</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">base</span>.OnEnable();</span><br><span class="line">    SetDirty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 清空追踪器</span></span><br><span class="line">     m_Tracker.Clear();</span><br><span class="line">    <span class="comment">// 强制重构布局</span></span><br><span class="line">     LayoutRebuilder.MarkLayoutForRebuild(rectTransform);</span><br><span class="line">     <span class="keyword">base</span>.OnDisable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果关联的 RectTransform 发生改变则调用这个函数</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnRectTransformDimensionsChange</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    SetDirty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnValidate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        SetDirty();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>SetDirty：强制重建布局</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">SetDirty</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!IsActive())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 如果是激活状态 强制重构布局</span></span><br><span class="line">    LayoutRebuilder.MarkLayoutForRebuild(rectTransform);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetLayoutHorizontal：计算并将大小的水平分量应用于RectTransform</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetLayoutHorizontal</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    m_Tracker.Clear();</span><br><span class="line">    HandleSelfFittingAlongAxis(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetLayoutVertical：计算并将大小的垂直分量应用于RectTransform</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetLayoutVertical</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    HandleSelfFittingAlongAxis(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>HandleSelfFittingAlongAxis：设置对象的位置和大小，对象属性直接通过LayoutUtility.GetMinSize与LayoutUtility.GetPreferredSize获取，获取时会从对象自身查找ILayoutElement，获取到minWidth与preferredWidth，如果不存在则返回默认值0</p></blockquote><p><a href="https://azurebubble.github.io/posts/a99e5cea.html"><strong>UGUI源码解析——LayoutUtility</strong></a></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleSelfFittingAlongAxis</span>(<span class="params"><span class="built_in">int</span> axis</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取水平或者垂直方向的自适应模式</span></span><br><span class="line">     FitMode fitting = (axis == <span class="number">0</span> ? horizontalFit : verticalFit);</span><br><span class="line">     <span class="keyword">if</span> (fitting == FitMode.Unconstrained)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">// 保持对跟踪变换的引用，但不要控制它的属性</span></span><br><span class="line">         <span class="comment">// 不做任何大小调整</span></span><br><span class="line">         m_Tracker.Add(<span class="keyword">this</span>, rectTransform, DrivenTransformProperties.None);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 如果不是 Unconstrained 模式，则关联 rectTransform 的 X 轴和 Y 轴变化，对rectTransform进行调整</span></span><br><span class="line">     m_Tracker.Add(<span class="keyword">this</span>, rectTransform, (axis == <span class="number">0</span> ? DrivenTransformProperties.SizeDeltaX : DrivenTransformProperties.SizeDeltaY));</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 设置大小为最小或首选大小</span></span><br><span class="line">     <span class="keyword">if</span> (fitting == FitMode.MinSize)</span><br><span class="line">         rectTransform.SetSizeWithCurrentAnchors((RectTransform.Axis)axis, LayoutUtility.GetMinSize(m_Rect, axis));</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         rectTransform.SetSizeWithCurrentAnchors((RectTransform.Axis)axis, LayoutUtility.GetPreferredSize(m_Rect, axis));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：给对象身上挂载ContentSizeFitter组件后设置PreferredSize后立即获取rectTransform.sizeDelte或rectTransform.rect.size还是之前的值，下一帧后获取才是真实的size，可以使用以下方法执行一次更新方法再去获取rect</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种 SetLayoutHorizontal 里会对 m_Tracker 进行清空后再执行 HandleSelfFittingAlongAxis</span></span><br><span class="line">GetComponent&lt;ContentSizeFitter&gt;().SetLayoutHorizontal();</span><br><span class="line"><span class="comment">//第二种 强制重建</span></span><br><span class="line">LayoutRebuilder.ForceRebuildLayoutImmediate(txt.rectTransform);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">继承了ILayoutElement和ILayoutSelfController，是调整对象自适应的组件。</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——GridLayoutGroup</title>
    <link href="https://azzurebubble.github.io/posts/5f14f802.html"/>
    <id>https://azzurebubble.github.io/posts/5f14f802.html</id>
    <published>2024-07-29T13:04:42.000Z</published>
    <updated>2024-08-06T13:36:40.327Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>GridLayoutGroup：继承自LayoutGroup，为网格布局组件，它同时实现了水平和竖直布局。</p></blockquote><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><blockquote><p>枚举Corner：标记网格起始的位置，有左上角、右上角、左下角、右下角。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Corner</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 左上角</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    UpperLeft = <span class="number">0</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 右上角</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    UpperRight = <span class="number">1</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 左下角</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    LowerLeft = <span class="number">2</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 右下角</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    LowerRight = <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Axis：标记开始排列的轴方向，有水平轴和垂直轴。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Axis</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 水平轴</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    Horizontal = <span class="number">0</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 垂直轴</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    Vertical = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Constraint：约束行列的个数</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Constraint</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 不限制行列多少个</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    Flexible = <span class="number">0</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 约束行数</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    FixedColumnCount = <span class="number">1</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 约束列数</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    FixedRowCount = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一些序列化的字段</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 单元格起始角 Corner</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">protected</span> Corner m_StartCorner = Corner.UpperLeft;</span><br><span class="line"><span class="keyword">public</span> Corner startCorner &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_StartCorner; &#125; <span class="keyword">set</span> &#123; SetProperty(<span class="keyword">ref</span> m_StartCorner, <span class="keyword">value</span>); &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 单元格沿着哪个轴开始放置填充，优先填满一个轴才进行换轴</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">protected</span> Axis m_StartAxis = Axis.Horizontal;</span><br><span class="line"><span class="keyword">public</span> Axis startAxis &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_StartAxis; &#125; <span class="keyword">set</span> &#123; SetProperty(<span class="keyword">ref</span> m_StartAxis, <span class="keyword">value</span>); &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 单元格大小</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">protected</span> Vector2 m_CellSize = <span class="keyword">new</span> Vector2(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">public</span> Vector2 cellSize &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_CellSize; &#125; <span class="keyword">set</span> &#123; SetProperty(<span class="keyword">ref</span> m_CellSize, <span class="keyword">value</span>); &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 单元格两个轴向上的间距</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">protected</span> Vector2 m_Spacing = Vector2.zero;</span><br><span class="line"><span class="keyword">public</span> Vector2 spacing &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_Spacing; &#125; <span class="keyword">set</span> &#123; SetProperty(<span class="keyword">ref</span> m_Spacing, <span class="keyword">value</span>); &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 行列约束的规则 Constraint</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">protected</span> Constraint m_Constraint = Constraint.Flexible;</span><br><span class="line"><span class="keyword">public</span> Constraint constraint &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_Constraint; &#125; <span class="keyword">set</span> &#123; SetProperty(<span class="keyword">ref</span> m_Constraint, <span class="keyword">value</span>); &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 约束轴上限制最多存在多少个单元格</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">protected</span> <span class="built_in">int</span> m_ConstraintCount = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> constraintCount &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_ConstraintCount; &#125; <span class="keyword">set</span> &#123; SetProperty(<span class="keyword">ref</span> m_ConstraintCount, Mathf.Max(<span class="number">1</span>, <span class="keyword">value</span>)); &#125; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>OnValidate：强制刷新 constraintCount 确保它的值在编辑器中能被正确应用和验证。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnValidate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnValidate();</span><br><span class="line">        constraintCount = constraintCount;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><a href="https://azurebubble.github.io/posts/51e1a8f9.html"><strong>UGUI源码解析——LayoutGroup</strong></a></p><blockquote><p>CalculateLayoutInputHorizontal：由布局系统调用，计算水平布局的大小。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">CalculateLayoutInputHorizontal</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">base</span>.CalculateLayoutInputHorizontal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据约束类型 计算列数</span></span><br><span class="line">    <span class="built_in">int</span> minColumns = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> preferredColumns = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (m_Constraint == Constraint.FixedColumnCount)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果约束类型是固定列数，则最小列数和首选列数都设置为 m_ConstraintCount</span></span><br><span class="line">        minColumns = preferredColumns = m_ConstraintCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m_Constraint == Constraint.FixedRowCount)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果约束类型是固定行数，则根据子对象的数量和行数约束计算最小列数和首选列数</span></span><br><span class="line">        minColumns = preferredColumns = Mathf.CeilToInt(rectChildren.Count / (<span class="built_in">float</span>)m_ConstraintCount - <span class="number">0.001f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果没有约束，则最小列数为1，首选列数为平方根下的子对象数量向上取整</span></span><br><span class="line">        minColumns = <span class="number">1</span>;</span><br><span class="line">        preferredColumns = Mathf.CeilToInt(Mathf.Sqrt(rectChildren.Count));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// padding.horizontal：表示水平方向上的内边距。</span></span><br><span class="line">    <span class="comment">// (cellSize.x + spacing.x) * minColumns - spacing.x 表示根据列数计算出的最小宽度，考虑了每个单元格的大小和间距。</span></span><br><span class="line">    <span class="comment">// (cellSize.x + spacing.x) * preferredColumns - spacing.x 表示根据列数计算出的首选宽度，同样考虑了每个单元格的大小和间距。</span></span><br><span class="line">    SetLayoutInputForAxis(</span><br><span class="line">        padding.horizontal + (cellSize.x + spacing.x) * minColumns - spacing.x,</span><br><span class="line">        padding.horizontal + (cellSize.x + spacing.x) * preferredColumns - spacing.x,</span><br><span class="line">        <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CalculateLayoutInputVertical：由布局系统调用，计算垂直布局的大小。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">CalculateLayoutInputVertical</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 计算最小行数</span></span><br><span class="line">    <span class="built_in">int</span> minRows = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (m_Constraint == Constraint.FixedColumnCount)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果约束类型是固定列数，则根据子对象数量和列数约束计算最小行数</span></span><br><span class="line">        minRows = Mathf.CeilToInt(rectChildren.Count / (<span class="built_in">float</span>)m_ConstraintCount - <span class="number">0.001f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m_Constraint == Constraint.FixedRowCount)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果约束类型是固定行数，则最小行数直接设置为 m_ConstraintCount</span></span><br><span class="line">        minRows = m_ConstraintCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果没有约束，则根据容器宽度计算可以容纳的列数，再根据子对象数量计算最小行数</span></span><br><span class="line">        <span class="built_in">float</span> width = rectTransform.rect.width;</span><br><span class="line">        <span class="built_in">int</span> cellCountX = Mathf.Max(<span class="number">1</span>, Mathf.FloorToInt((width - padding.horizontal + spacing.x + <span class="number">0.001f</span>) / (cellSize.x + spacing.x)));</span><br><span class="line">        minRows = Mathf.CeilToInt(rectChildren.Count / (<span class="built_in">float</span>)cellCountX);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// padding.vertical：表示垂直方向上的内边距。</span></span><br><span class="line">    <span class="comment">// (cellSize.y + spacing.y) * minRows - spacing.y 表示根据行数计算出的垂直方向上的最小高度，考虑了每个单元格的大小和间距。</span></span><br><span class="line">    <span class="built_in">float</span> minSpace = padding.vertical + (cellSize.y + spacing.y) * minRows - spacing.y;</span><br><span class="line">    SetLayoutInputForAxis(minSpace, minSpace, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>SetLayoutVertical：这个方法通常用于在水平方向上设置布局，以确保布局组件内的子对象按照规定的方式进行排列和调整位置。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">SetLayoutVertical</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    SetCellsAlongAxis(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetCellsAlongAxis</span>(<span class="params"><span class="built_in">int</span> axis</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//通常情况下，布局控制器应该只在调用水平轴时设置水平值</span></span><br><span class="line"><span class="comment">//当对垂直轴调用时，只调用垂直值。</span></span><br><span class="line"><span class="comment">//然而，在本例中，我们在调用垂直轴时设置了水平和垂直位置。</span></span><br><span class="line"><span class="comment">//因为我们只设置水平位置而不设置大小，所以它应该不会影响子元素的布局。</span></span><br><span class="line"><span class="comment">//因此不应该打破所有水平布局必须在所有垂直布局之前计算的规则。</span></span><br><span class="line">    <span class="keyword">if</span> (axis == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 仅在调用水平轴时设置大小，而不是位置。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; rectChildren.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            RectTransform rect = rectChildren[i];</span><br><span class="line"></span><br><span class="line">            m_Tracker.Add(<span class="keyword">this</span>, rect,</span><br><span class="line">                DrivenTransformProperties.Anchors |</span><br><span class="line">                DrivenTransformProperties.AnchoredPosition |</span><br><span class="line">                DrivenTransformProperties.SizeDelta);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置所有子元素的锚点为左上角(0,1) 并且设置他们的大小为cellSize</span></span><br><span class="line">            rect.anchorMin = Vector2.up;</span><br><span class="line">            rect.anchorMax = Vector2.up;</span><br><span class="line">            rect.sizeDelta = cellSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果垂直轴的布局</span></span><br><span class="line">    <span class="built_in">float</span> width = rectTransform.rect.size.x; <span class="comment">// 容器的宽度</span></span><br><span class="line">    <span class="built_in">float</span> height = rectTransform.rect.size.y; <span class="comment">// 容器的高度</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> cellCountX = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> cellCountY = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (m_Constraint == Constraint.FixedColumnCount)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果限制了列数</span></span><br><span class="line">        <span class="comment">// 设置 X 轴的格子数量为预定义数量</span></span><br><span class="line">        cellCountX = m_ConstraintCount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果子元素的数量大于预定义的 X 轴格子数 则计算 Y 轴行数</span></span><br><span class="line">        <span class="keyword">if</span> (rectChildren.Count &gt; cellCountX)</span><br><span class="line">            <span class="comment">// 如果有余数 则 再加 1</span></span><br><span class="line">            cellCountY = rectChildren.Count / cellCountX + (rectChildren.Count % cellCountX &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m_Constraint == Constraint.FixedRowCount)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果限制了行数</span></span><br><span class="line">        cellCountY = m_ConstraintCount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果子元素数量大于限制行数 则计算列数</span></span><br><span class="line">        <span class="keyword">if</span> (rectChildren.Count &gt; cellCountY)</span><br><span class="line">            cellCountX = rectChildren.Count / cellCountY + (rectChildren.Count % cellCountY &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果没有限制</span></span><br><span class="line">        <span class="comment">// 如果单元格大小+间距小于等于0，表示水平方向没有元素数量限制，应尽可能容纳多的元素</span></span><br><span class="line">        <span class="keyword">if</span> (cellSize.x + spacing.x &lt;= <span class="number">0</span>)</span><br><span class="line">            cellCountX = <span class="built_in">int</span>.MaxValue;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 否则，计算水平方向上可以容纳的单元格数量。使用 Mathf.FloorToInt 函数计算 (width - padding.horizontal + spacing.x + 0.001f) / (cellSize.x + spacing.x)，这个表达式计算容器宽度减去水平填充、加上间距和微小调整后能容纳多少个单元格的整数部分。</span></span><br><span class="line">            cellCountX = Mathf.Max(<span class="number">1</span>, Mathf.FloorToInt((width - padding.horizontal + spacing.x + <span class="number">0.001f</span>) / (cellSize.x + spacing.x)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">        <span class="keyword">if</span> (cellSize.y + spacing.y &lt;= <span class="number">0</span>)</span><br><span class="line">            cellCountY = <span class="built_in">int</span>.MaxValue;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cellCountY = Mathf.Max(<span class="number">1</span>, Mathf.FloorToInt((height - padding.vertical + spacing.y + <span class="number">0.001f</span>) / (cellSize.y + spacing.y)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算起始角的坐标</span></span><br><span class="line">    <span class="built_in">int</span> cornerX = (<span class="built_in">int</span>)startCorner % <span class="number">2</span>; <span class="comment">// (0/1)</span></span><br><span class="line">    <span class="built_in">int</span> cornerY = (<span class="built_in">int</span>)startCorner / <span class="number">2</span>; <span class="comment">// (0/1)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算主轴上的单元格数量</span></span><br><span class="line">    <span class="built_in">int</span> cellsPerMainAxis, actualCellCountX, actualCellCountY;</span><br><span class="line">    <span class="keyword">if</span> (startAxis == Axis.Horizontal)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 主轴最大数量</span></span><br><span class="line">        cellsPerMainAxis = cellCountX;</span><br><span class="line">        <span class="comment">// 横轴最大数量</span></span><br><span class="line">        actualCellCountX = Mathf.Clamp(cellCountX, <span class="number">1</span>, rectChildren.Count);</span><br><span class="line">        <span class="comment">// 竖轴最大数量</span></span><br><span class="line">        actualCellCountY = Mathf.Clamp(cellCountY, <span class="number">1</span>, Mathf.CeilToInt(rectChildren.Count / (<span class="built_in">float</span>)cellsPerMainAxis));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 同上 计算垂直布局</span></span><br><span class="line">        cellsPerMainAxis = cellCountY;</span><br><span class="line">        actualCellCountY = Mathf.Clamp(cellCountY, <span class="number">1</span>, rectChildren.Count);</span><br><span class="line">        actualCellCountX = Mathf.Clamp(cellCountX, <span class="number">1</span>, Mathf.CeilToInt(rectChildren.Count / (<span class="built_in">float</span>)cellsPerMainAxis));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算容器所需的空间大小</span></span><br><span class="line">    Vector2 requiredSpace = <span class="keyword">new</span> Vector2(</span><br><span class="line">        actualCellCountX * cellSize.x + (actualCellCountX - <span class="number">1</span>) * spacing.x,</span><br><span class="line">        actualCellCountY * cellSize.y + (actualCellCountY - <span class="number">1</span>) * spacing.y</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 计算起始偏移量</span></span><br><span class="line">    Vector2 startOffset = <span class="keyword">new</span> Vector2(</span><br><span class="line">        GetStartOffset(<span class="number">0</span>, requiredSpace.x),</span><br><span class="line">        GetStartOffset(<span class="number">1</span>, requiredSpace.y)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置子元素的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; rectChildren.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> positionX;</span><br><span class="line">        <span class="built_in">int</span> positionY;</span><br><span class="line">        <span class="keyword">if</span> (startAxis == Axis.Horizontal)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 假设水平轴限制最多两个元素</span></span><br><span class="line">            <span class="comment">// X ： 0 % 2 = 0  1 % 2 = 1 2 % 2 = 0 3 % 2 = 1 .....</span></span><br><span class="line">            <span class="comment">// Y ： 0 / 2 = 0  1 / 2 = 0 2 / 2 = 1 3 / 2 = 1 ..... </span></span><br><span class="line">            positionX = i % cellsPerMainAxis;</span><br><span class="line">            positionY = i / cellsPerMainAxis;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 垂直轴 同上</span></span><br><span class="line">            positionX = i / cellsPerMainAxis;</span><br><span class="line">            positionY = i % cellsPerMainAxis;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据起始角的位置 计算元素的位置 假设是一个四行三列的布局</span></span><br><span class="line">        <span class="comment">// 例如如果起始角为左上角(0,0)，则第一个元素坐标为(0,0)</span></span><br><span class="line">        <span class="comment">// 如果起始角为右上角(1,0)，则第一个元素坐标为(2,0) 以此类推</span></span><br><span class="line">        <span class="keyword">if</span> (cornerX == <span class="number">1</span>)</span><br><span class="line">            positionX = actualCellCountX - <span class="number">1</span> - positionX;</span><br><span class="line">        <span class="keyword">if</span> (cornerY == <span class="number">1</span>)</span><br><span class="line">            positionY = actualCellCountY - <span class="number">1</span> - positionY;</span><br><span class="line"></span><br><span class="line">        SetChildAlongAxis(rectChildren[i], <span class="number">0</span>, startOffset.x + (cellSize[<span class="number">0</span>] + spacing[<span class="number">0</span>]) * positionX, cellSize[<span class="number">0</span>]);</span><br><span class="line">        SetChildAlongAxis(rectChildren[i], <span class="number">1</span>, startOffset.y + (cellSize[<span class="number">1</span>] + spacing[<span class="number">1</span>]) * positionY, cellSize[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">继承自LayoutGroup，为网格布局组件，它同时实现了水平和竖直布局。</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——VerticalLayoutGroup</title>
    <link href="https://azzurebubble.github.io/posts/61697f5e.html"/>
    <id>https://azzurebubble.github.io/posts/61697f5e.html</id>
    <published>2024-07-29T13:04:25.000Z</published>
    <updated>2024-07-29T13:17:36.576Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>VerticalLayoutGroup：继承自HorizontalOrVerticalLayoutGroup，HorizontalOrVerticalLayoutGroup继承自LayoutGroup，是垂直布局组件。会受到LayoutElement组件的影响。</p></blockquote><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p><a href="https://azurebubble.github.io/posts/51e1a8f9.html"><strong>UGUI源码解析——LayoutGroup</strong></a></p><blockquote><p>CalculateLayoutInputHorizontal：由布局系统调用。也请参见ILayoutElement。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现了计算并设置m_TotalMinSize、m_TotalPreferredSize、m_TotalFlexibleSize属性值，调用了基类LayoutGroup中的SetLayoutInputForAxis方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">CalculateLayoutInputHorizontal</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">base</span>.CalculateLayoutInputHorizontal();</span><br><span class="line">    CalcAlongAxis(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CalculateLayoutInputVertical：</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">CalculateLayoutInputVertical</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    CalcAlongAxis(<span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetLayoutHorizontal：实现了设置子物体的位置和大小，调用了基类LayoutGroup中的SetChildAlongAxisWithScale或SetChildAlongAxis方法</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">SetLayoutHorizontal</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    SetChildrenAlongAxis(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetLayoutHorizontal：实现了设置子物体的位置和大小，调用了基类LayoutGroup中的SetChildAlongAxisWithScale或SetChildAlongAxis方法</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">SetLayoutVertical</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    SetChildrenAlongAxis(<span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">继承自HorizontalOrVerticalLayoutGroup，HorizontalOrVerticalLayoutGroup继承自LayoutGroup，是垂直布局组件。会受到LayoutElement组件的影响。</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——HorizontalLayoutGroup</title>
    <link href="https://azzurebubble.github.io/posts/2fff82bf.html"/>
    <id>https://azzurebubble.github.io/posts/2fff82bf.html</id>
    <published>2024-07-29T13:04:11.000Z</published>
    <updated>2024-07-29T13:15:15.090Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>HorizontalLayoutGroup：继承自HorizontalOrVerticalLayoutGroup，HorizontalOrVerticalLayoutGroup继承自LayoutGroup，是水平布局组件。会受到LayoutElement组件的影响。</p></blockquote><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p><a href="https://azurebubble.github.io/posts/51e1a8f9.html"><strong>UGUI源码解析——LayoutGroup</strong></a></p><blockquote><p>CalculateLayoutInputHorizontal：由布局系统调用。也请参见ILayoutElement。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现了计算并设置m_TotalMinSize、m_TotalPreferredSize、m_TotalFlexibleSize属性值，调用了基类LayoutGroup中的SetLayoutInputForAxis方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">CalculateLayoutInputHorizontal</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">base</span>.CalculateLayoutInputHorizontal();</span><br><span class="line">    CalcAlongAxis(<span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CalculateLayoutInputVertical：</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">CalculateLayoutInputVertical</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    CalcAlongAxis(<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetLayoutHorizontal：实现了设置子物体的位置和大小，调用了基类LayoutGroup中的SetChildAlongAxisWithScale或SetChildAlongAxis方法</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">SetLayoutHorizontal</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    SetChildrenAlongAxis(<span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetLayoutHorizontal：实现了设置子物体的位置和大小，调用了基类LayoutGroup中的SetChildAlongAxisWithScale或SetChildAlongAxis方法</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">SetLayoutVertical</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    SetChildrenAlongAxis(<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">继承自HorizontalOrVerticalLayoutGroup，HorizontalOrVerticalLayoutGroup继承自LayoutGroup，是水平布局组件。</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——HorizontalOrVerticalLayoutGroup</title>
    <link href="https://azzurebubble.github.io/posts/50159f2d.html"/>
    <id>https://azzurebubble.github.io/posts/50159f2d.html</id>
    <published>2024-07-23T12:23:44.000Z</published>
    <updated>2024-07-23T13:06:17.395Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>继承自LayoutGroup，是HorizontalLayoutGroup和VerticalLayoutGroup的父类，提供了一些HorizontalLayoutGroup和VerticalLayoutGroup通用的方法。</p></blockquote><h4 id="源码解析">源码解析</h4><blockquote><p>spacing：布局组中布局元素之间使用的间距。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">protected</span> <span class="built_in">float</span> m_Spacing = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> spacing &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_Spacing; &#125; <span class="keyword">set</span> &#123; SetProperty(<span class="keyword">ref</span> m_Spacing, <span class="keyword">value</span>); &#125; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>childForceExpandWidth：是否强迫孩子们扩展以填充额外的可用水平空间。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">protected</span> <span class="built_in">bool</span> m_ChildForceExpandWidth = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> childForceExpandWidth &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_ChildForceExpandWidth; &#125; <span class="keyword">set</span> &#123; SetProperty(<span class="keyword">ref</span> m_ChildForceExpandWidth, <span class="keyword">value</span>); &#125; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>childForceExpandHeight：是否强迫孩子们扩展以填充额外的可用垂直空间。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">protected</span> <span class="built_in">bool</span> m_ChildForceExpandHeight = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> childForceExpandHeight &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_ChildForceExpandHeight; &#125; <span class="keyword">set</span> &#123; SetProperty(<span class="keyword">ref</span> m_ChildForceExpandHeight, <span class="keyword">value</span>); &#125; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>childControlWidth：如果布局组控制其子元素的宽度则返回true。如果子节点控制自己的宽度，则返回false。</p><p>如果设置为false，布局组将只影响子元素的位置而不影响宽度。在这种情况下，子元素的宽度可以通过各自的RectTransforms来设置。</p><p>如果设置为true，子元素的宽度将由布局组根据它们各自的最小宽度、首选宽度和灵活宽度自动驱动。如果子节点的宽度应该根据可用空间的大小而变化，这是很有用的。在这种情况下，不能在RectTransform中手动设置每个子元素的宽度，但是可以通过向其添加LayoutElement组件来控制每个子元素的最小、首选和灵活宽度。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">protected</span> <span class="built_in">bool</span> m_ChildControlWidth = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> childControlWidth &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_ChildControlWidth; &#125; <span class="keyword">set</span> &#123; SetProperty(<span class="keyword">ref</span> m_ChildControlWidth, <span class="keyword">value</span>); &#125; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>childControlHeight：如果Layout Group控制其子元素的高度，则返回true。如果孩子控制自己的高度返回false。</p><p>如果设置为false，布局组将只影响子元素的位置而不影响高度。在这种情况下，子元素的高度可以通过各自的RectTransforms来设置。</p><p>如果设置为true，子元素的高度由布局组根据它们各自的最小高度、首选高度和灵活高度自动驱动。如果孩子的高度应该根据可用空间的大小而变化，这是有用的。在这种情况下，不能在RectTransform中手动设置每个子元素的高度，但是可以通过向其添加LayoutElement组件来控制每个子元素的最小、首选和灵活高度。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">protected</span> <span class="built_in">bool</span> m_ChildControlHeight = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> childControlHeight &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_ChildControlHeight; &#125; <span class="keyword">set</span> &#123; SetProperty(<span class="keyword">ref</span> m_ChildControlHeight, <span class="keyword">value</span>); &#125; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>m_ChildScaleWidth：孩子的宽度是否按x尺度缩放。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">protected</span> <span class="built_in">bool</span> m_ChildScaleWidth = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> childScaleWidth &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_ChildScaleWidth; &#125; <span class="keyword">set</span> &#123; SetProperty(<span class="keyword">ref</span> m_ChildScaleWidth, <span class="keyword">value</span>); &#125; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>childScaleHeight：孩子的高度是否按y尺度缩放。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">protected</span> <span class="built_in">bool</span> m_ChildScaleHeight = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> childScaleHeight &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_ChildScaleHeight; &#125; <span class="keyword">set</span> &#123; SetProperty(<span class="keyword">ref</span> m_ChildScaleHeight, <span class="keyword">value</span>); &#125; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>CalcAlongAxis：计算该布局元素沿给定轴的布局元素属性。0表示水平，1表示垂直。这个组是否是垂直组。计算minWidth、preferredWidth、flexibleWidth、minHeight、preferredHeight、flexibleHeight属性值，并通过父类LayoutGroup中的SetLayoutInputForAxis方法设置属性值</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算minWidth、preferredWidth、flexibleWidth、minHeight、preferredHeight、flexibleHeight属性值，并通过父类LayoutGroup中的SetLayoutInputForAxis方法设置属性值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">CalcAlongAxis</span>(<span class="params"><span class="built_in">int</span> axis, <span class="built_in">bool</span> isVertical</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 计算子元素布局时所考虑的边距总和，取决于是水平还是垂直布局</span></span><br><span class="line">    <span class="built_in">float</span> combinedPadding = (axis == <span class="number">0</span> ? padding.horizontal : padding.vertical);</span><br><span class="line">    <span class="comment">// 是否控制子元素的尺寸</span></span><br><span class="line">    <span class="built_in">bool</span> controlSize = (axis == <span class="number">0</span> ? m_ChildControlWidth : m_ChildControlHeight);</span><br><span class="line">    <span class="comment">// 是否使用缩放来调整子元素的尺寸</span></span><br><span class="line">    <span class="built_in">bool</span> useScale = (axis == <span class="number">0</span> ? m_ChildScaleWidth : m_ChildScaleHeight);</span><br><span class="line">    <span class="comment">// 子元素是否强制扩展尺寸</span></span><br><span class="line">    <span class="built_in">bool</span> childForceExpandSize = (axis == <span class="number">0</span> ? m_ChildForceExpandWidth : m_ChildForceExpandHeight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化为零，分别用于累积最小尺寸、首选尺寸和灵活尺寸</span></span><br><span class="line">    <span class="built_in">float</span> totalMin = combinedPadding;</span><br><span class="line">    <span class="built_in">float</span> totalPreferred = combinedPadding;</span><br><span class="line">    <span class="built_in">float</span> totalFlexible = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// （表示是否沿另一轴）来累积总的最小尺寸、首选尺寸和灵活尺寸。如果不是沿另一轴，还会增加间距 spacing。</span></span><br><span class="line">    <span class="built_in">bool</span> alongOtherAxis = (isVertical ^ (axis == <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; rectChildren.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        RectTransform child = rectChildren[i];</span><br><span class="line">        <span class="built_in">float</span> min, preferred, flexible;</span><br><span class="line">        GetChildSizes(child, axis, controlSize, childForceExpandSize, <span class="keyword">out</span> min, <span class="keyword">out</span> preferred, <span class="keyword">out</span> flexible);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据子元素在该轴上的缩放因子调整尺寸</span></span><br><span class="line">        <span class="keyword">if</span> (useScale)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">float</span> scaleFactor = child.localScale[axis];</span><br><span class="line">            min *= scaleFactor;</span><br><span class="line">            preferred *= scaleFactor;</span><br><span class="line">            flexible *= scaleFactor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (alongOtherAxis)</span><br><span class="line">        &#123;</span><br><span class="line">            totalMin = Mathf.Max(min + combinedPadding, totalMin);</span><br><span class="line">            totalPreferred = Mathf.Max(preferred + combinedPadding, totalPreferred);</span><br><span class="line">            totalFlexible = Mathf.Max(flexible, totalFlexible);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            totalMin += min + spacing;</span><br><span class="line">            totalPreferred += preferred + spacing;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Increment flexible size with element&#x27;s flexible size.</span></span><br><span class="line">            totalFlexible += flexible;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!alongOtherAxis &amp;&amp; rectChildren.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        totalMin -= spacing;</span><br><span class="line">        totalPreferred -= spacing;</span><br><span class="line">    &#125;</span><br><span class="line">    totalPreferred = Mathf.Max(totalMin, totalPreferred);</span><br><span class="line">    SetLayoutInputForAxis(totalMin, totalPreferred, totalFlexible, axis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GetChildSizes：计算子对象在布局组件中的尺寸大小，主要用于UI布局系统，比如Unity中的UI布局组件。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示要计算尺寸的子对象的RectTransform组件</span></span><br><span class="line"><span class="comment">// 表示计算尺寸的轴向（通常是水平轴或垂直轴，用0和1表示）</span></span><br><span class="line"><span class="comment">// 一个布尔值，表示是否应该控制子对象的尺寸。如果为false，子对象的最小尺寸、首选尺寸和灵活尺寸将直接从子对象的sizeDelta中获取；如果为true，将通过LayoutUtility来获取这些尺寸</span></span><br><span class="line"><span class="comment">// 一个布尔值，表示是否强制扩展子对象的灵活尺寸</span></span><br><span class="line"><span class="comment">// min: 输出参数，表示子对象在指定轴向上的最小尺寸。</span></span><br><span class="line"><span class="comment">// preferred: 输出参数，表示子对象在指定轴向上的首选尺寸。</span></span><br><span class="line"><span class="comment">// flexible: 输出参数，表示子对象在指定轴向上的灵活尺寸。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetChildSizes</span>(<span class="params">RectTransform child, <span class="built_in">int</span> axis, <span class="built_in">bool</span> controlSize, <span class="built_in">bool</span> childForceExpand,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">out</span> <span class="built_in">float</span> min, <span class="keyword">out</span> <span class="built_in">float</span> preferred, <span class="keyword">out</span> <span class="built_in">float</span> flexible</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!controlSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用子对象的 sizeDelta[axis] 作为最小尺寸（min）、首选尺寸（preferred），并将灵活尺寸（flexible）设为 0</span></span><br><span class="line">        min = child.sizeDelta[axis];</span><br><span class="line">        preferred = min;</span><br><span class="line">        flexible = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用 LayoutUtility 类的静态方法来获取子对象在指定轴向上的最小尺寸、首选尺寸和灵活尺寸</span></span><br><span class="line">        min = LayoutUtility.GetMinSize(child, axis);</span><br><span class="line">        preferred = LayoutUtility.GetPreferredSize(child, axis);</span><br><span class="line">        flexible = LayoutUtility.GetFlexibleSize(child, axis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (childForceExpand)</span><br><span class="line">        flexible = Mathf.Max(flexible, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetChildrenAlongAxis：为给定轴设置子布局元素的位置和大小。0表示水平，1表示垂直。是否是垂直组。计算子物体的位置和大小，并通过父类LayoutGroup中的SetChildAlongAxisWithScale方法设置位置和大小</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">SetChildrenAlongAxis</span>(<span class="params"><span class="built_in">int</span> axis, <span class="built_in">bool</span> isVertical</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取布局组件在当前轴向上的尺寸大小</span></span><br><span class="line">    <span class="built_in">float</span> size = rectTransform.rect.size[axis];</span><br><span class="line">    <span class="comment">//  控制子对象尺寸、使用缩放因子、子对象是否强制扩展尺寸的布尔参数</span></span><br><span class="line">    <span class="built_in">bool</span> controlSize = (axis == <span class="number">0</span> ? m_ChildControlWidth : m_ChildControlHeight);</span><br><span class="line">    <span class="built_in">bool</span> useScale = (axis == <span class="number">0</span> ? m_ChildScaleWidth : m_ChildScaleHeight);</span><br><span class="line">    <span class="built_in">bool</span> childForceExpandSize = (axis == <span class="number">0</span> ? m_ChildForceExpandWidth : m_ChildForceExpandHeight);</span><br><span class="line">    <span class="comment">// 获取子对象在当前轴向上的对齐方式</span></span><br><span class="line">    <span class="built_in">float</span> alignmentOnAxis = GetAlignmentOnAxis(axis);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> alongOtherAxis = (isVertical ^ (axis == <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 根据当前是否垂直布局以及轴向来决定是沿另一轴向排列还是当前轴向排列</span></span><br><span class="line">    <span class="keyword">if</span> (alongOtherAxis)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 计算沿着垂直轴或水平轴另一方向的排列</span></span><br><span class="line">        <span class="built_in">float</span> innerSize = size - (axis == <span class="number">0</span> ? padding.horizontal : padding.vertical);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; rectChildren.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 在垂直布局时，计算子对象在水平轴上的排列：根据子对象的尺寸、缩放因子和对齐方式，设置其位置</span></span><br><span class="line">            RectTransform child = rectChildren[i];</span><br><span class="line">            <span class="built_in">float</span> min, preferred, flexible;</span><br><span class="line">            GetChildSizes(child, axis, controlSize, childForceExpandSize, <span class="keyword">out</span> min, <span class="keyword">out</span> preferred, <span class="keyword">out</span> flexible);</span><br><span class="line">            <span class="built_in">float</span> scaleFactor = useScale ? child.localScale[axis] : <span class="number">1f</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">float</span> requiredSpace = Mathf.Clamp(innerSize, min, flexible &gt; <span class="number">0</span> ? size : preferred);</span><br><span class="line">            <span class="built_in">float</span> startOffset = GetStartOffset(axis, requiredSpace * scaleFactor);</span><br><span class="line">            <span class="keyword">if</span> (controlSize)</span><br><span class="line">            &#123;</span><br><span class="line">                SetChildAlongAxisWithScale(child, axis, startOffset, requiredSpace, scaleFactor);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">float</span> offsetInCell = (requiredSpace - child.sizeDelta[axis]) * alignmentOnAxis;</span><br><span class="line">                SetChildAlongAxisWithScale(child, axis, startOffset + offsetInCell, scaleFactor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 计算沿着当前轴向的排列</span></span><br><span class="line">        <span class="comment">// 计算剩余空间和灵活尺寸来确定子对象的位置和尺寸</span></span><br><span class="line">        <span class="built_in">float</span> pos = (axis == <span class="number">0</span> ? padding.left : padding.top);</span><br><span class="line">        <span class="built_in">float</span> itemFlexibleMultiplier = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">float</span> surplusSpace = size - GetTotalPreferredSize(axis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (surplusSpace &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (GetTotalFlexibleSize(axis) == <span class="number">0</span>)</span><br><span class="line">                pos = GetStartOffset(axis, GetTotalPreferredSize(axis) - (axis == <span class="number">0</span> ? padding.horizontal : padding.vertical));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (GetTotalFlexibleSize(axis) &gt; <span class="number">0</span>)</span><br><span class="line">                itemFlexibleMultiplier = surplusSpace / GetTotalFlexibleSize(axis);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">float</span> minMaxLerp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (GetTotalMinSize(axis) != GetTotalPreferredSize(axis))</span><br><span class="line">            minMaxLerp = Mathf.Clamp01((size - GetTotalMinSize(axis)) / (GetTotalPreferredSize(axis) - GetTotalMinSize(axis)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; rectChildren.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            RectTransform child = rectChildren[i];</span><br><span class="line">            <span class="built_in">float</span> min, preferred, flexible;</span><br><span class="line">            GetChildSizes(child, axis, controlSize, childForceExpandSize, <span class="keyword">out</span> min, <span class="keyword">out</span> preferred, <span class="keyword">out</span> flexible);</span><br><span class="line">            <span class="built_in">float</span> scaleFactor = useScale ? child.localScale[axis] : <span class="number">1f</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">float</span> childSize = Mathf.Lerp(min, preferred, minMaxLerp);</span><br><span class="line">            childSize += flexible * itemFlexibleMultiplier;</span><br><span class="line">            <span class="keyword">if</span> (controlSize)</span><br><span class="line">            &#123;</span><br><span class="line">                SetChildAlongAxisWithScale(child, axis, pos, childSize, scaleFactor);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">float</span> offsetInCell = (childSize - child.sizeDelta[axis]) * alignmentOnAxis;</span><br><span class="line">                SetChildAlongAxisWithScale(child, axis, pos + offsetInCell, scaleFactor);</span><br><span class="line">            &#125;</span><br><span class="line">            pos += childSize * scaleFactor + spacing;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">HorizontalOrVerticalLayoutGroup：继承自LayoutGroup，是HorizontalLayoutGroup和VerticalLayoutGroup的父类，提供了一些HorizontalLayoutGroup和VerticalLayoutGroup通用的方法。</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——LayoutGroup</title>
    <link href="https://azzurebubble.github.io/posts/51e1a8f9.html"/>
    <id>https://azzurebubble.github.io/posts/51e1a8f9.html</id>
    <published>2024-07-20T07:32:34.000Z</published>
    <updated>2024-07-20T09:05:24.053Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>LayoutGroup：LayoutGroup是控制子布局对象组件的基类，实现了ILayoutElement和ILayoutGroup接口，继承自UIBehaviour，说明它既是一个布局元素也是一个布局控制器，HorizontalLayoutGroup、VerticalLayoutGroup、GridLayoutGroup都继承或间接继承了此类。</p></blockquote><h4 id="源码解析">源码解析</h4><h5 id="特性">特性</h5><blockquote><p>[DisallowMultipleComponent]：不允许组件对象挂载重复的这个脚本。</p><p>[ExecuteAlways]：确保脚本在编辑器和游戏运行时都能被执行。</p><p>[RequireComponent(typeof(RectTransform))]：确保组件对象挂载了RectTransform组件。</p></blockquote><h5 id="内部实现">内部实现</h5><blockquote><p>m_Padding：可以在Unity的Inspector窗口中直观的调整和配置这个矩形区域的边距偏移量，而无需通过代码进行硬编码。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RectOffset 类型用于定义矩形区域的偏移量。它通常用于 UI 布局中，例如在实现边距（padding）或者边框（border）时非常有用。</span></span><br><span class="line"><span class="keyword">protected</span> RectOffset m_Padding = <span class="keyword">new</span> RectOffset();</span><br><span class="line"><span class="comment">// 控制子布局元素周围的边距偏移量。</span></span><br><span class="line"><span class="keyword">public</span> RectOffset padding &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_Padding; &#125; <span class="keyword">set</span> &#123; SetProperty(<span class="keyword">ref</span> m_Padding, <span class="keyword">value</span>);</span><br></pre></td></tr></table></figure><blockquote><p>SetProperty：帮助器方法，用于在给定属性发生更改时设置该属性。</p><p>这是类似MVVM模式中的使用方法</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">SetProperty</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">ref</span> T currentValue, T newValue</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((currentValue == <span class="literal">null</span> &amp;&amp; newValue == <span class="literal">null</span>) || (currentValue != <span class="literal">null</span> &amp;&amp; currentValue.Equals(newValue)))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    currentValue = newValue;</span><br><span class="line">    SetDirty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetDirty：标记LayoutGroup为Dirty，标记当前对象的布局是否需要重新构建，如果是失活状态将不会被标记。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">SetDirty</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 失活状态则不标记</span></span><br><span class="line">    <span class="keyword">if</span> (!IsActive())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前不在进行布局重建中则通过LayoutRebuilder.MarkLayoutForRebuild来标记当前对象的布局需要重新构建</span></span><br><span class="line">    <span class="keyword">if</span> (!CanvasUpdateRegistry.IsRebuildingLayout())</span><br><span class="line">        LayoutRebuilder.MarkLayoutForRebuild(rectTransform);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则启动一个协程DelayedSetDirty，延迟标记此对象布局需要重新构建</span></span><br><span class="line">        StartCoroutine(DelayedSetDirty(rectTransform));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>协程DelayedSetDirty:等待一帧之后再通过LayoutRebuilder.MarkLayoutForRebuild来标记当前对象的布局需要重新构建。可以使用LayoutRebuilder.ForceRebuildLayoutImmediate(rectTransform)方法强制更新布局。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">DelayedSetDirty</span>(<span class="params">RectTransform rectTransform</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    LayoutRebuilder.MarkLayoutForRebuild(rectTransform);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>子布局元素的对齐方式</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">protected</span> TextAnchor m_ChildAlignment = TextAnchor.UpperLeft;</span><br><span class="line"><span class="comment">// 布局组中子布局元素的对齐方式。默认是左上角对齐。</span></span><br><span class="line"><span class="keyword">public</span> TextAnchor childAlignment &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_ChildAlignment; &#125; <span class="keyword">set</span> &#123; SetProperty(<span class="keyword">ref</span> m_ChildAlignment, <span class="keyword">value</span>); &#125; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>获取此布局元素的RectTransform组件</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">System.NonSerialized</span>] <span class="keyword">private</span> RectTransform m_Rect;</span><br><span class="line"><span class="keyword">protected</span> RectTransform rectTransform</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Rect == <span class="literal">null</span>)</span><br><span class="line">            m_Rect = GetComponent&lt;RectTransform&gt;();</span><br><span class="line">        <span class="keyword">return</span> m_Rect;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>存储布局组中所有的子布局元素</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">System.NonSerialized</span>] <span class="keyword">private</span> List&lt;RectTransform&gt; m_RectChildren = <span class="keyword">new</span> List&lt;RectTransform&gt;();</span><br><span class="line"><span class="keyword">protected</span> List&lt;RectTransform&gt; rectChildren &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_RectChildren; &#125; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>一些其他属性和字段</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DrivenRectTransformTracker 是 Unity 提供的一个用于跟踪 RectTransform 尺寸和位置的工具类。确保布局可以在尺寸或位置变化时得到更新。</span></span><br><span class="line"><span class="keyword">protected</span> DrivenRectTransformTracker m_Tracker;</span><br><span class="line"><span class="comment">// m_TotalMinSize 用来记录当前布局所需的最小尺寸。初始值设为 Vector2.zero，即没有最小尺寸要求。</span></span><br><span class="line"><span class="keyword">private</span> Vector2 m_TotalMinSize = Vector2.zero;</span><br><span class="line"><span class="comment">// m_TotalPreferredSize 用来记录当前布局所需的首选尺寸。初始为 Vector2.zero，即没有首选尺寸要求。</span></span><br><span class="line"><span class="keyword">private</span> Vector2 m_TotalPreferredSize = Vector2.zero;</span><br><span class="line"><span class="comment">// m_TotalFlexibleSize 用来记录当前布局所需的灵活尺寸（即可变尺寸）。初始值设为 Vector2.zero，表示没有灵活尺寸的要求。</span></span><br><span class="line"><span class="keyword">private</span> Vector2 m_TotalFlexibleSize = Vector2.zero;</span><br></pre></td></tr></table></figure><blockquote><p>CalculateLayoutInputHorizontal：实现ILayoutElement中的接口，子类可重写</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CalculateLayoutInputHorizontal</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 清空当前子布局元素容器</span></span><br><span class="line">    m_RectChildren.Clear();</span><br><span class="line">    <span class="comment">// 使用对象池获取一个临时的ListPool&lt;Component&gt;容器</span></span><br><span class="line">    <span class="keyword">var</span> toIgnoreList = ListPool&lt;Component&gt;.Get();</span><br><span class="line">    <span class="comment">// 过滤不参与布局的子布局元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; rectTransform.childCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> rect = rectTransform.GetChild(i) <span class="keyword">as</span> RectTransform;</span><br><span class="line">        <span class="comment">// 没有RectTransform组件和在Hierarchy中没有被激活则跳过</span></span><br><span class="line">        <span class="keyword">if</span> (rect == <span class="literal">null</span> || !rect.gameObject.activeInHierarchy)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取附加在子布局元素组件的所有ILayoutIgnorer组件对象</span></span><br><span class="line">        rect.GetComponents(<span class="keyword">typeof</span>(ILayoutIgnorer), toIgnoreList);</span><br><span class="line"><span class="comment">// 如果为空，则代表需要参与布局</span></span><br><span class="line">        <span class="keyword">if</span> (toIgnoreList.Count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_RectChildren.Add(rect);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只要存在一个为false的ILayoutIgnorer组件，则需要参与布局</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; toIgnoreList.Count; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> ignorer = (ILayoutIgnorer)toIgnoreList[j];</span><br><span class="line">            <span class="keyword">if</span> (!ignorer.ignoreLayout)</span><br><span class="line">            &#123;</span><br><span class="line">                m_RectChildren.Add(rect);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放toIgnoreList返回对象池</span></span><br><span class="line">    ListPool&lt;Component&gt;.Release(toIgnoreList);</span><br><span class="line">    <span class="comment">// 清空布局追踪器</span></span><br><span class="line">    m_Tracker.Clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>抽象方法CalculateLayoutInputVertical计算垂直布局输入，子类必须实现</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">CalculateLayoutInputVertical</span>()</span>;</span><br></pre></td></tr></table></figure><blockquote><p>GetTotalMinSize：由子类调用给定轴上布局组的最小大小</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 轴索引。0表示水平，1表示垂直。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="built_in">float</span> <span class="title">GetTotalMinSize</span>(<span class="params"><span class="built_in">int</span> axis</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_TotalMinSize[axis];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GetTotalPreferredSize</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// // 轴索引。0表示水平，1表示垂直。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="built_in">float</span> <span class="title">GetTotalPreferredSize</span>(<span class="params"><span class="built_in">int</span> axis</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_TotalPreferredSize[axis];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GetTotalFlexibleSize：由子类调用给定轴上布局组的灵活大小。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// // 轴索引。0表示水平，1表示垂直。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="built_in">float</span> <span class="title">GetTotalFlexibleSize</span>(<span class="params"><span class="built_in">int</span> axis</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_TotalFlexibleSize[axis];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ILayoutController中的接口，抽象方法，子类必须实现的回调</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">SetLayoutHorizontal</span>()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">SetLayoutVertical</span>()</span>;</span><br></pre></td></tr></table></figure><blockquote><p>构造方法</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">LayoutGroup</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_Padding == <span class="literal">null</span>)</span><br><span class="line">        m_Padding = <span class="keyword">new</span> RectOffset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>生命周期OnEnable：启用时，标记为需要进行布局重建</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">base</span>.OnEnable();</span><br><span class="line">    SetDirty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>生命周期OnDisable：失活时，清空布局追踪器，强制更新布局</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    m_Tracker.Clear();</span><br><span class="line">    LayoutRebuilder.MarkLayoutForRebuild(rectTransform);</span><br><span class="line">    <span class="keyword">base</span>.OnDisable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>OnDidApplyAnimationProperties：当动画属性改变时，标记为需要进行布局重建</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnDidApplyAnimationProperties</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">SetDirty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>OnRectTransformDimensionsChange：当动画属性改变时，标记为需要进行布局重建</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnDidApplyAnimationProperties</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">SetDirty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GetStartOffset：根据给定轴和对齐方式计算第一个子布局元素起始偏移坐标，由子类调用。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 轴索引。0表示水平，1表示垂直</span></span><br><span class="line"><span class="comment">// 所有布局元素在给定轴上所需的总空间，包括间距和不包括填充。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="built_in">float</span> <span class="title">GetStartOffset</span>(<span class="params"><span class="built_in">int</span> axis, <span class="built_in">float</span> requiredSpaceWithoutPadding</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 计算实际需要的空间大小。它等于 requiredSpaceWithoutPadding 加上轴向上的填充值，根据 axis 的值来决定使用水平填充或垂直填充。</span></span><br><span class="line">    <span class="built_in">float</span> requiredSpace = requiredSpaceWithoutPadding + (axis == <span class="number">0</span> ? padding.horizontal : padding.vertical);</span><br><span class="line">    <span class="comment">// 获取当前轴上可用的空间大小，通过查询 rectTransform.rect.size[axis] 得到。</span></span><br><span class="line">    <span class="built_in">float</span> availableSpace = rectTransform.rect.size[axis];</span><br><span class="line">    <span class="comment">// 计算剩余的空间大小，即 availableSpace 减去 requiredSpace。</span></span><br><span class="line">    <span class="built_in">float</span> surplusSpace = availableSpace - requiredSpace;</span><br><span class="line">    <span class="comment">// 调用 GetAlignmentOnAxis(axis) 方法，获取在当前轴上的对齐方式或比例因子。</span></span><br><span class="line">    <span class="built_in">float</span> alignmentOnAxis = GetAlignmentOnAxis(axis);</span><br><span class="line">    <span class="comment">// 如果 axis 是 0（水平轴），则返回水平填充的左边距 padding.left 加上剩余空间乘以轴向的对齐方式。</span></span><br><span class="line"><span class="comment">// 如果 axis 是 1（垂直轴），则返回垂直填充的顶边距 padding.top 加上剩余空间乘以轴向的对齐方式。</span></span><br><span class="line">    <span class="keyword">return</span> (axis == <span class="number">0</span> ? padding.left : padding.top) + surplusSpace * alignmentOnAxis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GetAlignmentOnAxis：以分数形式返回指定轴上的对齐方式，其中0为左/上，0.5为中，1为右/下。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0表示水平，1表示垂直</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="built_in">float</span> <span class="title">GetAlignmentOnAxis</span>(<span class="params"><span class="built_in">int</span> axis</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (axis == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 水平轴：子布局元素的对齐方式进行模3运算，得到一个范围在0~2之间的整数，这个值乘以0.5f,得到一个在0.0f~1.0f之间的浮点数作为水平对齐的比例因子</span></span><br><span class="line">        <span class="keyword">return</span> ((<span class="built_in">int</span>)childAlignment % <span class="number">3</span>) * <span class="number">0.5f</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 垂直轴：子布局元素的对齐方式进行除3运算，得到一个范围在0~2之间的整数，这个值乘以0.5f,得到一个在0.0f~1.0f之间的浮点数作为垂直对齐的比例因子</span></span><br><span class="line">        <span class="keyword">return</span> ((<span class="built_in">int</span>)childAlignment / <span class="number">3</span>) * <span class="number">0.5f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetLayoutInputForAxis：用于设置给定轴的计算布局属性。由子类调用。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0表示水平，1表示垂直。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">SetLayoutInputForAxis</span>(<span class="params"><span class="built_in">float</span> totalMin, <span class="built_in">float</span> totalPreferred, <span class="built_in">float</span> totalFlexible, <span class="built_in">int</span> axis</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    m_TotalMinSize[axis] = totalMin;</span><br><span class="line">    m_TotalPreferredSize[axis] = totalPreferred;</span><br><span class="line">    m_TotalFlexibleSize[axis] = totalFlexible;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetChildAlongAxis：设置子布局元素沿给定轴的位置和大小。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0表示水平，1表示垂直。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">SetChildAlongAxis</span>(<span class="params">RectTransform rect, <span class="built_in">int</span> axis, <span class="built_in">float</span> pos</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rect == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    SetChildAlongAxisWithScale(rect, axis, pos, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetChildAlongAxisWithScale：设置子布局元素沿给定轴的位置和大小。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0表示水平，1表示垂直。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">SetChildAlongAxisWithScale</span>(<span class="params">RectTransform rect, <span class="built_in">int</span> axis, <span class="built_in">float</span> pos, <span class="built_in">float</span> scaleFactor</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rect == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 跟踪锚点和锚定位置（Anchors 和 AnchoredPositionX 或 AnchoredPositionY）的变化</span></span><br><span class="line">    m_Tracker.Add(<span class="keyword">this</span>, rect,</span><br><span class="line">        DrivenTransformProperties.Anchors |</span><br><span class="line">        (axis == <span class="number">0</span> ? DrivenTransformProperties.AnchoredPositionX : DrivenTransformProperties.AnchoredPositionY));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内联rect.SetInsetAndSizeFromParentEdge(…)和重构代码，以乘以所需的大小scaleFactor。</span></span><br><span class="line"><span class="comment">// sizeDelta必须保持不变，但位置计算中使用的大小必须通过scaleFactor进行缩放。</span></span><br><span class="line"><span class="comment">// 设置子元素的 anchorMin 和 anchorMax 为 Vector2.up，即完全沿父元素的顶部边缘对齐。</span></span><br><span class="line">    rect.anchorMin = Vector2.up;</span><br><span class="line">    rect.anchorMax = Vector2.up;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于水平轴（axis == 0）：计算公式为 pos + rect.sizeDelta[axis] * rect.pivot[axis] * scaleFactor。这将根据位置 pos、子元素的尺寸 rect.sizeDelta[axis]、子元素的中心点 rect.pivot[axis] 和缩放因子 scaleFactor 设置子元素的位置。</span></span><br><span class="line">    <span class="comment">// 对于垂直轴（axis == 1）：计算公式为 -pos - rect.sizeDelta[axis] * (1f - rect.pivot[axis]) * scaleFactor。这同样根据位置 pos、子元素的尺寸 rect.sizeDelta[axis]、子元素的中心点 rect.pivot[axis] 和缩放因子 scaleFactor 设置子元素的位置。</span></span><br><span class="line">    Vector2 anchoredPosition = rect.anchoredPosition;</span><br><span class="line">    anchoredPosition[axis] = (axis == <span class="number">0</span>) ? (pos + rect.sizeDelta[axis] * rect.pivot[axis] * scaleFactor) : (-pos - rect.sizeDelta[axis] * (<span class="number">1f</span> - rect.pivot[axis]) * scaleFactor);</span><br><span class="line">    <span class="comment">// 将计算得到的位置应用到子元素的 anchoredPosition 上，确保子元素按预期位置放置</span></span><br><span class="line">    rect.anchoredPosition = anchoredPosition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetChildAlongAxis：上面方法的重载，多了一个参数size，子布局元素的尺寸大小</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">SetChildAlongAxis</span>(<span class="params">RectTransform rect, <span class="built_in">int</span> axis, <span class="built_in">float</span> pos, <span class="built_in">float</span> size</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rect == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    SetChildAlongAxisWithScale(rect, axis, pos, size, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetChildAlongAxisWithScale：上面方法的重载，多了一个参数size，子布局元素的尺寸大小</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">SetChildAlongAxisWithScale</span>(<span class="params">RectTransform rect, <span class="built_in">int</span> axis, <span class="built_in">float</span> pos, <span class="built_in">float</span> size, <span class="built_in">float</span> scaleFactor</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rect == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跟踪锚点和锚定位置的变化，以及根据轴的不同追踪 AnchoredPositionX 或 AnchoredPositionY 和对应的 SizeDeltaX 或 SizeDeltaY。</span></span><br><span class="line">    m_Tracker.Add(<span class="keyword">this</span>, rect,</span><br><span class="line">        DrivenTransformProperties.Anchors |</span><br><span class="line">        (axis == <span class="number">0</span> ?</span><br><span class="line">            (DrivenTransformProperties.AnchoredPositionX | DrivenTransformProperties.SizeDeltaX) :</span><br><span class="line">            (DrivenTransformProperties.AnchoredPositionY | DrivenTransformProperties.SizeDeltaY)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置子元素的 anchorMin 和 anchorMax 为 Vector2.up，即完全沿父元素的顶部边缘对齐</span></span><br><span class="line">    rect.anchorMin = Vector2.up;</span><br><span class="line">    rect.anchorMax = Vector2.up;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新子元素的 sizeDelta，将指定轴上的尺寸设置为传入的 size 值，确保子元素在该轴上具有正确的大小</span></span><br><span class="line">    Vector2 sizeDelta = rect.sizeDelta;</span><br><span class="line">    sizeDelta[axis] = size;</span><br><span class="line">    rect.sizeDelta = sizeDelta;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于水平轴（axis == 0）：计算公式为 pos + size * rect.pivot[axis] * scaleFactor。这将根据位置 pos、子元素的尺寸 size、子元素的中心点 rect.pivot[axis] 和缩放因子 scaleFactor 设置子元素的位置。</span></span><br><span class="line">    <span class="comment">// 对于垂直轴（axis == 1）：计算公式为 -pos - size * (1f - rect.pivot[axis]) * scaleFactor。这同样根据位置 pos、子元素的尺寸 size、子元素的中心点 rect.pivot[axis] 和缩放因子 scaleFactor 设置子元素的位置。</span></span><br><span class="line">    Vector2 anchoredPosition = rect.anchoredPosition;</span><br><span class="line">    anchoredPosition[axis] = (axis == <span class="number">0</span>) ? (pos + size * rect.pivot[axis] * scaleFactor) : (-pos - size * (<span class="number">1f</span> - rect.pivot[axis]) * scaleFactor);</span><br><span class="line">    <span class="comment">// 将计算得到的位置应用到子元素的 anchoredPosition 上，确保子元素按预期位置放置</span></span><br><span class="line">    rect.anchoredPosition = anchoredPosition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>isRootLayoutGroup：判断当前对象是否是布局组的根布局对象组件。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> isRootLayoutGroup</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        Transform parent = transform.parent;</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> transform.parent.GetComponent(<span class="keyword">typeof</span>(ILayoutGroup)) == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>OnRectTransformDimensionsChange：如果当前对象是根布局对象，且RectTransform发生了变化，则标记为需要进行布局重建</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnRectTransformDimensionsChange</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">base</span>.OnRectTransformDimensionsChange();</span><br><span class="line">    <span class="keyword">if</span> (isRootLayoutGroup)</span><br><span class="line">        SetDirty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>OnTransformChildrenChanged：子布局元素如果的Transform如果发生改变则标记为需要进行布局重建</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnTransformChildrenChanged</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    SetDirty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在编辑器模式下，每次对该组件的属性进行修改并保存时自动调用OnValidate方法，标记为需要进行布局重建</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnValidate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        SetDirty();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">LayoutGroup是控制子布局对象组件的基类，实现了ILayoutElement和ILayoutGroup接口，说明它既是一个布局元素也是一个布局控制器，HorizontalLayoutGroup、VerticalLayoutGroup、GridLayoutGroup都继承或间接继承了此类。</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——ILayoutIgnorer</title>
    <link href="https://azzurebubble.github.io/posts/4c1d55d0.html"/>
    <id>https://azzurebubble.github.io/posts/4c1d55d0.html</id>
    <published>2024-07-20T07:09:24.000Z</published>
    <updated>2024-07-20T09:05:24.054Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ILayoutIgnorer：挂载了实现ILayoutIgnorer接口的组件的对象可以设置不受布局系统控制，例如LayoutElement。<br><font color=red>实现ILayoutIgnorer接口的组件的作用是针对于布局组下的子对象，而不是针对于自身，例如给挂载了ContentSizeFitter组件的对象身上挂载LayoutElement组件并将ignoreLayout设置为true是没有作用的</font></p></blockquote><h4 id="源码解析">源码解析</h4><blockquote><p>ignoreLayout：返回这个布局元素的RecTransform是否应该被布局系统忽略。</p><p><font color=red>注意：需要对象身上所有挂载了ILayoutIgnorer组件中的ignoreLayout都为true的时候才会不受到布局系统控制</font></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> ignoreLayout &#123; <span class="keyword">get</span>; &#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color=red>因为只有在LayoutGroup类中引用了ILayoutIngnorer接口，LayoutGroup类是只作用与子布局元素的，所以实现了ILayoutIgnorer接口的组件的作用是针对于布局组下的子对象，而不是自身。</font></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CalculateLayoutInputHorizontal</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    m_RectChildren.Clear();</span><br><span class="line">    <span class="keyword">var</span> toIgnoreList = ListPool&lt;Component&gt;.Get();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; rectTransform.childCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> rect = rectTransform.GetChild(i) <span class="keyword">as</span> RectTransform;</span><br><span class="line">        <span class="keyword">if</span> (rect == <span class="literal">null</span> || !rect.gameObject.activeInHierarchy)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        rect.GetComponents(<span class="keyword">typeof</span>(ILayoutIgnorer), toIgnoreList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (toIgnoreList.Count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_RectChildren.Add(rect);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; toIgnoreList.Count; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> ignorer = (ILayoutIgnorer)toIgnoreList[j];</span><br><span class="line">            <span class="keyword">if</span> (!ignorer.ignoreLayout)</span><br><span class="line">            &#123;</span><br><span class="line">                m_RectChildren.Add(rect);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ListPool&lt;Component&gt;.Release(toIgnoreList);</span><br><span class="line">    m_Tracker.Clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">挂载了实现ILayoutIgnorer接口的组件对象可以设置不受布局系统控制，例如：LayoutElement</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——ILayoutSelfController</title>
    <link href="https://azzurebubble.github.io/posts/8ae908f0.html"/>
    <id>https://azzurebubble.github.io/posts/8ae908f0.html</id>
    <published>2024-07-20T07:09:15.000Z</published>
    <updated>2024-07-20T09:05:24.052Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ILayoutSelfController：继承自ILayoutController(布局控制器)，挂载了实现ILayoutSelfController的组件的对象被视为一个布局控制器，用于控制自身布局对象，例如：ContentSizeFitter、AspectRatioFitter。</p></blockquote><h4 id="源码解析">源码解析</h4><blockquote><p>继承自ILayoutController，用于驱动自身的RectTransform，调用 <code>ILayoutController.SetLayoutHorizontal</code> 处理水平布局部分，调用 <code>ILayoutController.SetLayoutVertical</code> 处理垂直布局部分。可以改变 RectTransform 的高度、宽度、位置和旋转。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ILayoutSelfController</span> : <span class="title">ILayoutController</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">继承自ILayoutController(布局控制器)，挂载了实现ILayoutSelfController的组件的对象被视为一个布局控制器，用于控制自身布局对象，例如：ContentSizeFitter、AspectRatioFitter。</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——ILayoutGroup</title>
    <link href="https://azzurebubble.github.io/posts/16a94385.html"/>
    <id>https://azzurebubble.github.io/posts/16a94385.html</id>
    <published>2024-07-20T07:09:05.000Z</published>
    <updated>2024-07-20T09:05:24.051Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ILayoutGroup：继承自ILayoutController，挂载了实现ILayoutGroup的组件的对象被视为一个布局控制器，用于控制子布局对象，驱动它的子元素的RectTransforms，例如：HorizontalLayoutGroup、VerticalLayoutGroup、GridLayoutGroup。</p></blockquote><h4 id="源码解析">源码解析</h4><blockquote><p>继承自ILayoutController</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ILayoutGroup</span> : <span class="title">ILayoutController</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">继承自ILayoutController，挂载了实现ILayoutGroup的组件的对象被视为一个布局控制器，用于控制子布局对象，例如：HorizontalLayoutGroup、VerticalLayoutGroup、GridLayoutGroup。</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——ILayoutController</title>
    <link href="https://azzurebubble.github.io/posts/21b56f8.html"/>
    <id>https://azzurebubble.github.io/posts/21b56f8.html</id>
    <published>2024-07-20T07:08:25.000Z</published>
    <updated>2024-07-20T09:05:24.048Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ILayoutController：挂载了实现ILayoutController的组件的对象被视为一个布局控制器，布局控制器用于设置布局。布局控制器可分为两种：控制自身和控制子布局元素</p></blockquote><h4 id="源码解析">源码解析</h4><blockquote><p>SetLayoutHorizontal：由自动布局系统调用的回调函数，先处理布局的水平方面</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetLayoutHorizontal</span>()</span>;</span><br></pre></td></tr></table></figure><blockquote><p>SetLayoutVertical：由自动布局系统调用的回调函数，先处理布局的垂直方面</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetLayoutVertical</span>()</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">挂载了实现ILayoutController的组件的对象被视为一个布局控制器，布局控制器用于设置布局。布局控制器可分为两种：控制自身和控制子布局元素。</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——ILayoutElement</title>
    <link href="https://azzurebubble.github.io/posts/2f5dfff6.html"/>
    <id>https://azzurebubble.github.io/posts/2f5dfff6.html</id>
    <published>2024-07-20T06:53:50.000Z</published>
    <updated>2024-07-20T09:05:24.046Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ILayoutElement：挂载了实现ILayoutElement接口的组件的对象被视为一个布局元素，<font color=red>布局元素不直接设置布局，只计算自身属性，设置布局由布局控制器设置</font></p></blockquote><h4 id="源码解析">源码解析</h4><blockquote><p>CalculateLayoutInputHorizontal：先计算水平布局的属性值，当调用这个方法时，子节点已经有了最新的水平布局输入。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CalculateLayoutInputHorizontal</span>()</span>;</span><br></pre></td></tr></table></figure><blockquote><p>CalculateLayoutInputVertical：后计算垂直布局的属性值，当调用这个方法时，子节点已经有了最新的垂直布局输入。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CalculateLayoutInputVertical</span>()</span>;</span><br></pre></td></tr></table></figure><blockquote><p>minWidth：此布局元素属性分配最小的宽度</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> minWidth &#123; <span class="keyword">get</span>; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>preferredWidth：如果有足够的空间，应该分配这个布局元素的首选宽度，preferredWidth可以设置为-1来移除大小</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> preferredWidth &#123; <span class="keyword">get</span>; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>flexibleWidth：布局元素在有额外可用空间时应该分配的额外相对宽度</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> flexibleWidth &#123; <span class="keyword">get</span>; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>minHeight：此布局元素属性分配最小的高度</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> minHeight &#123; <span class="keyword">get</span>; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>preferredHeight：如果有足够的空间，应该分配这个布局元素的首选高度，preferredHeight可以设置为-1来移除大小</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> preferredHeight &#123; <span class="keyword">get</span>; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>flexibleHeight：布局元素在有额外可用空间时应该分配的额外相对高度</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> flexibleHeight &#123; <span class="keyword">get</span>; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>layoutPriority：获取该组件的布局优先级，当一个游戏对象上的多个组件实现了ILayoutElement接口时，确定到底由哪个组件提供布局属性，值越大优先级越高，小于0的值将被忽略。通过这种方式，组件可以只重写选中的属性，让剩余的值为-1或其他小于零的值。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> layoutPriority &#123; <span class="keyword">get</span>; &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">挂载了实现ILayoutElement的组件的对象被视为一个布局元素，布局元素不直接设置布局，只计算自身属性，设置布局由布局控制器设置</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——LayoutRebuilder</title>
    <link href="https://azzurebubble.github.io/posts/52e926ac.html"/>
    <id>https://azzurebubble.github.io/posts/52e926ac.html</id>
    <published>2024-07-18T14:43:45.000Z</published>
    <updated>2024-08-14T16:14:58.954Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>LayoutRebuilder：用于管理CanvasElement布局重建的包装类，主要负责布局的刷新(UI对象位置和大小的刷新)。</p></blockquote><h4 id="源码解析">源码解析</h4><blockquote><p>字段</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RectTransform m_ToRebuild;</span><br><span class="line"><span class="comment">// 从变换中缓存哈希值有几个原因:</span></span><br><span class="line"><span class="comment">//  - 这是一个ValueType (struct)， . net从ValueType字段计算Hash值。</span></span><br><span class="line"><span class="comment">//  - 字典的键应该有一个常量哈希值。</span></span><br><span class="line"><span class="comment">//  - 这是可能的转换得到null从本地端。</span></span><br><span class="line"><span class="comment">// 我们将这个结构体与IndexedSet容器一起使用，IndexedSet容器使用字典作为实现的一部分</span></span><br><span class="line"><span class="comment">// 这个结构体被用作字典的键，所以我们需要保证一个恒定的哈希值。</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> m_CachedHashFromTransform;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前的 RectTransform</span></span><br><span class="line"><span class="keyword">public</span> Transform transform &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_ToRebuild; &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前的 RectTransform 是否被销毁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsDestroyed</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_ToRebuild == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态对象池 管理 LayoutRebuilder 对象</span></span><br><span class="line"><span class="keyword">static</span> ObjectPool&lt;LayoutRebuilder&gt; s_Rebuilders = <span class="keyword">new</span> ObjectPool&lt;LayoutRebuilder&gt;(<span class="literal">null</span>, x =&gt; x.Clear());</span><br></pre></td></tr></table></figure><blockquote><p>Initialize：初始化 m_ToRebuild 和 m_CachedHashFromTransform，确保哈希值保持不变</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Initialize</span>(<span class="params">RectTransform controller</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    m_ToRebuild = controller;</span><br><span class="line">    m_CachedHashFromTransform = controller.GetHashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Clear：清理缓存</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Clear</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    m_ToRebuild = <span class="literal">null</span>;</span><br><span class="line">    m_CachedHashFromTransform = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>LayoutRebuilder：静态构造函数，第一次访问该类时被调用，不接受参数</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RectTransform.reapplyDrivenProperties 是一个静态事件，定义在 RectTransform 类中。这个事件在 RectTransform 的属性被重新应用时触发。例如，当 RectTransform 的尺寸或位置受到驱动并需要更新时，该事件会被触发。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LayoutRebuilder</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    RectTransform.reapplyDrivenProperties += ReapplyDrivenProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ReapplyDrivenProperties：静态构造函数，第一次访问该类时被调用，不接受参数</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 ReapplyDrivenProperties 方法内部，调用了 MarkLayoutForRebuild(driven)。这个方法的目的是标记指定的 RectTransform 以便在下次布局更新时进行重新构建。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReapplyDrivenProperties</span>(<span class="params">RectTransform driven</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MarkLayoutForRebuild(driven);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ReapplyDrivenProperties：静态构造函数，第一次访问该类时被调用，不接受参数</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 ReapplyDrivenProperties 方法内部，调用了 MarkLayoutForRebuild(driven)。这个方法的目的是标记指定的 RectTransform 以便在下次布局更新时进行重新构建。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReapplyDrivenProperties</span>(<span class="params">RectTransform driven</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MarkLayoutForRebuild(driven);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>MarkLayoutForRebuild：将给定的RectTransform标记为需要在下一次布局过程中重新计算其布局。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MarkLayoutForRebuild</span>(<span class="params">RectTransform rect</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rect == <span class="literal">null</span> || rect.gameObject == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> comps = ListPool&lt;Component&gt;.Get();</span><br><span class="line">    <span class="comment">// 用于标记当前处理的 RectTransform 是否具有有效的布局组。</span></span><br><span class="line">    <span class="built_in">bool</span> validLayoutGroup = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 是当前 RectTransform，将用来追踪有效的布局根。</span></span><br><span class="line">    RectTransform layoutRoot = rect;</span><br><span class="line">    <span class="comment">//  是当前 RectTransform 的父级，类型转换为 RectTransform。</span></span><br><span class="line">    <span class="keyword">var</span> parent = layoutRoot.parent <span class="keyword">as</span> RectTransform;</span><br><span class="line">    <span class="comment">// 持续检查父级的 RectTransform 直到找到有效的布局组或到达根节点</span></span><br><span class="line">    <span class="keyword">while</span> (validLayoutGroup &amp;&amp; !(parent == <span class="literal">null</span> || parent.gameObject == <span class="literal">null</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        validLayoutGroup = <span class="literal">false</span>;</span><br><span class="line">        parent.GetComponents(<span class="keyword">typeof</span>(ILayoutGroup), comps);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; comps.Count; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> cur = comps[i];</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">null</span> &amp;&amp; cur <span class="keyword">is</span> Behaviour &amp;&amp; ((Behaviour)cur).isActiveAndEnabled)</span><br><span class="line">            &#123;</span><br><span class="line">                validLayoutGroup = <span class="literal">true</span>;</span><br><span class="line">                layoutRoot = parent;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        parent = parent.parent <span class="keyword">as</span> RectTransform;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们知道布局根是有效的，如果它不相同的矩形，</span></span><br><span class="line"><span class="comment">// 上面已经检查过了。但如果它们是一样的，我们还需要检查。</span></span><br><span class="line">    <span class="comment">// 如果当前父级不符合条件，则继续向上检查其上一级父级，直到找到有效的布局组或到达根节点。</span></span><br><span class="line">    <span class="keyword">if</span> (layoutRoot == rect &amp;&amp; !ValidController(layoutRoot, comps))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// // 如果 layoutRoot 没有变化并且 ValidController 返回 false，则表示当前 RectTransform 不需要重新标记为重建。释放组件列表并退出方法。</span></span><br><span class="line">        ListPool&lt;Component&gt;.Release(comps);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 MarkLayoutRootForRebuild 方法，标记 layoutRoot 需要重建布局。</span></span><br><span class="line">    MarkLayoutRootForRebuild(layoutRoot);</span><br><span class="line">    ListPool&lt;Component&gt;.Release(comps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ValidController：检查给定的 <code>RectTransform</code> 是否具有有效的 <code>ILayoutController</code> 组件</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">ValidController</span>(<span class="params">RectTransform layoutRoot, List&lt;Component&gt; comps</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (layoutRoot == <span class="literal">null</span> || layoutRoot.gameObject == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 comps 列表，检查每个组件是否是 Behaviour 类型且处于启用状态（isActiveAndEnabled 为 true）。</span></span><br><span class="line">    layoutRoot.GetComponents(<span class="keyword">typeof</span>(ILayoutController), comps);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; comps.Count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> cur = comps[i];</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="literal">null</span> &amp;&amp; cur <span class="keyword">is</span> Behaviour &amp;&amp; ((Behaviour)cur).isActiveAndEnabled)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>StripDisabledBehavioursFromList：从给定的组件列表中移除所有是Behaviour类型并且未启用的组件。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">StripDisabledBehavioursFromList</span>(<span class="params">List&lt;Component&gt; components</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    components.RemoveAll(e =&gt; e <span class="keyword">is</span> Behaviour &amp;&amp; !((Behaviour)e).isActiveAndEnabled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ForceRebuildLayoutImmediate：强制立即重建受计算影响的布局元素和子布局元素。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强制立即重建受计算影响的布局元素和子布局元素。</span></span><br><span class="line"><span class="comment">// 正常使用的布局系统不应该使用这个方法。相反，应该使用MarkLayoutForRebuild，它会在下一次布局传递时触发延迟的布局重建。延迟的重新构建以正确的顺序自动处理整个布局层次结构中的对象，并防止对相同布局元素进行多次重新计算。</span></span><br><span class="line"><span class="comment">// 但是，对于特殊的布局计算需求，可以使用::ref:: forcerebuildlayoutimate来立即解析子树的布局。这甚至可以从内部布局计算方法，如ILayoutController完成。SetLayoutHorizontal orILayoutController.SetLayoutVertical。使用应该限制在多个布局传递不可避免的情况下，尽管在性能上有额外的成本。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ForceRebuildLayoutImmediate</span>(<span class="params">RectTransform layoutRoot</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> rebuilder = s_Rebuilders.Get();</span><br><span class="line">    rebuilder.Initialize(layoutRoot);</span><br><span class="line">    rebuilder.Rebuild(CanvasUpdate.Layout);</span><br><span class="line">    s_Rebuilders.Release(rebuilder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Rebuild：在CanvasUpdateRegistry类中给委托Canvas.willRenderCanvases注册了PerformUpdate方法，PerformUpdate会在CanvasRender渲染之前会遍历布局和图像重建序列调用每个元素的Rebuild方法(执行布局重建操作前会先将所有待重建对象的父物体数量进行升序排序，这样可以保证是从下到上进行布局重建，避免布局混乱)，这里的Rebuild就是布局更新操作的具体实现，先进行水平布局的计算和设置再进行竖直布局的计算和设置。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Rebuild</span>(<span class="params">CanvasUpdate executing</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (executing)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> CanvasUpdate.Layout:</span><br><span class="line">            <span class="comment">// 不幸的是，我们将对树执行相同的GetComponents查询2次，</span></span><br><span class="line">            <span class="comment">// 但是每个树必须在进入下一个动作之前被完全迭代，</span></span><br><span class="line">            <span class="comment">// 所以重用结果需要将结果存储在Dictionary或类似的地方，</span></span><br><span class="line">            <span class="comment">// 这可能比多次执行GetComponents的开销更大。</span></span><br><span class="line">            PerformLayoutCalculation(m_ToRebuild, e =&gt; (e <span class="keyword">as</span> ILayoutElement).CalculateLayoutInputHorizontal());</span><br><span class="line">            PerformLayoutControl(m_ToRebuild, e =&gt; (e <span class="keyword">as</span> ILayoutController).SetLayoutHorizontal());</span><br><span class="line">            PerformLayoutCalculation(m_ToRebuild, e =&gt; (e <span class="keyword">as</span> ILayoutElement).CalculateLayoutInputVertical());</span><br><span class="line">            PerformLayoutControl(m_ToRebuild, e =&gt; (e <span class="keyword">as</span> ILayoutController).SetLayoutVertical());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PerformLayoutControl：<strong>从上到下</strong>遍历实现了ILayoutController接口的组件的对象，先处理实现了ILayoutController接口的组件的对象，接着处理实现了ILayoutGroup接口的组件的对象，最后迭代遍历当前对象的子物体。从上到下设置是因为子对象的布局依赖于父对象的布局</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确保父节点的布局控制器能够首先设置并影响其子节点的布局</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PerformLayoutControl</span>(<span class="params">RectTransform rect, UnityAction&lt;Component&gt; action</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rect == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> components = ListPool&lt;Component&gt;.Get();</span><br><span class="line">    rect.GetComponents(<span class="keyword">typeof</span>(ILayoutController), components);</span><br><span class="line">    StripDisabledBehavioursFromList(components);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果这个rect上没有控制器，我们可以跳过这整个子树</span></span><br><span class="line"><span class="comment">//我们也不需要考虑子树更深处的子节点上的控制器，</span></span><br><span class="line"><span class="comment">//因为它们将成为自己的根。</span></span><br><span class="line">    <span class="keyword">if</span> (components.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//布局控件需要自顶向下执行，父控件在子控件之前完成;</span></span><br><span class="line"><span class="comment">//因为孩子依赖于父母的大小。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//首先调用布局控制器，它们可以改变自己的RectTransform</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; components.Count; i++)</span><br><span class="line">            <span class="keyword">if</span> (components[i] <span class="keyword">is</span> ILayoutSelfController)</span><br><span class="line">                action(components[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//然后调用其余的，比如改变它们的子布局组，考虑它们自己的RectTransform大小。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; components.Count; i++)</span><br><span class="line">            <span class="keyword">if</span> (!(components[i] <span class="keyword">is</span> ILayoutSelfController))</span><br><span class="line">                action(components[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; rect.childCount; i++)</span><br><span class="line">            PerformLayoutControl(rect.GetChild(i) <span class="keyword">as</span> RectTransform, action);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListPool&lt;Component&gt;.Release(components);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PerformLayoutCalculation：递归地<strong>从下到上</strong>遍历实现了ILayoutElement接口的组件的对象，并调用计算布局属性的方法(CalculateLayoutInputHorizontal和CalculateLayoutInputVertical)。从下到上计算是因为父对象的属性依赖于子对象的属性</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算布局大小，依赖于子对象</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PerformLayoutCalculation</span>(<span class="params">RectTransform rect, UnityAction&lt;Component&gt; action</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rect == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> components = ListPool&lt;Component&gt;.Get();</span><br><span class="line">    rect.GetComponents(<span class="keyword">typeof</span>(ILayoutElement), components);</span><br><span class="line">    StripDisabledBehavioursFromList(components);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果这个rect上没有控制器，我们可以跳过这整个子树</span></span><br><span class="line"><span class="comment">//我们也不需要考虑子树更深处的子节点上的控制器，</span></span><br><span class="line"><span class="comment">//因为它们将成为自己的根。</span></span><br><span class="line">    <span class="keyword">if</span> (components.Count &gt; <span class="number">0</span>  || rect.GetComponent(<span class="keyword">typeof</span>(ILayoutGroup)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//布局计算需要自底向上执行，子节点在父节点之前完成;</span></span><br><span class="line"><span class="comment">//因为父节点的计算大小依赖于子节点的大小。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; rect.childCount; i++)</span><br><span class="line">            PerformLayoutCalculation(rect.GetChild(i) <span class="keyword">as</span> RectTransform, action);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; components.Count; i++)</span><br><span class="line">            action(components[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListPool&lt;Component&gt;.Release(components);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>MarkLayoutRootForRebuild：标记一个 <code>RectTransform</code> 对象以便在布局更新时进行重建</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MarkLayoutRootForRebuild</span>(<span class="params">RectTransform controller</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (controller == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> rebuilder = s_Rebuilders.Get();</span><br><span class="line">    rebuilder.Initialize(controller);</span><br><span class="line">    <span class="comment">// 尝试注册到布局重建容器中，如果注册失败就直接释放掉这个对象</span></span><br><span class="line">    <span class="keyword">if</span> (!CanvasUpdateRegistry.TryRegisterCanvasElementForLayoutRebuild(rebuilder))</span><br><span class="line">        s_Rebuilders.Release(rebuilder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>LayoutComplete：布局重建完成时间，释放s_Rebuilders对象池中的当前对象</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LayoutComplete</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    s_Rebuilders.Release(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一些比较简单的方法</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图像更新完成事件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GraphicUpdateComplete</span>()</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得当前进行重建的RectTransform的哈希值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">GetHashCode</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_CachedHashFromTransform;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断两个对象的哈希值是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params"><span class="built_in">object</span> obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> obj.GetHashCode() == GetHashCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ToString 重写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(Layout Rebuilder for) &quot;</span> + m_ToRebuild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">负责布局的刷新(UI对象位置和大小的刷新)</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——CanvasUpdateRegistry</title>
    <link href="https://azzurebubble.github.io/posts/6dcd3730.html"/>
    <id>https://azzurebubble.github.io/posts/6dcd3730.html</id>
    <published>2024-07-18T14:27:22.000Z</published>
    <updated>2024-07-18T14:55:06.910Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>CanvasUpdate：用于描述在Canvas更新过程中可能发生的不同阶段</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> CanvasUpdate</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 布局更新之前调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    Prelayout = <span class="number">0</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 布局更新时调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    Layout = <span class="number">1</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 布局更新之后调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    PostLayout = <span class="number">2</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 渲染之前调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    PreRender = <span class="number">3</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 渲染之前完成后调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    LatePreRender = <span class="number">4</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 表示枚举的范围，边界检测或者迭代</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    MaxUpdateValue = <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ICanvasElement：图像、布局重建接口。几乎所有UI对象都继承自ICanvasElement接口，一个UI对象若要重建都需要继承自ICanvasElement接口。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICanvasElement</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 重构方法，需要在继承类中实现，Graphic和LayoutRebuilder继承了此接口</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;executing&quot;&gt;</span>正在重建的当前的CanvasUpdate阶段<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">Rebuild</span>(<span class="params">CanvasUpdate executing</span>)</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 每个UI都继承自UIBehaviour类，UIBehaviour继承自MonoBehaviour，MonoBehaviour继承自Component类，而Component类实现了transform属性，所以子类可以不再实现这个属性</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     Transform transform &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 布局完成的回调函数</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">LayoutComplete</span>()</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 图像更新完成的回调函数</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">GraphicUpdateComplete</span>()</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 获取UI对象是否销毁</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">     <span class="function"><span class="built_in">bool</span> <span class="title">IsDestroyed</span>()</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>CanvasUpdateRegistry：是一个单例，它监听了Canvas即将渲染的事件，并调用已注册对象的Rebuild、LayoutComplete、GraphicUpdateComplete方法，<font color=red>而其中的Rebuild方法就是每个UI元素的刷新方法。</font></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例获取</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CanvasUpdateRegistry s_Instance;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CanvasUpdateRegistry instance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s_Instance == <span class="literal">null</span>)</span><br><span class="line">            s_Instance = <span class="keyword">new</span> CanvasUpdateRegistry();</span><br><span class="line">        <span class="keyword">return</span> s_Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数：给Canvas的静态事件willRenderCanvases注册一个名为PerformUpdate的方法</span></span><br><span class="line"><span class="comment">// (willRenderCanvases每帧在Canvas渲染前执行)，PerformUpdate中调用了布局和图像的更新</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">CanvasUpdateRegistry</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Canvas.willRenderCanvases += PerformUpdate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个标记是否在进行布局或图像更新的字段</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> m_PerformingLayoutUpdate;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> m_PerformingGraphicUpdate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于在性能分析器中识别和记录Canvas更新过程中的不同阶段的标识符</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span>[] m_CanvasUpdateProfilerStrings = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;CanvasUpdate.Prelayout&quot;</span>, <span class="string">&quot;CanvasUpdate.Layout&quot;</span>, <span class="string">&quot;CanvasUpdate.PostLayout&quot;</span>, <span class="string">&quot;CanvasUpdate.PreRender&quot;</span>, <span class="string">&quot;CanvasUpdate.LatePreRender&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 用于在性能分析器或调试器中标识剪切器注册表中执行裁剪的标识符</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> m_CullingUpdateProfilerString = <span class="string">&quot;ClipperRegistry.Cull&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 布局重建序列和图像重建序列</span></span><br><span class="line"><span class="comment">// 当需要更新布局或图像时，可以调用RegisterCanvasElementForLayoutRebuild和</span></span><br><span class="line"><span class="comment">// RegisterCanvasElementForGraphicRebuild两个方法将对象添加到对应的重建序列中</span></span><br><span class="line"><span class="comment">// PerformUpdate方法会调用Rebuild方法对这两个序列中中的对象进行更新操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> IndexedSet&lt;ICanvasElement&gt; m_LayoutRebuildQueue = <span class="keyword">new</span> IndexedSet&lt;ICanvasElement&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> IndexedSet&lt;ICanvasElement&gt; m_GraphicRebuildQueue = <span class="keyword">new</span> IndexedSet&lt;ICanvasElement&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查指定的Canvas元素是否是Unity的Object，是否可以进行有效更新</span></span><br><span class="line"><span class="comment">// Object是Unity所有对象的基类，object是C#中所有对象的基类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">ObjectValidForUpdate</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> valid = element != <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> isUnityObject = element <span class="keyword">is</span> Object;</span><br><span class="line">    <span class="keyword">if</span> (isUnityObject)</span><br><span class="line">        valid = (element <span class="keyword">as</span> Object) != <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> valid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理两个队列中的无效元素</span></span><br><span class="line"><span class="comment">// MonoBehaviour对空值相等性重载了==操作符，用于检查他们是否被销毁</span></span><br><span class="line"><span class="comment">// 这段代码中处理的是一个ICanvasElement接口类型的列表，而不是具体的MonoBehaviour类型</span></span><br><span class="line"><span class="comment">// 因此直接使用==操作符不能直接转发到MonoBehaviour，而只是检查接口本身是否为null</span></span><br><span class="line"><span class="comment">// IsDestroyed()方法用于检查元素的后端是否被销毁</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CleanInvalidItems</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> layoutRebuildQueueCount = m_LayoutRebuildQueue.Count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = layoutRebuildQueueCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> item = m_LayoutRebuildQueue[i];</span><br><span class="line">        <span class="comment">// 元素是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (item == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_LayoutRebuildQueue.RemoveAt(i);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 元素是否被销毁</span></span><br><span class="line">        <span class="keyword">if</span> (item.IsDestroyed())</span><br><span class="line">        &#123;</span><br><span class="line">            m_LayoutRebuildQueue.RemoveAt(i);</span><br><span class="line">            item.LayoutComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> graphicRebuildQueueCount = m_GraphicRebuildQueue.Count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = graphicRebuildQueueCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> item = m_GraphicRebuildQueue[i];</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_GraphicRebuildQueue.RemoveAt(i);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (item.IsDestroyed())</span><br><span class="line">        &#123;</span><br><span class="line">            m_GraphicRebuildQueue.RemoveAt(i);</span><br><span class="line">            item.GraphicUpdateComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算指定Transform对象的父级层级数目</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">ParentCount</span>(<span class="params">Transform child</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> parent = child.parent;</span><br><span class="line">    <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (parent != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        parent = parent.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个元素的祖先层级深度，祖先层级深度越深，则排在列表的更后面</span></span><br><span class="line"><span class="comment">// 决定元素的布局和图像重建顺序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">SortLayoutList</span>(<span class="params">ICanvasElement x, ICanvasElement y</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Transform t1 = x.transform;</span><br><span class="line">    Transform t2 = y.transform;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ParentCount(t1) - ParentCount(t2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个Canvas元素注册到布局重建队列中，一个带返回值一个不带返回值方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RegisterCanvasElementForLayoutRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    instance.InternalRegisterCanvasElementForLayoutRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">TryRegisterCanvasElementForLayoutRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> instance.InternalRegisterCanvasElementForLayoutRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">InternalRegisterCanvasElementForLayoutRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断元素是否存在布局重建队列中</span></span><br><span class="line">    <span class="keyword">if</span> (m_LayoutRebuildQueue.Contains(element))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 向布局重建队列中添加元素，确保不会重复添加</span></span><br><span class="line">    <span class="keyword">return</span> m_LayoutRebuildQueue.AddUnique(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个Canvas元素注册到图像重建队列中，一个带返回值一个不带返回值方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RegisterCanvasElementForGraphicRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    instance.InternalRegisterCanvasElementForGraphicRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">TryRegisterCanvasElementForGraphicRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> instance.InternalRegisterCanvasElementForGraphicRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">InternalRegisterCanvasElementForGraphicRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 是否正在进行图像重建更新操作，是的话将不会将元素添加到图像重建队列中</span></span><br><span class="line">    <span class="keyword">if</span> (m_PerformingGraphicUpdate)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="built_in">string</span>.Format(<span class="string">&quot;Trying to add &#123;0&#125; for graphic rebuild while we are already inside a graphic rebuild loop. This is not supported.&quot;</span>, element));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 向图像重建队列中添加元素，确保不会重复添加</span></span><br><span class="line">    <span class="keyword">return</span> m_GraphicRebuildQueue.AddUnique(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从布局和重建的队列中移除指定的Canvas元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnRegisterCanvasElementForRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    instance.InternalUnRegisterCanvasElementForLayoutRebuild(element);</span><br><span class="line">    instance.InternalUnRegisterCanvasElementForGraphicRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InternalUnRegisterCanvasElementForLayoutRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果正在进行布局重建更新操作，将不会移除指定元素</span></span><br><span class="line">    <span class="keyword">if</span> (m_PerformingLayoutUpdate)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="built_in">string</span>.Format(<span class="string">&quot;Trying to remove &#123;0&#125; from rebuild list while we are already inside a rebuild loop. This is not supported.&quot;</span>, element));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 调用元素的布局重建完成函数</span></span><br><span class="line">    element.LayoutComplete();</span><br><span class="line">    <span class="comment">// 从布局重建队列中移除元素</span></span><br><span class="line">    instance.m_LayoutRebuildQueue.Remove(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InternalUnRegisterCanvasElementForGraphicRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果正在进行图像重建更新操作，将不会移除指定元素</span></span><br><span class="line">    <span class="keyword">if</span> (m_PerformingGraphicUpdate)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="built_in">string</span>.Format(<span class="string">&quot;Trying to remove &#123;0&#125; from rebuild list while we are already inside a rebuild loop. This is not supported.&quot;</span>, element));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用元素的图像重建完成函数</span></span><br><span class="line">    element.GraphicUpdateComplete();</span><br><span class="line">    <span class="comment">// 从图像重建队列中移除元素</span></span><br><span class="line">    instance.m_GraphicRebuildQueue.Remove(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从布局和重建的队列中禁用指定的Canvas元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DisableCanvasElementForRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    instance.InternalDisableCanvasElementForLayoutRebuild(element);</span><br><span class="line">    instance.InternalDisableCanvasElementForGraphicRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InternalDisableCanvasElementForLayoutRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果正在进行布局重建更新操作，将不会禁用指定元素</span></span><br><span class="line">    <span class="keyword">if</span> (m_PerformingLayoutUpdate)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="built_in">string</span>.Format(<span class="string">&quot;Trying to remove &#123;0&#125; from rebuild list while we are already inside a rebuild loop. This is not supported.&quot;</span>, element));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 调用元素的布局重建完成函数</span></span><br><span class="line">    element.LayoutComplete();</span><br><span class="line">    <span class="comment">// 禁用指定元素</span></span><br><span class="line">    instance.m_LayoutRebuildQueue.DisableItem(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InternalDisableCanvasElementForGraphicRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果正在进行图像重建更新操作，将不会禁用指定元素</span></span><br><span class="line">    <span class="keyword">if</span> (m_PerformingGraphicUpdate)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="built_in">string</span>.Format(<span class="string">&quot;Trying to remove &#123;0&#125; from rebuild list while we are already inside a rebuild loop. This is not supported.&quot;</span>, element));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用元素的图像重建完成函数</span></span><br><span class="line">    element.GraphicUpdateComplete();</span><br><span class="line">    <span class="comment">// 禁用指定元素</span></span><br><span class="line">    instance.m_GraphicRebuildQueue.DisableItem(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前是否正在计算图形布局</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsRebuildingLayout</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> instance.m_PerformingLayoutUpdate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当前是否正在重建图形</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsRebuildingGraphics</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> instance.m_PerformingGraphicUpdate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接下来着重分析CanvasUpdateRegistry中的PerformUpdate方法的内部实现和执行顺序。<font color=red>可以在Profiler中通过查看标志性函数Canvas.willRenderCanvases的耗时，来了解重建的性能消耗</font></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先定义一个静态只读的比较函数委托</span></span><br><span class="line"><span class="comment">// Comparison&lt;T&gt;是C#已经预定义好的一个用于比较两个类型为T的对象并返回整数的委托</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Comparison&lt;ICanvasElement&gt; s_SortLayoutFunction = SortLayoutList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PerformUpdate</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 用于在代码块开始和结束时记录性能样本，监测布局更新的性能</span></span><br><span class="line">    UISystemProfilerApi.BeginSample(UISystemProfilerApi.SampleType.Layout);</span><br><span class="line">    <span class="comment">// 清理无效的元素或数据</span></span><br><span class="line">    CleanInvalidItems();</span><br><span class="line"><span class="comment">// 标记正在进行布局更新操作</span></span><br><span class="line">    m_PerformingLayoutUpdate = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 对布局重建队列中的元素进行排序</span></span><br><span class="line">    m_LayoutRebuildQueue.Sort(s_SortLayoutFunction);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= (<span class="built_in">int</span>)CanvasUpdate.PostLayout; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 标记每一个元素的性能分析</span></span><br><span class="line">        UnityEngine.Profiling.Profiler.BeginSample(m_CanvasUpdateProfilerStrings[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; m_LayoutRebuildQueue.Count; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> rebuild = m_LayoutRebuildQueue[j];</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 判断元素是否是有效元素</span></span><br><span class="line">                <span class="comment">// 对布局重建序列中的每一个元素进行CanvasUpdate的每个阶段更新</span></span><br><span class="line">                <span class="keyword">if</span> (ObjectValidForUpdate(rebuild))</span><br><span class="line">                    rebuild.Rebuild((CanvasUpdate)i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogException(e, rebuild.transform);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        UnityEngine.Profiling.Profiler.EndSample();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m_LayoutRebuildQueue.Count; ++i)</span><br><span class="line">        <span class="comment">// 调用布局重建完成函数</span></span><br><span class="line">        m_LayoutRebuildQueue[i].LayoutComplete();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空布局重建列表，并修改布局重建标志为false</span></span><br><span class="line">    m_LayoutRebuildQueue.Clear();</span><br><span class="line">    m_PerformingLayoutUpdate = <span class="literal">false</span>;</span><br><span class="line">    UISystemProfilerApi.EndSample(UISystemProfilerApi.SampleType.Layout);</span><br><span class="line">    UISystemProfilerApi.BeginSample(UISystemProfilerApi.SampleType.Render);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now layout is complete do culling...</span></span><br><span class="line">    UnityEngine.Profiling.Profiler.BeginSample(m_CullingUpdateProfilerString);</span><br><span class="line">    <span class="comment">// 执行实际的裁剪操作</span></span><br><span class="line">    ClipperRegistry.instance.Cull();</span><br><span class="line">    UnityEngine.Profiling.Profiler.EndSample();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记正在进行图像更新操作</span></span><br><span class="line">    m_PerformingGraphicUpdate = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = (<span class="built_in">int</span>)CanvasUpdate.PreRender; i &lt; (<span class="built_in">int</span>)CanvasUpdate.MaxUpdateValue; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        UnityEngine.Profiling.Profiler.BeginSample(m_CanvasUpdateProfilerStrings[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; m_GraphicRebuildQueue.Count; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> element = m_GraphicRebuildQueue[k];</span><br><span class="line">                <span class="comment">// 判断元素是否是有效元素</span></span><br><span class="line">                <span class="comment">// 对布局重建序列中的每一个元素进行CanvasUpdate的每个阶段更新</span></span><br><span class="line">                <span class="keyword">if</span> (ObjectValidForUpdate(element))</span><br><span class="line">                    element.Rebuild((CanvasUpdate)i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogException(e, m_GraphicRebuildQueue[k].transform);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        UnityEngine.Profiling.Profiler.EndSample();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m_GraphicRebuildQueue.Count; ++i)</span><br><span class="line">        <span class="comment">// 调用图像重建完成函数</span></span><br><span class="line">        m_GraphicRebuildQueue[i].GraphicUpdateComplete();</span><br><span class="line"><span class="comment">// 清空图像重建序列 并修改图像重建标志为false</span></span><br><span class="line">    m_GraphicRebuildQueue.Clear();</span><br><span class="line">    m_PerformingGraphicUpdate = <span class="literal">false</span>;</span><br><span class="line">    UISystemProfilerApi.EndSample(UISystemProfilerApi.SampleType.Render);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">图像、布局重建注册器</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——ClipperRegistry</title>
    <link href="https://azzurebubble.github.io/posts/c266fbd7.html"/>
    <id>https://azzurebubble.github.io/posts/c266fbd7.html</id>
    <published>2024-07-18T01:46:53.000Z</published>
    <updated>2024-07-18T14:53:52.573Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ClipperRegister：是一个裁剪注册器单例，用于跟踪场景中存在的所有IClipper。</p><p>这在CanvasUpdate循环期间用于剔除可剪裁元素。剪裁在布局之后但在图形更新之前调用。</p></blockquote><h4 id="源码解析">源码解析</h4><blockquote><p>单例</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例获取</span></span><br><span class="line"><span class="keyword">static</span> ClipperRegistry s_Instance;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ClipperRegistry instance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s_Instance == <span class="literal">null</span>)</span><br><span class="line">            s_Instance = <span class="keyword">new</span> ClipperRegistry();</span><br><span class="line">        <span class="keyword">return</span> s_Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>保护类型的构造函数，这里面声明了一个空的带有具体类型的字典，是为了在AOT平台中能够识别使用前面说到的IndexedSet自定义容器中的字典容器。</p><p>类型的可参考xLua热更新就需要给每个泛型容器预先定义一个空的具体类型的容器。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ClipperRegistry</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> disable 168</span></span><br><span class="line">    Dictionary&lt;IClipper, <span class="built_in">int</span>&gt; emptyIClipperDic;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> restore 168</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Register：将裁剪对象添加到m_Clippers序列中</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Register</span>(<span class="params">IClipper c</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    instance.m_Clippers.AddUnique(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Cull：对所有注册的IClipper执行剪辑，在CanvasUpdateRegistry类中的PerformUpdate中调用了这个方法，可回顾查看</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Cull</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; m_Clippers.Count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Clippers[i].PerformClipping();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Unregister：取消注册的IClipper元素</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Unregister</span>(<span class="params">IClipper c</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">instance.m_Clippers.Remove(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一个裁剪注册器单例</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
</feed>
