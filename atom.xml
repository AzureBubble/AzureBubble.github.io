<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fomalhaut🥝</title>
  
  
  <link href="https://azzurebubble.github.io/atom.xml" rel="self"/>
  
  <link href="https://azzurebubble.github.io/"/>
  <updated>2024-09-15T09:50:21.713Z</updated>
  <id>https://azzurebubble.github.io/</id>
  
  <author>
    <name>Rock</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UGUI源码解析——Button</title>
    <link href="https://azzurebubble.github.io/posts/65fa9ff1.html"/>
    <id>https://azzurebubble.github.io/posts/65fa9ff1.html</id>
    <published>2024-09-15T09:48:57.000Z</published>
    <updated>2024-09-15T09:50:21.713Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——Text</title>
    <link href="https://azzurebubble.github.io/posts/3990f15b.html"/>
    <id>https://azzurebubble.github.io/posts/3990f15b.html</id>
    <published>2024-09-15T09:48:49.000Z</published>
    <updated>2024-09-15T09:50:21.725Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——RawImage</title>
    <link href="https://azzurebubble.github.io/posts/aaf04942.html"/>
    <id>https://azzurebubble.github.io/posts/aaf04942.html</id>
    <published>2024-09-15T09:48:28.000Z</published>
    <updated>2024-09-15T09:50:21.721Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——Image</title>
    <link href="https://azzurebubble.github.io/posts/3c86c066.html"/>
    <id>https://azzurebubble.github.io/posts/3c86c066.html</id>
    <published>2024-09-15T09:48:21.000Z</published>
    <updated>2024-09-15T09:50:21.718Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——Outline</title>
    <link href="https://azzurebubble.github.io/posts/d5f2204d.html"/>
    <id>https://azzurebubble.github.io/posts/d5f2204d.html</id>
    <published>2024-09-15T09:48:12.000Z</published>
    <updated>2024-09-15T09:50:21.720Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——Shadow</title>
    <link href="https://azzurebubble.github.io/posts/2a8ab1e1.html"/>
    <id>https://azzurebubble.github.io/posts/2a8ab1e1.html</id>
    <published>2024-09-15T09:48:03.000Z</published>
    <updated>2024-09-15T09:50:21.723Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——BaseMeshEffect</title>
    <link href="https://azzurebubble.github.io/posts/9693dd44.html"/>
    <id>https://azzurebubble.github.io/posts/9693dd44.html</id>
    <published>2024-09-15T09:47:54.000Z</published>
    <updated>2024-09-15T09:50:21.716Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——Clipping</title>
    <link href="https://azzurebubble.github.io/posts/7d77a4b4.html"/>
    <id>https://azzurebubble.github.io/posts/7d77a4b4.html</id>
    <published>2024-09-15T09:47:28.000Z</published>
    <updated>2024-09-15T09:50:21.718Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——StencilMaterial</title>
    <link href="https://azzurebubble.github.io/posts/544072e3.html"/>
    <id>https://azzurebubble.github.io/posts/544072e3.html</id>
    <published>2024-09-15T09:47:07.000Z</published>
    <updated>2024-09-15T09:50:21.723Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——MaskUtilities</title>
    <link href="https://azzurebubble.github.io/posts/bb5a059c.html"/>
    <id>https://azzurebubble.github.io/posts/bb5a059c.html</id>
    <published>2024-09-15T09:46:37.000Z</published>
    <updated>2024-09-15T09:50:21.720Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——RectMask2D</title>
    <link href="https://azzurebubble.github.io/posts/aeb7ffff.html"/>
    <id>https://azzurebubble.github.io/posts/aeb7ffff.html</id>
    <published>2024-09-15T09:46:23.000Z</published>
    <updated>2024-09-15T09:50:21.722Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——Mask</title>
    <link href="https://azzurebubble.github.io/posts/7d7495ac.html"/>
    <id>https://azzurebubble.github.io/posts/7d7495ac.html</id>
    <published>2024-09-15T09:46:14.000Z</published>
    <updated>2024-09-15T09:50:21.719Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——ClipperRegistry</title>
    <link href="https://azzurebubble.github.io/posts/c266fbd7.html"/>
    <id>https://azzurebubble.github.io/posts/c266fbd7.html</id>
    <published>2024-09-15T09:45:47.000Z</published>
    <updated>2024-09-15T09:50:21.717Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——IClippable</title>
    <link href="https://azzurebubble.github.io/posts/27cfff35.html"/>
    <id>https://azzurebubble.github.io/posts/27cfff35.html</id>
    <published>2024-09-15T07:10:45.000Z</published>
    <updated>2024-09-15T07:26:03.587Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>IClippable：MaskableGraphic继承此接口</p></blockquote><h4 id="源码解析">源码解析</h4><blockquote><p>IClipper：裁剪接口（裁剪者），RectMask2D继承此接口。接口中只有一个方法，在子类中实现PerformClipping，此方法在布局重建后图像重建前执行</p><p>首先将每个实现了IClipper接口的对象添加到待裁剪序列中，在CanvasUpdateRegistry类中的PerformUpdate里调用了Cull方法执行裁剪序列中每个对象的PerformClipping方法参与Canvas的更新</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 可以用来接收裁剪回调作为画布更新循环的一部分</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IClipper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 删除/剪辑子元素的函数</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 在Canvas更新循环的布局之后和图形更新之前调用。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PerformClipping</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>IClippable接口</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span>   Interface for elements that can be clipped if they are under an IClipper</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IClippable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 实现此接口的游戏物体</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    GameObject gameObject &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 重新计算待裁剪对象（MaskUtilities的Notify2DMaskStateChanged调用）</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RecalculateClipping</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 实现此接口的游戏物体的 RectTransform</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    RectTransform rectTransform &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 裁剪和剔除给定的矩形（RectMask2D的PerformClipping调用）</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;clipRect&quot;&gt;</span>要剪切的矩形<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;validRect&quot;&gt;</span>Rect是否有效?如果不是，则矩形的大小为0<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Cull</span>(<span class="params">Rect clipRect, <span class="built_in">bool</span> validRect</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 设置裁剪矩形（RectMask2D的PerformClipping调用）</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;value&quot;&gt;</span>用于剪切的矩形<span class="doctag">&lt;&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;validRect&quot;&gt;</span>rect是否有效<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetClipRect</span>(<span class="params">Rect <span class="keyword">value</span>, <span class="built_in">bool</span> validRect</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 设置渐变度（RectMask2D的PerformClipping调用）</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetClipSoftness</span>(<span class="params">Vector2 clipSoftness</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">裁剪接口(被裁剪者)</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——IMaskable</title>
    <link href="https://azzurebubble.github.io/posts/e480027.html"/>
    <id>https://azzurebubble.github.io/posts/e480027.html</id>
    <published>2024-09-15T07:10:34.000Z</published>
    <updated>2024-09-15T07:19:57.611Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>IMaskable：可以在子类中实现RecalculateMasking方法去重新计算遮罩</p></blockquote><h4 id="源码解析">源码解析</h4><blockquote><p>IMaskable接口</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span>   这个元素可以被遮罩</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMaskable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 重新计算所有子元素的遮罩.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 使用这个来更新内部状态(重新创建材质等)</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RecalculateMasking</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">遮罩接口(被遮罩者)</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——MaskableGraphic</title>
    <link href="https://azzurebubble.github.io/posts/6507ee44.html"/>
    <id>https://azzurebubble.github.io/posts/6507ee44.html</id>
    <published>2024-09-15T07:07:49.000Z</published>
    <updated>2024-09-15T07:22:47.417Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>MaskableGraphic：是可被遮罩的图像，严谨的说应该是可被遮罩和可被裁剪的图像，可它继承自Graphic类和IClippable、IMaskable、IMaterialModifier接口，在Graphic的基础上实现了裁剪和遮罩功能，Image、RawImage、Text都继承自MaskableGraphic类</p></blockquote><p><a href="https://azurebubble.github.io/posts/ee37f782.html"><strong>UGUI源码解析——Graphic</strong></a></p><p><a href="https://azurebubble.github.io/posts/6390c557.html"><strong>UGUI源码解析——IMaterialModifier</strong></a></p><p><a href="https://azurebubble.github.io/posts/e480027.html"><strong>UGUI源码解析——IMaskable</strong></a></p><p><a href="https://azurebubble.github.io/posts/27cfff35.html"><strong>UGUI源码解析——IClippable</strong></a></p><h4 id="源码解析">源码解析</h4><blockquote></blockquote>]]></content>
    
    
    <summary type="html">继承自 Graphic，实现了裁剪和遮罩功能。</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——IMaterialModifier</title>
    <link href="https://azzurebubble.github.io/posts/6390c557.html"/>
    <id>https://azzurebubble.github.io/posts/6390c557.html</id>
    <published>2024-08-18T14:27:03.000Z</published>
    <updated>2024-08-18T14:30:13.166Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>IMaterialModifier：是材质处理的接口，可以在子类中实现GetModifiedMaterial方法去修改渲染的材质。<br>Mask实现了此接口</p></blockquote><h4 id="源码解析">源码解析</h4><blockquote><p>GetModifiedMaterial：</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Material <span class="title">GetModifiedMaterial</span>(<span class="params">Material baseMaterial</span>)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>Canvas每帧更新时会将materialForRendering赋给canvasRenderer进行渲染</p></blockquote>]]></content>
    
    
    <summary type="html">材质处理的接口，可以在子类中实现GetModifiedMaterial方法去修改渲染的材质。</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——VertexHelper</title>
    <link href="https://azzurebubble.github.io/posts/93fc2cc0.html"/>
    <id>https://azzurebubble.github.io/posts/93fc2cc0.html</id>
    <published>2024-08-18T14:18:07.000Z</published>
    <updated>2024-09-15T07:06:04.988Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>VertexHelper：是一个工具类，可以帮助我们快速创建网格<br>我们知道一个UI想要显示出来就需要对应的Mesh网格信息，而生成Mesh的网格信息就保存在了VertexHelper中，实际上我们可以直接操作Mesh类添加顶点等数据，可以理解为VertexHelper是UGUI与Mesh之间的一座桥梁。</p></blockquote><h4 id="源码解析">源码解析</h4><blockquote><p>字段</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Vector3&gt; m_Positions; <span class="comment">// 顶点位置</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Color32&gt; m_Colors; <span class="comment">// 顶点颜色</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Vector2&gt; m_Uv0S; <span class="comment">// 第一个顶点的UV坐标</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Vector2&gt; m_Uv1S; <span class="comment">// 第二个顶点的UV坐标</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Vector2&gt; m_Uv2S; <span class="comment">// 第三个顶点的UV坐标</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Vector2&gt; m_Uv3S; <span class="comment">// 第四个顶点的UV坐标</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Vector3&gt; m_Normals; <span class="comment">// 法线向量</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Vector4&gt; m_Tangents; <span class="comment">// 切线向量</span></span><br><span class="line"><span class="keyword">private</span> List&lt;<span class="built_in">int</span>&gt; m_Indices; <span class="comment">// 三角面顶点索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性</span></span><br><span class="line"><span class="comment">// 当前顶点数</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> currentVertCount</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_Positions != <span class="literal">null</span> ? m_Positions.Count : <span class="number">0</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当前顶点索引（为了绘制三角形，同一个顶点可能会使用多次，这里会统计使用多次的情况）</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> currentIndexCount</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_Indices != <span class="literal">null</span> ? m_Indices.Count : <span class="number">0</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态默认切线向量 X\Y\Z\W</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Vector4 s_DefaultTangent = <span class="keyword">new</span> Vector4(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line"><span class="comment">// 静态默认法线向量 向后</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Vector3 s_DefaultNormal = Vector3.back;</span><br><span class="line"><span class="comment">// 记录顶点数据列表是否已初始化</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> m_ListsInitalized = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><blockquote><p>构造函数：将 Mesh 对象 m 中的各个顶点属性(如位置、颜色、UV坐标、法线、切线和索引)提取到 VertexHelper 实例的相应列表中。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">VertexHelper</span>(<span class="params">Mesh m</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化数据列表</span></span><br><span class="line">    InitializeListIfRequired();</span><br><span class="line"><span class="comment">// 将 Mesh 对象 m 中的各个顶点属性(如位置、颜色、UV坐标、法线、切线和索引)提取到 VertexHelper 实例的相应列表中。</span></span><br><span class="line">    m_Positions.AddRange(m.vertices);</span><br><span class="line">    m_Colors.AddRange(m.colors32);</span><br><span class="line">    m_Uv0S.AddRange(m.uv);</span><br><span class="line">    m_Uv1S.AddRange(m.uv2);</span><br><span class="line">    m_Uv2S.AddRange(m.uv3);</span><br><span class="line">    m_Uv3S.AddRange(m.uv4);</span><br><span class="line">    m_Normals.AddRange(m.normals);</span><br><span class="line">    m_Tangents.AddRange(m.tangents);</span><br><span class="line">    m_Indices.AddRange(m.GetIndices(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>InitializeListIfRequired：通过对象池初始化所有的数据列表</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InitializeListIfRequired</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_ListsInitalized)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Positions = ListPool&lt;Vector3&gt;.Get();</span><br><span class="line">        m_Colors = ListPool&lt;Color32&gt;.Get();</span><br><span class="line">        m_Uv0S = ListPool&lt;Vector2&gt;.Get();</span><br><span class="line">        m_Uv1S = ListPool&lt;Vector2&gt;.Get();</span><br><span class="line">        m_Uv2S = ListPool&lt;Vector2&gt;.Get();</span><br><span class="line">        m_Uv3S = ListPool&lt;Vector2&gt;.Get();</span><br><span class="line">        m_Normals = ListPool&lt;Vector3&gt;.Get();</span><br><span class="line">        m_Tangents = ListPool&lt;Vector4&gt;.Get();</span><br><span class="line">        m_Indices = ListPool&lt;<span class="built_in">int</span>&gt;.Get();</span><br><span class="line">        m_ListsInitalized = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Dispose：释放内存</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_ListsInitalized)</span><br><span class="line">    &#123;</span><br><span class="line">        ListPool&lt;Vector3&gt;.Release(m_Positions);</span><br><span class="line">        ListPool&lt;Color32&gt;.Release(m_Colors);</span><br><span class="line">        ListPool&lt;Vector2&gt;.Release(m_Uv0S);</span><br><span class="line">        ListPool&lt;Vector2&gt;.Release(m_Uv1S);</span><br><span class="line">        ListPool&lt;Vector2&gt;.Release(m_Uv2S);</span><br><span class="line">        ListPool&lt;Vector2&gt;.Release(m_Uv3S);</span><br><span class="line">        ListPool&lt;Vector3&gt;.Release(m_Normals);</span><br><span class="line">        ListPool&lt;Vector4&gt;.Release(m_Tangents);</span><br><span class="line">        ListPool&lt;<span class="built_in">int</span>&gt;.Release(m_Indices);</span><br><span class="line"></span><br><span class="line">        m_Positions = <span class="literal">null</span>;</span><br><span class="line">        m_Colors = <span class="literal">null</span>;</span><br><span class="line">        m_Uv0S = <span class="literal">null</span>;</span><br><span class="line">        m_Uv1S = <span class="literal">null</span>;</span><br><span class="line">        m_Uv2S = <span class="literal">null</span>;</span><br><span class="line">        m_Uv3S = <span class="literal">null</span>;</span><br><span class="line">        m_Normals = <span class="literal">null</span>;</span><br><span class="line">        m_Tangents = <span class="literal">null</span>;</span><br><span class="line">        m_Indices = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        m_ListsInitalized = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Clear：如果初始化过，则清空缓存</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Clear</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_ListsInitalized)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Positions.Clear();</span><br><span class="line">        m_Colors.Clear();</span><br><span class="line">        m_Uv0S.Clear();</span><br><span class="line">        m_Uv1S.Clear();</span><br><span class="line">        m_Uv2S.Clear();</span><br><span class="line">        m_Uv3S.Clear();</span><br><span class="line">        m_Normals.Clear();</span><br><span class="line">        m_Tangents.Clear();</span><br><span class="line">        m_Indices.Clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetUIVertex：将某个顶点数据赋值给指定索引的顶点数据</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetUIVertex</span>(<span class="params">UIVertex vertex, <span class="built_in">int</span> i</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    InitializeListIfRequired();</span><br><span class="line"></span><br><span class="line">    m_Positions[i] = vertex.position;</span><br><span class="line">    m_Colors[i] = vertex.color;</span><br><span class="line">    m_Uv0S[i] = vertex.uv0;</span><br><span class="line">    m_Uv1S[i] = vertex.uv1;</span><br><span class="line">    m_Uv2S[i] = vertex.uv2;</span><br><span class="line">    m_Uv3S[i] = vertex.uv3;</span><br><span class="line">    m_Normals[i] = vertex.normal;</span><br><span class="line">    m_Tangents[i] = vertex.tangent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>FillMesh：将当前VertexHelper中的数据填充到输入的Mesh上，注意顶点数不能超过65000</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FillMesh</span>(<span class="params">Mesh mesh</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    InitializeListIfRequired();</span><br><span class="line"></span><br><span class="line">    mesh.Clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_Positions.Count &gt;= <span class="number">65000</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;Mesh can not have more than 65000 vertices&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mesh.SetVertices(m_Positions);</span><br><span class="line">    mesh.SetColors(m_Colors);</span><br><span class="line">    mesh.SetUVs(<span class="number">0</span>, m_Uv0S);</span><br><span class="line">    mesh.SetUVs(<span class="number">1</span>, m_Uv1S);</span><br><span class="line">    mesh.SetUVs(<span class="number">2</span>, m_Uv2S);</span><br><span class="line">    mesh.SetUVs(<span class="number">3</span>, m_Uv3S);</span><br><span class="line">    mesh.SetNormals(m_Normals);</span><br><span class="line">    mesh.SetTangents(m_Tangents);</span><br><span class="line">    mesh.SetTriangles(m_Indices, <span class="number">0</span>);</span><br><span class="line">    mesh.RecalculateBounds();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>AddVert：添加顶点</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddVert</span>(<span class="params">Vector3 position, Color32 color, Vector2 uv0, Vector2 uv1, Vector2 uv2, Vector2 uv3, Vector3 normal, Vector4 tangent</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    InitializeListIfRequired();</span><br><span class="line"></span><br><span class="line">    m_Positions.Add(position);</span><br><span class="line">    m_Colors.Add(color);</span><br><span class="line">    m_Uv0S.Add(uv0);</span><br><span class="line">    m_Uv1S.Add(uv1);</span><br><span class="line">    m_Uv2S.Add(uv2);</span><br><span class="line">    m_Uv3S.Add(uv3);</span><br><span class="line">    m_Normals.Add(normal);</span><br><span class="line">    m_Tangents.Add(tangent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddVert</span>(<span class="params">Vector3 position, Color32 color, Vector2 uv0, Vector2 uv1, Vector3 normal, Vector4 tangent</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    AddVert(position, color, uv0, uv1, Vector2.zero, Vector2.zero, normal, tangent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddVert</span>(<span class="params">Vector3 position, Color32 color, Vector2 uv0</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    AddVert(position, color, uv0, Vector2.zero, s_DefaultNormal, s_DefaultTangent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddVert</span>(<span class="params">UIVertex v</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    AddVert(v.position, v.color, v.uv0, v.uv1, v.normal, v.tangent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>AddTriangle：添加三角形，按照顶点索引顺序进行绘制（CanvasRender和MeshRender不同在于三角形索引顺序不论正反CanvasRender都能够绘制出来）</p><h3 id="1-CanvasRenderer"><strong>1. CanvasRenderer:</strong></h3><ul><li><strong>CanvasRenderer</strong> 是 Unity UI 系统中的一部分，用于绘制 UI 元素（如按钮、图像等）。</li><li><strong>绘制方式</strong>: <code>CanvasRenderer</code> 不依赖于三角形的索引顺序（即正向或反向）。它可以正确绘制三角形，即使它们的顶点索引顺序是反向的（逆时针或顺时针）。</li><li><strong>原因</strong>: 在 Canvas 系统中，顶点的索引顺序通常不会影响绘制结果，因为 CanvasRenderer 主要关注的是 UI 组件的渲染，而不是底层的几何图形处理。Canvas 的渲染逻辑处理的是已经转换成屏幕坐标系的元素，而不是深度或面朝向。</li></ul><h3 id="2-MeshRenderer"><strong>2. MeshRenderer:</strong></h3><ul><li><strong>MeshRenderer</strong> 是用于渲染 3D 网格的组件。</li><li><strong>绘制方式</strong>: <code>MeshRenderer</code> 对三角形的索引顺序有严格的要求。默认情况下，它期望三角形的顶点按顺时针（或逆时针）顺序排列，以确定三角形的正面（前面）。如果三角形的顶点索引顺序不符合预期，可能会导致三角形的面朝向不正确，或者三角形不会被渲染。</li><li><strong>原因</strong>: 在 3D 图形渲染中，面朝向决定了哪些面是可见的，哪些面是隐藏的（背面剔除）。正确的索引顺序对于正确的深度测试和视觉渲染是至关重要的。</li></ul></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddTriangle</span>(<span class="params"><span class="built_in">int</span> idx0, <span class="built_in">int</span> idx1, <span class="built_in">int</span> idx2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    InitializeListIfRequired();</span><br><span class="line"><span class="comment">// 三角顶点的索引</span></span><br><span class="line">    m_Indices.Add(idx0);</span><br><span class="line">    m_Indices.Add(idx1);</span><br><span class="line">    m_Indices.Add(idx2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>AddUIVertexQuad：根据传入的顶点数据数组(verts)，从当前索引处添加一个长方形，顶点数据数组(verts)中不论有几个数据也只能添加四个顶点数据</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddUIVertexQuad</span>(<span class="params">UIVertex[] verts</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> startIndex = currentVertCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        AddVert(verts[i].position, verts[i].color, verts[i].uv0, verts[i].uv1, verts[i].normal, verts[i].tangent);</span><br><span class="line"></span><br><span class="line">    AddTriangle(startIndex, startIndex + <span class="number">1</span>, startIndex + <span class="number">2</span>);</span><br><span class="line">    AddTriangle(startIndex + <span class="number">2</span>, startIndex + <span class="number">3</span>, startIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>AddUIVertexStream：将传入的顶点数据列表(verts)覆盖掉当前VertexHelper中的顶点数据，不会覆盖m_Indices<br>将传入的顶点索引列表(indices)添加到当前VertexHelper的m_Indices列表中</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddUIVertexStream</span>(<span class="params">List&lt;UIVertex&gt; verts, List&lt;<span class="built_in">int</span>&gt; indices</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    InitializeListIfRequired();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (verts != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        CanvasRenderer.AddUIVertexStream(verts, m_Positions, m_Colors, m_Uv0S, m_Uv1S, m_Uv2S, m_Uv3S, m_Normals, m_Tangents);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (indices != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Indices.AddRange(indices);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>AddUIVertexTriangleStream：将传入的顶点数据列表(verts)覆盖添加到当前VertexHelper中，会覆盖掉之前VertexHelper中的所有数据包括m_Indices列表，传入的顶点数据列表(verts)有几个数据，最终VertexHelper中的顶点列表和顶点索引列表就有几个数据，传入的顶点数据列表(verts)的长度必须是三的倍数</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddUIVertexTriangleStream</span>(<span class="params">List&lt;UIVertex&gt; verts</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (verts == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    InitializeListIfRequired();</span><br><span class="line"></span><br><span class="line">    CanvasRenderer.SplitUIVertexStreams(verts, m_Positions, m_Colors, m_Uv0S, m_Uv1S, m_Uv2S, m_Uv3S, m_Normals, m_Tangents, m_Indices);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GetUIVertexStream：获取当前VertexHelper中的所有顶点数据<br>将当前VertexHelper中的所有顶点数据填充到传入的顶点数据列表中(stream)，会根据m_Indices顶点索引列表的数量创建顶点数据，例如一个长方形需要4个顶点，6个顶点索引，使用此方法得到的列表元素数量是6</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetUIVertexStream</span>(<span class="params">List&lt;UIVertex&gt; stream</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (stream == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    InitializeListIfRequired();</span><br><span class="line"></span><br><span class="line">    CanvasRenderer.CreateUIVertexStream(stream, m_Positions, m_Colors, m_Uv0S, m_Uv1S, m_Uv2S, m_Uv3S, m_Normals, m_Tangents, m_Indices);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PopulateUIVertex：返回指定索引的顶点数据</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PopulateUIVertex</span>(<span class="params"><span class="keyword">ref</span> UIVertex vertex, <span class="built_in">int</span> i</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    InitializeListIfRequired();</span><br><span class="line"></span><br><span class="line">    vertex.position = m_Positions[i];</span><br><span class="line">    vertex.color = m_Colors[i];</span><br><span class="line">    vertex.uv0 = m_Uv0S[i];</span><br><span class="line">    vertex.uv1 = m_Uv1S[i];</span><br><span class="line">    vertex.uv2 = m_Uv2S[i];</span><br><span class="line">    vertex.uv3 = m_Uv3S[i];</span><br><span class="line">    vertex.normal = m_Normals[i];</span><br><span class="line">    vertex.tangent = m_Tangents[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">网格数据的工具类。</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——CoroutineTween</title>
    <link href="https://azzurebubble.github.io/posts/59942898.html"/>
    <id>https://azzurebubble.github.io/posts/59942898.html</id>
    <published>2024-08-18T14:17:14.000Z</published>
    <updated>2024-08-18T14:30:39.020Z</updated>
    
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——SetPropertyUtility</title>
    <link href="https://azzurebubble.github.io/posts/ef6aa33a.html"/>
    <id>https://azzurebubble.github.io/posts/ef6aa33a.html</id>
    <published>2024-08-18T09:00:04.000Z</published>
    <updated>2024-08-18T09:05:37.556Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>SetPropertyUtility：设置UI元素属性的静态工具类。</p></blockquote><h4 id="源码解析">源码解析</h4><blockquote><p>SetColor:修改颜色值，如果新传入的颜色的RGBA和就颜色相同则不进行修改</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">SetColor</span>(<span class="params"><span class="keyword">ref</span> Color currentValue, Color newValue</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (currentValue.r == newValue.r &amp;&amp; currentValue.g == newValue.g &amp;&amp; currentValue.b == newValue.b &amp;&amp; currentValue.a == newValue.a)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    currentValue = newValue;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetStruct:比较两个结构体的值，如果为不一样才进行更新</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">SetStruct</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">ref</span> T currentValue, T newValue</span>) <span class="keyword">where</span> T : <span class="keyword">struct</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (EqualityComparer&lt;T&gt;.Default.Equals(currentValue, newValue))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    currentValue = newValue;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetClass:比较两个类的值，如果不一样且都不为空才进行更新</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">SetClass</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">ref</span> T currentValue, T newValue</span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((currentValue == <span class="literal">null</span> &amp;&amp; newValue == <span class="literal">null</span>) || (currentValue != <span class="literal">null</span> &amp;&amp; currentValue.Equals(newValue)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    currentValue = newValue;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">设置UI元素属性的静态工具类。</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
</feed>
