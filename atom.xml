<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fomalhaut🥝</title>
  
  
  <link href="https://azzurebubble.github.io/atom.xml" rel="self"/>
  
  <link href="https://azzurebubble.github.io/"/>
  <updated>2024-07-20T09:05:24.053Z</updated>
  <id>https://azzurebubble.github.io/</id>
  
  <author>
    <name>Rock</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UGUI源码解析——LayoutGroup</title>
    <link href="https://azzurebubble.github.io/posts/51e1a8f9.html"/>
    <id>https://azzurebubble.github.io/posts/51e1a8f9.html</id>
    <published>2024-07-20T07:32:34.000Z</published>
    <updated>2024-07-20T09:05:24.053Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>LayoutGroup：LayoutGroup是控制子布局对象组件的基类，实现了ILayoutElement和ILayoutGroup接口，继承自UIBehaviour，说明它既是一个布局元素也是一个布局控制器，HorizontalLayoutGroup、VerticalLayoutGroup、GridLayoutGroup都继承或间接继承了此类。</p></blockquote><h4 id="源码解析">源码解析</h4><h5 id="特性">特性</h5><blockquote><p>[DisallowMultipleComponent]：不允许组件对象挂载重复的这个脚本。</p><p>[ExecuteAlways]：确保脚本在编辑器和游戏运行时都能被执行。</p><p>[RequireComponent(typeof(RectTransform))]：确保组件对象挂载了RectTransform组件。</p></blockquote><h5 id="内部实现">内部实现</h5><blockquote><p>m_Padding：可以在Unity的Inspector窗口中直观的调整和配置这个矩形区域的边距偏移量，而无需通过代码进行硬编码。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RectOffset 类型用于定义矩形区域的偏移量。它通常用于 UI 布局中，例如在实现边距（padding）或者边框（border）时非常有用。</span></span><br><span class="line"><span class="keyword">protected</span> RectOffset m_Padding = <span class="keyword">new</span> RectOffset();</span><br><span class="line"><span class="comment">// 控制子布局元素周围的边距偏移量。</span></span><br><span class="line"><span class="keyword">public</span> RectOffset padding &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_Padding; &#125; <span class="keyword">set</span> &#123; SetProperty(<span class="keyword">ref</span> m_Padding, <span class="keyword">value</span>);</span><br></pre></td></tr></table></figure><blockquote><p>SetProperty：帮助器方法，用于在给定属性发生更改时设置该属性。</p><p>这是类似MVVM模式中的使用方法</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">SetProperty</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">ref</span> T currentValue, T newValue</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((currentValue == <span class="literal">null</span> &amp;&amp; newValue == <span class="literal">null</span>) || (currentValue != <span class="literal">null</span> &amp;&amp; currentValue.Equals(newValue)))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    currentValue = newValue;</span><br><span class="line">    SetDirty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetDirty：标记LayoutGroup为Dirty，标记当前对象的布局是否需要重新构建，如果是失活状态将不会被标记。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">SetDirty</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 失活状态则不标记</span></span><br><span class="line">    <span class="keyword">if</span> (!IsActive())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前不在进行布局重建中则通过LayoutRebuilder.MarkLayoutForRebuild来标记当前对象的布局需要重新构建</span></span><br><span class="line">    <span class="keyword">if</span> (!CanvasUpdateRegistry.IsRebuildingLayout())</span><br><span class="line">        LayoutRebuilder.MarkLayoutForRebuild(rectTransform);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则启动一个协程DelayedSetDirty，延迟标记此对象布局需要重新构建</span></span><br><span class="line">        StartCoroutine(DelayedSetDirty(rectTransform));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>协程DelayedSetDirty:等待一帧之后再通过LayoutRebuilder.MarkLayoutForRebuild来标记当前对象的布局需要重新构建。可以使用LayoutRebuilder.ForceRebuildLayoutImmediate(rectTransform)方法强制更新布局。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">DelayedSetDirty</span>(<span class="params">RectTransform rectTransform</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    LayoutRebuilder.MarkLayoutForRebuild(rectTransform);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>子布局元素的对齐方式</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">protected</span> TextAnchor m_ChildAlignment = TextAnchor.UpperLeft;</span><br><span class="line"><span class="comment">// 布局组中子布局元素的对齐方式。默认是左上角对齐。</span></span><br><span class="line"><span class="keyword">public</span> TextAnchor childAlignment &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_ChildAlignment; &#125; <span class="keyword">set</span> &#123; SetProperty(<span class="keyword">ref</span> m_ChildAlignment, <span class="keyword">value</span>); &#125; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>获取此布局元素的RectTransform组件</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">System.NonSerialized</span>] <span class="keyword">private</span> RectTransform m_Rect;</span><br><span class="line"><span class="keyword">protected</span> RectTransform rectTransform</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Rect == <span class="literal">null</span>)</span><br><span class="line">            m_Rect = GetComponent&lt;RectTransform&gt;();</span><br><span class="line">        <span class="keyword">return</span> m_Rect;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>存储布局组中所有的子布局元素</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">System.NonSerialized</span>] <span class="keyword">private</span> List&lt;RectTransform&gt; m_RectChildren = <span class="keyword">new</span> List&lt;RectTransform&gt;();</span><br><span class="line"><span class="keyword">protected</span> List&lt;RectTransform&gt; rectChildren &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_RectChildren; &#125; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>一些其他属性和字段</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DrivenRectTransformTracker 是 Unity 提供的一个用于跟踪 RectTransform 尺寸和位置的工具类。确保布局可以在尺寸或位置变化时得到更新。</span></span><br><span class="line"><span class="keyword">protected</span> DrivenRectTransformTracker m_Tracker;</span><br><span class="line"><span class="comment">// m_TotalMinSize 用来记录当前布局所需的最小尺寸。初始值设为 Vector2.zero，即没有最小尺寸要求。</span></span><br><span class="line"><span class="keyword">private</span> Vector2 m_TotalMinSize = Vector2.zero;</span><br><span class="line"><span class="comment">// m_TotalPreferredSize 用来记录当前布局所需的首选尺寸。初始为 Vector2.zero，即没有首选尺寸要求。</span></span><br><span class="line"><span class="keyword">private</span> Vector2 m_TotalPreferredSize = Vector2.zero;</span><br><span class="line"><span class="comment">// m_TotalFlexibleSize 用来记录当前布局所需的灵活尺寸（即可变尺寸）。初始值设为 Vector2.zero，表示没有灵活尺寸的要求。</span></span><br><span class="line"><span class="keyword">private</span> Vector2 m_TotalFlexibleSize = Vector2.zero;</span><br></pre></td></tr></table></figure><blockquote><p>CalculateLayoutInputHorizontal：实现ILayoutElement中的接口，子类可重写</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CalculateLayoutInputHorizontal</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 清空当前子布局元素容器</span></span><br><span class="line">    m_RectChildren.Clear();</span><br><span class="line">    <span class="comment">// 使用对象池获取一个临时的ListPool&lt;Component&gt;容器</span></span><br><span class="line">    <span class="keyword">var</span> toIgnoreList = ListPool&lt;Component&gt;.Get();</span><br><span class="line">    <span class="comment">// 过滤不参与布局的子布局元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; rectTransform.childCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> rect = rectTransform.GetChild(i) <span class="keyword">as</span> RectTransform;</span><br><span class="line">        <span class="comment">// 没有RectTransform组件和在Hierarchy中没有被激活则跳过</span></span><br><span class="line">        <span class="keyword">if</span> (rect == <span class="literal">null</span> || !rect.gameObject.activeInHierarchy)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取附加在子布局元素组件的所有ILayoutIgnorer组件对象</span></span><br><span class="line">        rect.GetComponents(<span class="keyword">typeof</span>(ILayoutIgnorer), toIgnoreList);</span><br><span class="line"><span class="comment">// 如果为空，则代表需要参与布局</span></span><br><span class="line">        <span class="keyword">if</span> (toIgnoreList.Count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_RectChildren.Add(rect);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只要存在一个为false的ILayoutIgnorer组件，则需要参与布局</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; toIgnoreList.Count; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> ignorer = (ILayoutIgnorer)toIgnoreList[j];</span><br><span class="line">            <span class="keyword">if</span> (!ignorer.ignoreLayout)</span><br><span class="line">            &#123;</span><br><span class="line">                m_RectChildren.Add(rect);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放toIgnoreList返回对象池</span></span><br><span class="line">    ListPool&lt;Component&gt;.Release(toIgnoreList);</span><br><span class="line">    <span class="comment">// 清空布局追踪器</span></span><br><span class="line">    m_Tracker.Clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>抽象方法CalculateLayoutInputVertical计算垂直布局输入，子类必须实现</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">CalculateLayoutInputVertical</span>()</span>;</span><br></pre></td></tr></table></figure><blockquote><p>GetTotalMinSize：由子类调用给定轴上布局组的最小大小</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 轴索引。0表示水平，1表示垂直。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="built_in">float</span> <span class="title">GetTotalMinSize</span>(<span class="params"><span class="built_in">int</span> axis</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_TotalMinSize[axis];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GetTotalPreferredSize</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// // 轴索引。0表示水平，1表示垂直。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="built_in">float</span> <span class="title">GetTotalPreferredSize</span>(<span class="params"><span class="built_in">int</span> axis</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_TotalPreferredSize[axis];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GetTotalFlexibleSize：由子类调用给定轴上布局组的灵活大小。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// // 轴索引。0表示水平，1表示垂直。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="built_in">float</span> <span class="title">GetTotalFlexibleSize</span>(<span class="params"><span class="built_in">int</span> axis</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_TotalFlexibleSize[axis];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ILayoutController中的接口，抽象方法，子类必须实现的回调</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">SetLayoutHorizontal</span>()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">SetLayoutVertical</span>()</span>;</span><br></pre></td></tr></table></figure><blockquote><p>构造方法</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">LayoutGroup</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_Padding == <span class="literal">null</span>)</span><br><span class="line">        m_Padding = <span class="keyword">new</span> RectOffset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>生命周期OnEnable：启用时，标记为需要进行布局重建</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">base</span>.OnEnable();</span><br><span class="line">    SetDirty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>生命周期OnDisable：失活时，清空布局追踪器，强制更新布局</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    m_Tracker.Clear();</span><br><span class="line">    LayoutRebuilder.MarkLayoutForRebuild(rectTransform);</span><br><span class="line">    <span class="keyword">base</span>.OnDisable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>OnDidApplyAnimationProperties：当动画属性改变时，标记为需要进行布局重建</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnDidApplyAnimationProperties</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">SetDirty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>OnRectTransformDimensionsChange：当动画属性改变时，标记为需要进行布局重建</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnDidApplyAnimationProperties</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">SetDirty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GetStartOffset：根据给定轴和对齐方式计算第一个子布局元素起始偏移坐标，由子类调用。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 轴索引。0表示水平，1表示垂直</span></span><br><span class="line"><span class="comment">// 所有布局元素在给定轴上所需的总空间，包括间距和不包括填充。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="built_in">float</span> <span class="title">GetStartOffset</span>(<span class="params"><span class="built_in">int</span> axis, <span class="built_in">float</span> requiredSpaceWithoutPadding</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 计算实际需要的空间大小。它等于 requiredSpaceWithoutPadding 加上轴向上的填充值，根据 axis 的值来决定使用水平填充或垂直填充。</span></span><br><span class="line">    <span class="built_in">float</span> requiredSpace = requiredSpaceWithoutPadding + (axis == <span class="number">0</span> ? padding.horizontal : padding.vertical);</span><br><span class="line">    <span class="comment">// 获取当前轴上可用的空间大小，通过查询 rectTransform.rect.size[axis] 得到。</span></span><br><span class="line">    <span class="built_in">float</span> availableSpace = rectTransform.rect.size[axis];</span><br><span class="line">    <span class="comment">// 计算剩余的空间大小，即 availableSpace 减去 requiredSpace。</span></span><br><span class="line">    <span class="built_in">float</span> surplusSpace = availableSpace - requiredSpace;</span><br><span class="line">    <span class="comment">// 调用 GetAlignmentOnAxis(axis) 方法，获取在当前轴上的对齐方式或比例因子。</span></span><br><span class="line">    <span class="built_in">float</span> alignmentOnAxis = GetAlignmentOnAxis(axis);</span><br><span class="line">    <span class="comment">// 如果 axis 是 0（水平轴），则返回水平填充的左边距 padding.left 加上剩余空间乘以轴向的对齐方式。</span></span><br><span class="line"><span class="comment">// 如果 axis 是 1（垂直轴），则返回垂直填充的顶边距 padding.top 加上剩余空间乘以轴向的对齐方式。</span></span><br><span class="line">    <span class="keyword">return</span> (axis == <span class="number">0</span> ? padding.left : padding.top) + surplusSpace * alignmentOnAxis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GetAlignmentOnAxis：以分数形式返回指定轴上的对齐方式，其中0为左/上，0.5为中，1为右/下。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0表示水平，1表示垂直</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="built_in">float</span> <span class="title">GetAlignmentOnAxis</span>(<span class="params"><span class="built_in">int</span> axis</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (axis == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 水平轴：子布局元素的对齐方式进行模3运算，得到一个范围在0~2之间的整数，这个值乘以0.5f,得到一个在0.0f~1.0f之间的浮点数作为水平对齐的比例因子</span></span><br><span class="line">        <span class="keyword">return</span> ((<span class="built_in">int</span>)childAlignment % <span class="number">3</span>) * <span class="number">0.5f</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 垂直轴：子布局元素的对齐方式进行除3运算，得到一个范围在0~2之间的整数，这个值乘以0.5f,得到一个在0.0f~1.0f之间的浮点数作为垂直对齐的比例因子</span></span><br><span class="line">        <span class="keyword">return</span> ((<span class="built_in">int</span>)childAlignment / <span class="number">3</span>) * <span class="number">0.5f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetLayoutInputForAxis：用于设置给定轴的计算布局属性。由子类调用。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0表示水平，1表示垂直。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">SetLayoutInputForAxis</span>(<span class="params"><span class="built_in">float</span> totalMin, <span class="built_in">float</span> totalPreferred, <span class="built_in">float</span> totalFlexible, <span class="built_in">int</span> axis</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    m_TotalMinSize[axis] = totalMin;</span><br><span class="line">    m_TotalPreferredSize[axis] = totalPreferred;</span><br><span class="line">    m_TotalFlexibleSize[axis] = totalFlexible;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetChildAlongAxis：设置子布局元素沿给定轴的位置和大小。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0表示水平，1表示垂直。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">SetChildAlongAxis</span>(<span class="params">RectTransform rect, <span class="built_in">int</span> axis, <span class="built_in">float</span> pos</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rect == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    SetChildAlongAxisWithScale(rect, axis, pos, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetChildAlongAxisWithScale：设置子布局元素沿给定轴的位置和大小。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0表示水平，1表示垂直。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">SetChildAlongAxisWithScale</span>(<span class="params">RectTransform rect, <span class="built_in">int</span> axis, <span class="built_in">float</span> pos, <span class="built_in">float</span> scaleFactor</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rect == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 跟踪锚点和锚定位置（Anchors 和 AnchoredPositionX 或 AnchoredPositionY）的变化</span></span><br><span class="line">    m_Tracker.Add(<span class="keyword">this</span>, rect,</span><br><span class="line">        DrivenTransformProperties.Anchors |</span><br><span class="line">        (axis == <span class="number">0</span> ? DrivenTransformProperties.AnchoredPositionX : DrivenTransformProperties.AnchoredPositionY));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内联rect.SetInsetAndSizeFromParentEdge(…)和重构代码，以乘以所需的大小scaleFactor。</span></span><br><span class="line"><span class="comment">// sizeDelta必须保持不变，但位置计算中使用的大小必须通过scaleFactor进行缩放。</span></span><br><span class="line"><span class="comment">// 设置子元素的 anchorMin 和 anchorMax 为 Vector2.up，即完全沿父元素的顶部边缘对齐。</span></span><br><span class="line">    rect.anchorMin = Vector2.up;</span><br><span class="line">    rect.anchorMax = Vector2.up;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于水平轴（axis == 0）：计算公式为 pos + rect.sizeDelta[axis] * rect.pivot[axis] * scaleFactor。这将根据位置 pos、子元素的尺寸 rect.sizeDelta[axis]、子元素的中心点 rect.pivot[axis] 和缩放因子 scaleFactor 设置子元素的位置。</span></span><br><span class="line">    <span class="comment">// 对于垂直轴（axis == 1）：计算公式为 -pos - rect.sizeDelta[axis] * (1f - rect.pivot[axis]) * scaleFactor。这同样根据位置 pos、子元素的尺寸 rect.sizeDelta[axis]、子元素的中心点 rect.pivot[axis] 和缩放因子 scaleFactor 设置子元素的位置。</span></span><br><span class="line">    Vector2 anchoredPosition = rect.anchoredPosition;</span><br><span class="line">    anchoredPosition[axis] = (axis == <span class="number">0</span>) ? (pos + rect.sizeDelta[axis] * rect.pivot[axis] * scaleFactor) : (-pos - rect.sizeDelta[axis] * (<span class="number">1f</span> - rect.pivot[axis]) * scaleFactor);</span><br><span class="line">    <span class="comment">// 将计算得到的位置应用到子元素的 anchoredPosition 上，确保子元素按预期位置放置</span></span><br><span class="line">    rect.anchoredPosition = anchoredPosition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetChildAlongAxis：上面方法的重载，多了一个参数size，子布局元素的尺寸大小</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">SetChildAlongAxis</span>(<span class="params">RectTransform rect, <span class="built_in">int</span> axis, <span class="built_in">float</span> pos, <span class="built_in">float</span> size</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rect == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    SetChildAlongAxisWithScale(rect, axis, pos, size, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SetChildAlongAxisWithScale：上面方法的重载，多了一个参数size，子布局元素的尺寸大小</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">SetChildAlongAxisWithScale</span>(<span class="params">RectTransform rect, <span class="built_in">int</span> axis, <span class="built_in">float</span> pos, <span class="built_in">float</span> size, <span class="built_in">float</span> scaleFactor</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rect == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跟踪锚点和锚定位置的变化，以及根据轴的不同追踪 AnchoredPositionX 或 AnchoredPositionY 和对应的 SizeDeltaX 或 SizeDeltaY。</span></span><br><span class="line">    m_Tracker.Add(<span class="keyword">this</span>, rect,</span><br><span class="line">        DrivenTransformProperties.Anchors |</span><br><span class="line">        (axis == <span class="number">0</span> ?</span><br><span class="line">            (DrivenTransformProperties.AnchoredPositionX | DrivenTransformProperties.SizeDeltaX) :</span><br><span class="line">            (DrivenTransformProperties.AnchoredPositionY | DrivenTransformProperties.SizeDeltaY)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置子元素的 anchorMin 和 anchorMax 为 Vector2.up，即完全沿父元素的顶部边缘对齐</span></span><br><span class="line">    rect.anchorMin = Vector2.up;</span><br><span class="line">    rect.anchorMax = Vector2.up;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新子元素的 sizeDelta，将指定轴上的尺寸设置为传入的 size 值，确保子元素在该轴上具有正确的大小</span></span><br><span class="line">    Vector2 sizeDelta = rect.sizeDelta;</span><br><span class="line">    sizeDelta[axis] = size;</span><br><span class="line">    rect.sizeDelta = sizeDelta;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于水平轴（axis == 0）：计算公式为 pos + size * rect.pivot[axis] * scaleFactor。这将根据位置 pos、子元素的尺寸 size、子元素的中心点 rect.pivot[axis] 和缩放因子 scaleFactor 设置子元素的位置。</span></span><br><span class="line">    <span class="comment">// 对于垂直轴（axis == 1）：计算公式为 -pos - size * (1f - rect.pivot[axis]) * scaleFactor。这同样根据位置 pos、子元素的尺寸 size、子元素的中心点 rect.pivot[axis] 和缩放因子 scaleFactor 设置子元素的位置。</span></span><br><span class="line">    Vector2 anchoredPosition = rect.anchoredPosition;</span><br><span class="line">    anchoredPosition[axis] = (axis == <span class="number">0</span>) ? (pos + size * rect.pivot[axis] * scaleFactor) : (-pos - size * (<span class="number">1f</span> - rect.pivot[axis]) * scaleFactor);</span><br><span class="line">    <span class="comment">// 将计算得到的位置应用到子元素的 anchoredPosition 上，确保子元素按预期位置放置</span></span><br><span class="line">    rect.anchoredPosition = anchoredPosition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>isRootLayoutGroup：判断当前对象是否是布局组的根布局对象组件。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> isRootLayoutGroup</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        Transform parent = transform.parent;</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> transform.parent.GetComponent(<span class="keyword">typeof</span>(ILayoutGroup)) == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>OnRectTransformDimensionsChange：如果当前对象是根布局对象，且RectTransform发生了变化，则标记为需要进行布局重建</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnRectTransformDimensionsChange</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">base</span>.OnRectTransformDimensionsChange();</span><br><span class="line">    <span class="keyword">if</span> (isRootLayoutGroup)</span><br><span class="line">        SetDirty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>OnTransformChildrenChanged：子布局元素如果的Transform如果发生改变则标记为需要进行布局重建</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnTransformChildrenChanged</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    SetDirty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在编辑器模式下，每次对该组件的属性进行修改并保存时自动调用OnValidate方法，标记为需要进行布局重建</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnValidate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        SetDirty();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">LayoutGroup是控制子布局对象组件的基类，实现了ILayoutElement和ILayoutGroup接口，说明它既是一个布局元素也是一个布局控制器，HorizontalLayoutGroup、VerticalLayoutGroup、GridLayoutGroup都继承或间接继承了此类。</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——ILayoutIgnorer</title>
    <link href="https://azzurebubble.github.io/posts/4c1d55d0.html"/>
    <id>https://azzurebubble.github.io/posts/4c1d55d0.html</id>
    <published>2024-07-20T07:09:24.000Z</published>
    <updated>2024-07-20T09:05:24.054Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ILayoutIgnorer：挂载了实现ILayoutIgnorer接口的组件的对象可以设置不受布局系统控制，例如LayoutElement。<br><font color=red>实现ILayoutIgnorer接口的组件的作用是针对于布局组下的子对象，而不是针对于自身，例如给挂载了ContentSizeFitter组件的对象身上挂载LayoutElement组件并将ignoreLayout设置为true是没有作用的</font></p></blockquote><h4 id="源码解析">源码解析</h4><blockquote><p>ignoreLayout：返回这个布局元素的RecTransform是否应该被布局系统忽略。</p><p><font color=red>注意：需要对象身上所有挂载了ILayoutIgnorer组件中的ignoreLayout都为true的时候才会不受到布局系统控制</font></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> ignoreLayout &#123; <span class="keyword">get</span>; &#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color=red>因为只有在LayoutGroup类中引用了ILayoutIngnorer接口，LayoutGroup类是只作用与子布局元素的，所以实现了ILayoutIgnorer接口的组件的作用是针对于布局组下的子对象，而不是自身。</font></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CalculateLayoutInputHorizontal</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    m_RectChildren.Clear();</span><br><span class="line">    <span class="keyword">var</span> toIgnoreList = ListPool&lt;Component&gt;.Get();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; rectTransform.childCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> rect = rectTransform.GetChild(i) <span class="keyword">as</span> RectTransform;</span><br><span class="line">        <span class="keyword">if</span> (rect == <span class="literal">null</span> || !rect.gameObject.activeInHierarchy)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        rect.GetComponents(<span class="keyword">typeof</span>(ILayoutIgnorer), toIgnoreList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (toIgnoreList.Count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_RectChildren.Add(rect);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; toIgnoreList.Count; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> ignorer = (ILayoutIgnorer)toIgnoreList[j];</span><br><span class="line">            <span class="keyword">if</span> (!ignorer.ignoreLayout)</span><br><span class="line">            &#123;</span><br><span class="line">                m_RectChildren.Add(rect);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ListPool&lt;Component&gt;.Release(toIgnoreList);</span><br><span class="line">    m_Tracker.Clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">挂载了实现ILayoutIgnorer接口的组件对象可以设置不受布局系统控制，例如：LayoutElement</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——ILayoutSelfController</title>
    <link href="https://azzurebubble.github.io/posts/8ae908f0.html"/>
    <id>https://azzurebubble.github.io/posts/8ae908f0.html</id>
    <published>2024-07-20T07:09:15.000Z</published>
    <updated>2024-07-20T09:05:24.052Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ILayoutSelfController：继承自ILayoutController(布局控制器)，挂载了实现ILayoutSelfController的组件的对象被视为一个布局控制器，用于控制自身布局对象，例如：ContentSizeFitter、AspectRatioFitter。</p></blockquote><h4 id="源码解析">源码解析</h4><blockquote><p>继承自ILayoutController，用于驱动自身的RectTransform，调用 <code>ILayoutController.SetLayoutHorizontal</code> 处理水平布局部分，调用 <code>ILayoutController.SetLayoutVertical</code> 处理垂直布局部分。可以改变 RectTransform 的高度、宽度、位置和旋转。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ILayoutSelfController</span> : <span class="title">ILayoutController</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">继承自ILayoutController(布局控制器)，挂载了实现ILayoutSelfController的组件的对象被视为一个布局控制器，用于控制自身布局对象，例如：ContentSizeFitter、AspectRatioFitter。</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——ILayoutGroup</title>
    <link href="https://azzurebubble.github.io/posts/16a94385.html"/>
    <id>https://azzurebubble.github.io/posts/16a94385.html</id>
    <published>2024-07-20T07:09:05.000Z</published>
    <updated>2024-07-20T09:05:24.051Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ILayoutGroup：继承自ILayoutController，挂载了实现ILayoutGroup的组件的对象被视为一个布局控制器，用于控制子布局对象，驱动它的子元素的RectTransforms，例如：HorizontalLayoutGroup、VerticalLayoutGroup、GridLayoutGroup。</p></blockquote><h4 id="源码解析">源码解析</h4><blockquote><p>继承自ILayoutController</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ILayoutGroup</span> : <span class="title">ILayoutController</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">继承自ILayoutController，挂载了实现ILayoutGroup的组件的对象被视为一个布局控制器，用于控制子布局对象，例如：HorizontalLayoutGroup、VerticalLayoutGroup、GridLayoutGroup。</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——ILayoutController</title>
    <link href="https://azzurebubble.github.io/posts/21b56f8.html"/>
    <id>https://azzurebubble.github.io/posts/21b56f8.html</id>
    <published>2024-07-20T07:08:25.000Z</published>
    <updated>2024-07-20T09:05:24.048Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ILayoutController：挂载了实现ILayoutController的组件的对象被视为一个布局控制器，布局控制器用于设置布局。布局控制器可分为两种：控制自身和控制子布局元素</p></blockquote><h4 id="源码解析">源码解析</h4><blockquote><p>SetLayoutHorizontal：由自动布局系统调用的回调函数，先处理布局的水平方面</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetLayoutHorizontal</span>()</span>;</span><br></pre></td></tr></table></figure><blockquote><p>SetLayoutVertical：由自动布局系统调用的回调函数，先处理布局的垂直方面</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetLayoutVertical</span>()</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">挂载了实现ILayoutController的组件的对象被视为一个布局控制器，布局控制器用于设置布局。布局控制器可分为两种：控制自身和控制子布局元素。</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——ILayoutElement</title>
    <link href="https://azzurebubble.github.io/posts/2f5dfff6.html"/>
    <id>https://azzurebubble.github.io/posts/2f5dfff6.html</id>
    <published>2024-07-20T06:53:50.000Z</published>
    <updated>2024-07-20T09:05:24.046Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ILayoutElement：挂载了实现ILayoutElement接口的组件的对象被视为一个布局元素，<font color=red>布局元素不直接设置布局，只计算自身属性，设置布局由布局控制器设置</font></p></blockquote><h4 id="源码解析">源码解析</h4><blockquote><p>CalculateLayoutInputHorizontal：先计算水平布局的属性值，当调用这个方法时，子节点已经有了最新的水平布局输入。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CalculateLayoutInputHorizontal</span>()</span>;</span><br></pre></td></tr></table></figure><blockquote><p>CalculateLayoutInputVertical：后计算垂直布局的属性值，当调用这个方法时，子节点已经有了最新的垂直布局输入。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CalculateLayoutInputVertical</span>()</span>;</span><br></pre></td></tr></table></figure><blockquote><p>minWidth：此布局元素属性分配最小的宽度</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> minWidth &#123; <span class="keyword">get</span>; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>preferredWidth：如果有足够的空间，应该分配这个布局元素的首选宽度，preferredWidth可以设置为-1来移除大小</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> preferredWidth &#123; <span class="keyword">get</span>; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>flexibleWidth：布局元素在有额外可用空间时应该分配的额外相对宽度</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> flexibleWidth &#123; <span class="keyword">get</span>; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>minHeight：此布局元素属性分配最小的高度</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> minHeight &#123; <span class="keyword">get</span>; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>preferredHeight：如果有足够的空间，应该分配这个布局元素的首选高度，preferredHeight可以设置为-1来移除大小</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> preferredHeight &#123; <span class="keyword">get</span>; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>flexibleHeight：布局元素在有额外可用空间时应该分配的额外相对高度</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> flexibleHeight &#123; <span class="keyword">get</span>; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>layoutPriority：获取该组件的布局优先级，当一个游戏对象上的多个组件实现了ILayoutElement接口时，确定到底由哪个组件提供布局属性，值越大优先级越高，小于0的值将被忽略。通过这种方式，组件可以只重写选中的属性，让剩余的值为-1或其他小于零的值。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> layoutPriority &#123; <span class="keyword">get</span>; &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">挂载了实现ILayoutElement的组件的对象被视为一个布局元素，布局元素不直接设置布局，只计算自身属性，设置布局由布局控制器设置</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——LayoutRebuilder</title>
    <link href="https://azzurebubble.github.io/posts/52e926ac.html"/>
    <id>https://azzurebubble.github.io/posts/52e926ac.html</id>
    <published>2024-07-18T14:43:45.000Z</published>
    <updated>2024-07-20T06:47:09.980Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>LayoutRebuilder：用于管理CanvasElement布局重建的包装类，主要负责布局的刷新(UI对象位置和大小的刷新)。</p></blockquote><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>&gt;</p>]]></content>
    
    
    <summary type="html">负责布局的刷新(UI对象位置和大小的刷新)</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——CanvasUpdateRegistry</title>
    <link href="https://azzurebubble.github.io/posts/6dcd3730.html"/>
    <id>https://azzurebubble.github.io/posts/6dcd3730.html</id>
    <published>2024-07-18T14:27:22.000Z</published>
    <updated>2024-07-18T14:55:06.910Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>CanvasUpdate：用于描述在Canvas更新过程中可能发生的不同阶段</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> CanvasUpdate</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 布局更新之前调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    Prelayout = <span class="number">0</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 布局更新时调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    Layout = <span class="number">1</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 布局更新之后调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    PostLayout = <span class="number">2</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 渲染之前调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    PreRender = <span class="number">3</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 渲染之前完成后调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    LatePreRender = <span class="number">4</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 表示枚举的范围，边界检测或者迭代</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    MaxUpdateValue = <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ICanvasElement：图像、布局重建接口。几乎所有UI对象都继承自ICanvasElement接口，一个UI对象若要重建都需要继承自ICanvasElement接口。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICanvasElement</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 重构方法，需要在继承类中实现，Graphic和LayoutRebuilder继承了此接口</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;executing&quot;&gt;</span>正在重建的当前的CanvasUpdate阶段<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">Rebuild</span>(<span class="params">CanvasUpdate executing</span>)</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 每个UI都继承自UIBehaviour类，UIBehaviour继承自MonoBehaviour，MonoBehaviour继承自Component类，而Component类实现了transform属性，所以子类可以不再实现这个属性</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     Transform transform &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 布局完成的回调函数</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">LayoutComplete</span>()</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 图像更新完成的回调函数</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">GraphicUpdateComplete</span>()</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 获取UI对象是否销毁</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">     <span class="function"><span class="built_in">bool</span> <span class="title">IsDestroyed</span>()</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>CanvasUpdateRegistry：是一个单例，它监听了Canvas即将渲染的事件，并调用已注册对象的Rebuild、LayoutComplete、GraphicUpdateComplete方法，<font color=red>而其中的Rebuild方法就是每个UI元素的刷新方法。</font></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例获取</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CanvasUpdateRegistry s_Instance;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CanvasUpdateRegistry instance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s_Instance == <span class="literal">null</span>)</span><br><span class="line">            s_Instance = <span class="keyword">new</span> CanvasUpdateRegistry();</span><br><span class="line">        <span class="keyword">return</span> s_Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数：给Canvas的静态事件willRenderCanvases注册一个名为PerformUpdate的方法</span></span><br><span class="line"><span class="comment">// (willRenderCanvases每帧在Canvas渲染前执行)，PerformUpdate中调用了布局和图像的更新</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">CanvasUpdateRegistry</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Canvas.willRenderCanvases += PerformUpdate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个标记是否在进行布局或图像更新的字段</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> m_PerformingLayoutUpdate;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> m_PerformingGraphicUpdate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于在性能分析器中识别和记录Canvas更新过程中的不同阶段的标识符</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span>[] m_CanvasUpdateProfilerStrings = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;CanvasUpdate.Prelayout&quot;</span>, <span class="string">&quot;CanvasUpdate.Layout&quot;</span>, <span class="string">&quot;CanvasUpdate.PostLayout&quot;</span>, <span class="string">&quot;CanvasUpdate.PreRender&quot;</span>, <span class="string">&quot;CanvasUpdate.LatePreRender&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 用于在性能分析器或调试器中标识剪切器注册表中执行裁剪的标识符</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> m_CullingUpdateProfilerString = <span class="string">&quot;ClipperRegistry.Cull&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 布局重建序列和图像重建序列</span></span><br><span class="line"><span class="comment">// 当需要更新布局或图像时，可以调用RegisterCanvasElementForLayoutRebuild和</span></span><br><span class="line"><span class="comment">// RegisterCanvasElementForGraphicRebuild两个方法将对象添加到对应的重建序列中</span></span><br><span class="line"><span class="comment">// PerformUpdate方法会调用Rebuild方法对这两个序列中中的对象进行更新操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> IndexedSet&lt;ICanvasElement&gt; m_LayoutRebuildQueue = <span class="keyword">new</span> IndexedSet&lt;ICanvasElement&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> IndexedSet&lt;ICanvasElement&gt; m_GraphicRebuildQueue = <span class="keyword">new</span> IndexedSet&lt;ICanvasElement&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查指定的Canvas元素是否是Unity的Object，是否可以进行有效更新</span></span><br><span class="line"><span class="comment">// Object是Unity所有对象的基类，object是C#中所有对象的基类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">ObjectValidForUpdate</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> valid = element != <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> isUnityObject = element <span class="keyword">is</span> Object;</span><br><span class="line">    <span class="keyword">if</span> (isUnityObject)</span><br><span class="line">        valid = (element <span class="keyword">as</span> Object) != <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> valid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理两个队列中的无效元素</span></span><br><span class="line"><span class="comment">// MonoBehaviour对空值相等性重载了==操作符，用于检查他们是否被销毁</span></span><br><span class="line"><span class="comment">// 这段代码中处理的是一个ICanvasElement接口类型的列表，而不是具体的MonoBehaviour类型</span></span><br><span class="line"><span class="comment">// 因此直接使用==操作符不能直接转发到MonoBehaviour，而只是检查接口本身是否为null</span></span><br><span class="line"><span class="comment">// IsDestroyed()方法用于检查元素的后端是否被销毁</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CleanInvalidItems</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> layoutRebuildQueueCount = m_LayoutRebuildQueue.Count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = layoutRebuildQueueCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> item = m_LayoutRebuildQueue[i];</span><br><span class="line">        <span class="comment">// 元素是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (item == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_LayoutRebuildQueue.RemoveAt(i);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 元素是否被销毁</span></span><br><span class="line">        <span class="keyword">if</span> (item.IsDestroyed())</span><br><span class="line">        &#123;</span><br><span class="line">            m_LayoutRebuildQueue.RemoveAt(i);</span><br><span class="line">            item.LayoutComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> graphicRebuildQueueCount = m_GraphicRebuildQueue.Count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = graphicRebuildQueueCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> item = m_GraphicRebuildQueue[i];</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_GraphicRebuildQueue.RemoveAt(i);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (item.IsDestroyed())</span><br><span class="line">        &#123;</span><br><span class="line">            m_GraphicRebuildQueue.RemoveAt(i);</span><br><span class="line">            item.GraphicUpdateComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算指定Transform对象的父级层级数目</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">ParentCount</span>(<span class="params">Transform child</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> parent = child.parent;</span><br><span class="line">    <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (parent != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        parent = parent.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个元素的祖先层级深度，祖先层级深度越深，则排在列表的更后面</span></span><br><span class="line"><span class="comment">// 决定元素的布局和图像重建顺序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">SortLayoutList</span>(<span class="params">ICanvasElement x, ICanvasElement y</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Transform t1 = x.transform;</span><br><span class="line">    Transform t2 = y.transform;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ParentCount(t1) - ParentCount(t2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个Canvas元素注册到布局重建队列中，一个带返回值一个不带返回值方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RegisterCanvasElementForLayoutRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    instance.InternalRegisterCanvasElementForLayoutRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">TryRegisterCanvasElementForLayoutRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> instance.InternalRegisterCanvasElementForLayoutRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">InternalRegisterCanvasElementForLayoutRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断元素是否存在布局重建队列中</span></span><br><span class="line">    <span class="keyword">if</span> (m_LayoutRebuildQueue.Contains(element))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 向布局重建队列中添加元素，确保不会重复添加</span></span><br><span class="line">    <span class="keyword">return</span> m_LayoutRebuildQueue.AddUnique(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个Canvas元素注册到图像重建队列中，一个带返回值一个不带返回值方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RegisterCanvasElementForGraphicRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    instance.InternalRegisterCanvasElementForGraphicRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">TryRegisterCanvasElementForGraphicRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> instance.InternalRegisterCanvasElementForGraphicRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">InternalRegisterCanvasElementForGraphicRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 是否正在进行图像重建更新操作，是的话将不会将元素添加到图像重建队列中</span></span><br><span class="line">    <span class="keyword">if</span> (m_PerformingGraphicUpdate)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="built_in">string</span>.Format(<span class="string">&quot;Trying to add &#123;0&#125; for graphic rebuild while we are already inside a graphic rebuild loop. This is not supported.&quot;</span>, element));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 向图像重建队列中添加元素，确保不会重复添加</span></span><br><span class="line">    <span class="keyword">return</span> m_GraphicRebuildQueue.AddUnique(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从布局和重建的队列中移除指定的Canvas元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnRegisterCanvasElementForRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    instance.InternalUnRegisterCanvasElementForLayoutRebuild(element);</span><br><span class="line">    instance.InternalUnRegisterCanvasElementForGraphicRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InternalUnRegisterCanvasElementForLayoutRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果正在进行布局重建更新操作，将不会移除指定元素</span></span><br><span class="line">    <span class="keyword">if</span> (m_PerformingLayoutUpdate)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="built_in">string</span>.Format(<span class="string">&quot;Trying to remove &#123;0&#125; from rebuild list while we are already inside a rebuild loop. This is not supported.&quot;</span>, element));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 调用元素的布局重建完成函数</span></span><br><span class="line">    element.LayoutComplete();</span><br><span class="line">    <span class="comment">// 从布局重建队列中移除元素</span></span><br><span class="line">    instance.m_LayoutRebuildQueue.Remove(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InternalUnRegisterCanvasElementForGraphicRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果正在进行图像重建更新操作，将不会移除指定元素</span></span><br><span class="line">    <span class="keyword">if</span> (m_PerformingGraphicUpdate)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="built_in">string</span>.Format(<span class="string">&quot;Trying to remove &#123;0&#125; from rebuild list while we are already inside a rebuild loop. This is not supported.&quot;</span>, element));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用元素的图像重建完成函数</span></span><br><span class="line">    element.GraphicUpdateComplete();</span><br><span class="line">    <span class="comment">// 从图像重建队列中移除元素</span></span><br><span class="line">    instance.m_GraphicRebuildQueue.Remove(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从布局和重建的队列中禁用指定的Canvas元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DisableCanvasElementForRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    instance.InternalDisableCanvasElementForLayoutRebuild(element);</span><br><span class="line">    instance.InternalDisableCanvasElementForGraphicRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InternalDisableCanvasElementForLayoutRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果正在进行布局重建更新操作，将不会禁用指定元素</span></span><br><span class="line">    <span class="keyword">if</span> (m_PerformingLayoutUpdate)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="built_in">string</span>.Format(<span class="string">&quot;Trying to remove &#123;0&#125; from rebuild list while we are already inside a rebuild loop. This is not supported.&quot;</span>, element));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 调用元素的布局重建完成函数</span></span><br><span class="line">    element.LayoutComplete();</span><br><span class="line">    <span class="comment">// 禁用指定元素</span></span><br><span class="line">    instance.m_LayoutRebuildQueue.DisableItem(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InternalDisableCanvasElementForGraphicRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果正在进行图像重建更新操作，将不会禁用指定元素</span></span><br><span class="line">    <span class="keyword">if</span> (m_PerformingGraphicUpdate)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="built_in">string</span>.Format(<span class="string">&quot;Trying to remove &#123;0&#125; from rebuild list while we are already inside a rebuild loop. This is not supported.&quot;</span>, element));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用元素的图像重建完成函数</span></span><br><span class="line">    element.GraphicUpdateComplete();</span><br><span class="line">    <span class="comment">// 禁用指定元素</span></span><br><span class="line">    instance.m_GraphicRebuildQueue.DisableItem(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前是否正在计算图形布局</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsRebuildingLayout</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> instance.m_PerformingLayoutUpdate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当前是否正在重建图形</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsRebuildingGraphics</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> instance.m_PerformingGraphicUpdate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接下来着重分析CanvasUpdateRegistry中的PerformUpdate方法的内部实现和执行顺序。<font color=red>可以在Profiler中通过查看标志性函数Canvas.willRenderCanvases的耗时，来了解重建的性能消耗</font></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先定义一个静态只读的比较函数委托</span></span><br><span class="line"><span class="comment">// Comparison&lt;T&gt;是C#已经预定义好的一个用于比较两个类型为T的对象并返回整数的委托</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Comparison&lt;ICanvasElement&gt; s_SortLayoutFunction = SortLayoutList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PerformUpdate</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 用于在代码块开始和结束时记录性能样本，监测布局更新的性能</span></span><br><span class="line">    UISystemProfilerApi.BeginSample(UISystemProfilerApi.SampleType.Layout);</span><br><span class="line">    <span class="comment">// 清理无效的元素或数据</span></span><br><span class="line">    CleanInvalidItems();</span><br><span class="line"><span class="comment">// 标记正在进行布局更新操作</span></span><br><span class="line">    m_PerformingLayoutUpdate = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 对布局重建队列中的元素进行排序</span></span><br><span class="line">    m_LayoutRebuildQueue.Sort(s_SortLayoutFunction);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= (<span class="built_in">int</span>)CanvasUpdate.PostLayout; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 标记每一个元素的性能分析</span></span><br><span class="line">        UnityEngine.Profiling.Profiler.BeginSample(m_CanvasUpdateProfilerStrings[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; m_LayoutRebuildQueue.Count; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> rebuild = m_LayoutRebuildQueue[j];</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 判断元素是否是有效元素</span></span><br><span class="line">                <span class="comment">// 对布局重建序列中的每一个元素进行CanvasUpdate的每个阶段更新</span></span><br><span class="line">                <span class="keyword">if</span> (ObjectValidForUpdate(rebuild))</span><br><span class="line">                    rebuild.Rebuild((CanvasUpdate)i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogException(e, rebuild.transform);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        UnityEngine.Profiling.Profiler.EndSample();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m_LayoutRebuildQueue.Count; ++i)</span><br><span class="line">        <span class="comment">// 调用布局重建完成函数</span></span><br><span class="line">        m_LayoutRebuildQueue[i].LayoutComplete();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空布局重建列表，并修改布局重建标志为false</span></span><br><span class="line">    m_LayoutRebuildQueue.Clear();</span><br><span class="line">    m_PerformingLayoutUpdate = <span class="literal">false</span>;</span><br><span class="line">    UISystemProfilerApi.EndSample(UISystemProfilerApi.SampleType.Layout);</span><br><span class="line">    UISystemProfilerApi.BeginSample(UISystemProfilerApi.SampleType.Render);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now layout is complete do culling...</span></span><br><span class="line">    UnityEngine.Profiling.Profiler.BeginSample(m_CullingUpdateProfilerString);</span><br><span class="line">    <span class="comment">// 执行实际的裁剪操作</span></span><br><span class="line">    ClipperRegistry.instance.Cull();</span><br><span class="line">    UnityEngine.Profiling.Profiler.EndSample();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记正在进行图像更新操作</span></span><br><span class="line">    m_PerformingGraphicUpdate = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = (<span class="built_in">int</span>)CanvasUpdate.PreRender; i &lt; (<span class="built_in">int</span>)CanvasUpdate.MaxUpdateValue; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        UnityEngine.Profiling.Profiler.BeginSample(m_CanvasUpdateProfilerStrings[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; m_GraphicRebuildQueue.Count; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> element = m_GraphicRebuildQueue[k];</span><br><span class="line">                <span class="comment">// 判断元素是否是有效元素</span></span><br><span class="line">                <span class="comment">// 对布局重建序列中的每一个元素进行CanvasUpdate的每个阶段更新</span></span><br><span class="line">                <span class="keyword">if</span> (ObjectValidForUpdate(element))</span><br><span class="line">                    element.Rebuild((CanvasUpdate)i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogException(e, m_GraphicRebuildQueue[k].transform);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        UnityEngine.Profiling.Profiler.EndSample();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m_GraphicRebuildQueue.Count; ++i)</span><br><span class="line">        <span class="comment">// 调用图像重建完成函数</span></span><br><span class="line">        m_GraphicRebuildQueue[i].GraphicUpdateComplete();</span><br><span class="line"><span class="comment">// 清空图像重建序列 并修改图像重建标志为false</span></span><br><span class="line">    m_GraphicRebuildQueue.Clear();</span><br><span class="line">    m_PerformingGraphicUpdate = <span class="literal">false</span>;</span><br><span class="line">    UISystemProfilerApi.EndSample(UISystemProfilerApi.SampleType.Render);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">图像、布局重建注册器</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——ClipperRegistry</title>
    <link href="https://azzurebubble.github.io/posts/c266fbd7.html"/>
    <id>https://azzurebubble.github.io/posts/c266fbd7.html</id>
    <published>2024-07-18T01:46:53.000Z</published>
    <updated>2024-07-18T14:53:52.573Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ClipperRegister：是一个裁剪注册器单例，用于跟踪场景中存在的所有IClipper。</p><p>这在CanvasUpdate循环期间用于剔除可剪裁元素。剪裁在布局之后但在图形更新之前调用。</p></blockquote><h4 id="源码解析">源码解析</h4><blockquote><p>单例</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例获取</span></span><br><span class="line"><span class="keyword">static</span> ClipperRegistry s_Instance;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ClipperRegistry instance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s_Instance == <span class="literal">null</span>)</span><br><span class="line">            s_Instance = <span class="keyword">new</span> ClipperRegistry();</span><br><span class="line">        <span class="keyword">return</span> s_Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>保护类型的构造函数，这里面声明了一个空的带有具体类型的字典，是为了在AOT平台中能够识别使用前面说到的IndexedSet自定义容器中的字典容器。</p><p>类型的可参考xLua热更新就需要给每个泛型容器预先定义一个空的具体类型的容器。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ClipperRegistry</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> disable 168</span></span><br><span class="line">    Dictionary&lt;IClipper, <span class="built_in">int</span>&gt; emptyIClipperDic;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> restore 168</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Register：将裁剪对象添加到m_Clippers序列中</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Register</span>(<span class="params">IClipper c</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    instance.m_Clippers.AddUnique(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Cull：对所有注册的IClipper执行剪辑，在CanvasUpdateRegistry类中的PerformUpdate中调用了这个方法，可回顾查看</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Cull</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; m_Clippers.Count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Clippers[i].PerformClipping();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Unregister：取消注册的IClipper元素</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Unregister</span>(<span class="params">IClipper c</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">instance.m_Clippers.Remove(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一个裁剪注册器单例</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——IClipper</title>
    <link href="https://azzurebubble.github.io/posts/75a13096.html"/>
    <id>https://azzurebubble.github.io/posts/75a13096.html</id>
    <published>2024-07-17T13:10:49.000Z</published>
    <updated>2024-07-18T14:55:39.867Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>IClipper：裁剪接口（裁剪者），RectMask2D继承此接口</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子类实现PerformClipping</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IClipper</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 函数用于筛选/剪辑子元素</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> CanvasUpdateRegistry类中的PerformUpdate里调用了Cull方法执行裁剪</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 在Canvas更新循环的布局之后和图形更新之前调用</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">PerformClipping</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">裁剪接口（裁剪者）</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——IndexedSet</title>
    <link href="https://azzurebubble.github.io/posts/ad6295b1.html"/>
    <id>https://azzurebubble.github.io/posts/ad6295b1.html</id>
    <published>2024-07-17T13:00:16.000Z</published>
    <updated>2024-07-18T14:55:34.060Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>IndexedSet：</p><p>优点：保证容器元素的唯一性，快速随机移除，快速唯一的添加元素到容器尾部，顺序访问</p><p>缺点：使用更多的内存，排序不是持久化的，不支持序列化</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当删除时，我们将最后一项移动到删除项的位置，这样我们只需要更新单个项的索引缓存。(快速删除)</span></span><br><span class="line"><span class="comment">// 不保证元素的顺序。移除将改变项目的顺序。</span></span><br><span class="line"><span class="keyword">readonly</span> List&lt;T&gt; m_List = <span class="keyword">new</span> List&lt;T&gt;();</span><br><span class="line"><span class="comment">// 使用字典来加速列表的查找，这也保证了列表中元素的唯一性</span></span><br><span class="line">Dictionary&lt;T, <span class="built_in">int</span>&gt; m_Dictionary = <span class="keyword">new</span> Dictionary&lt;T, <span class="built_in">int</span>&gt;();</span><br></pre></td></tr></table></figure><blockquote><p>Add：添加元素到列表中</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">T item</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 添加元素到List中</span></span><br><span class="line">    m_List.Add(item);</span><br><span class="line">    <span class="comment">// 以元素作为key，列表中的下标作为value</span></span><br><span class="line">    m_Dictionary.Add(item, m_List.Count - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>AddUnique：确保列表中的元素的唯一性的添加方法</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">AddUnique</span>(<span class="params">T item</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断字典中是否存在key</span></span><br><span class="line">    <span class="keyword">if</span> (m_Dictionary.ContainsKey(item))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    不存在则添加</span><br><span class="line">    m_List.Add(item);</span><br><span class="line">    m_Dictionary.Add(item, m_List.Count - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Remove：删除列表中的元素</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Remove</span>(<span class="params">T item</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 取出对应元素在List中的下标位置</span></span><br><span class="line">    <span class="built_in">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!m_Dictionary.TryGetValue(item, <span class="keyword">out</span> index))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 删除List中该下标元素</span></span><br><span class="line">    RemoveAt(index);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实现以下两个方法以提供foreach遍历</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IEnumerator&lt;T&gt; <span class="title">GetEnumerator</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> System.NotImplementedException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IEnumerator IEnumerable.GetEnumerator()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> GetEnumerator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Clear：清空这个容器类</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Clear</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    m_List.Clear();</span><br><span class="line">    m_Dictionary.Clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Contains：查询是否存在某元素</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Contains</span>(<span class="params">T item</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_Dictionary.ContainsKey(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CopyTo：将此容器复制到一个泛型数组中</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定类型的数组 数组索引</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CopyTo</span>(<span class="params">T[] array, <span class="built_in">int</span> arrayIndex</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    m_List.CopyTo(array, arrayIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Count：获得容器大小</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> Count &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_List.Count; &#125; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>IsReadOnly：容器是否只读，这里为不是</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> IsReadOnly &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>Insert：因为语义可能很奇怪，顺序不能保证，所以在这个容器没有实现支持</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span>(<span class="params"><span class="built_in">int</span> index, T item</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NotSupportedException(<span class="string">&quot;Random Insertion is semantically invalid, since this structure does not guarantee ordering.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>RemoveAt：删除指定下标的元素</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveAt</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 找到该下标元素</span></span><br><span class="line">    T item = m_List[index];</span><br><span class="line">    <span class="comment">// 删除字典中的对应值</span></span><br><span class="line">    m_Dictionary.Remove(item);</span><br><span class="line">    <span class="keyword">if</span> (index == m_List.Count - <span class="number">1</span>)</span><br><span class="line">        m_List.RemoveAt(index);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果该下标不是列表的最后一个元素</span></span><br><span class="line">        <span class="comment">// 则将该元素替换到列表的最后一个元素</span></span><br><span class="line">        <span class="comment">// 再进行删除操作</span></span><br><span class="line">        <span class="built_in">int</span> replaceItemIndex = m_List.Count - <span class="number">1</span>;</span><br><span class="line">        T replaceItem = m_List[replaceItemIndex];</span><br><span class="line">        m_List[index] = replaceItem;</span><br><span class="line">        m_Dictionary[replaceItem] = index;</span><br><span class="line">        m_List.RemoveAt(replaceItemIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>索引器实现</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_List[index]; &#125;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">        T item = m_List[index];</span><br><span class="line">        m_Dictionary.Remove(item);</span><br><span class="line">        m_List[index] = <span class="keyword">value</span>;</span><br><span class="line">        m_Dictionary.Add(item, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>RemoveAll：</p><ul><li><p><code>Predicate&lt;T&gt; match</code> 是一个委托，它表示一个方法或 Lambda 表达式，用来确定是否移除列表中的元素。</p></li><li><p>作者提到了一种可能的优化方法，即将需要移除的元素移动到列表的末尾，然后一次性进行移除操作。这种方法可能减少了移动元素的次数，但需要额外的逻辑来管理移动元素和一次性移除的操作。</p></li><li><p>现在的实现方式虽然简单，但如果列表中的元素较多或者频繁调用 <code>RemoveAll</code> 方法，可能会成为性能的瓶颈。</p></li></ul></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveAll</span>(<span class="params">Predicate&lt;T&gt; match</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; m_List.Count)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 判断元素是否匹配传入的委托，匹配则删除</span></span><br><span class="line">        T item = m_List[i];</span><br><span class="line">        <span class="keyword">if</span> (match(item))</span><br><span class="line">            Remove(item);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Sort:</p><ul><li>对内部列表进行排序，这使得暴露的索引访问器也排序。</li><li>但是注意，任何插入或删除都可以再次打乱集合的顺序。</li><li>由上面的插入和删除代码可知道，会打乱排序，所以这个容器的排序不是持久化的</li></ul></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Sort</span>(<span class="params">Comparison&lt;T&gt; sortLayoutFunction</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可能有更好的排序方法，并使得字典的索引保持最新</span></span><br><span class="line">    m_List.Sort(sortLayoutFunction);</span><br><span class="line">    <span class="comment">// 重建字典的索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m_List.Count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        T item = m_List[i];</span><br><span class="line">        m_Dictionary[item] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">UGUI中继承IList实现特定功能的容器</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——UIBehaviour</title>
    <link href="https://azzurebubble.github.io/posts/45311df6.html"/>
    <id>https://azzurebubble.github.io/posts/45311df6.html</id>
    <published>2024-07-15T15:07:52.000Z</published>
    <updated>2024-07-16T14:32:24.539Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>UIBehaviour：是所有UI组件的基类，UI组件都是直接或者间接继承UIBehaviour这个抽象类，<font color=red>它继承自MonoBehaviour，所以拥有和Unity相同的生命周期。</font></p></blockquote><h4 id="源码解析">源码解析</h4><blockquote><p>只会在物体创建时执行一次 ，与Mono Awake调用时机和次数保持一致</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在物体显示时执行一次，与Mono OnEnable一致</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在物体第一次激活时执行一次，在Awake之后，第一帧Update之前执行，与Mono Start一致</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Start</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在物体隐藏时执行一次，与Mono OnDisable 一致</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在当前界面被销毁时调用一次，与Mono Destroy一致</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在编辑器模式下：当脚本被加载(禁用或启用)或者Inspector窗口的值出现变化的时候会被调用，使用时添加#if UNITY_EDITOR</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnValidate</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在编辑器模式下：当脚本恢复默认值时调用，使用时添加#if UNITY_EDITOR</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Reset</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当RectTransform变化时候调用，Anchors、Pivot、Width、Height变化时调用，Transform、Rotation、Scale变化时不调用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnRectTransformDimensionsChange</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在父物体变化之前调用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnBeforeTransformParentChanged</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在父物体变化之后调用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnTransformParentChanged</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在Canvas状态变化时调用，比如禁用Canvas组件</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnDidApplyAnimationProperties</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在Canvas Group变化时调用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnCanvasGroupChanged</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当应用动画属性时调用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnCanvasHierarchyChanged</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>获取GameObject和Component是否处于激活状态</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> <span class="title">IsActive</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> isActiveAndEnabled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>获取GameObject和Component是否被销毁</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsDestroyed</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">UI组件的基类，继承MonoBehaviour</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——目录</title>
    <link href="https://azzurebubble.github.io/posts/42c102bd.html"/>
    <id>https://azzurebubble.github.io/posts/42c102bd.html</id>
    <published>2024-07-05T03:33:56.000Z</published>
    <updated>2024-07-20T09:09:27.058Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://azurebubble.github.io/posts/45311df6.html"><strong>UGUI源码解析——UIBehaviour</strong></a></p><blockquote><p>UIBehaviour：UI组件的基类，继承MonoBehaviour</p></blockquote><p><a href="https://azurebubble.github.io/posts/ad6295b1.html"><strong>UGUI源码解析——IndexedSet</strong></a></p><blockquote><p>IndexedSet：UGUI中继承IList实现特定功能的容器</p></blockquote><p><a href="https://azurebubble.github.io/posts/ad6295b1.html"><strong>UGUI源码解析——IndexedSet</strong></a></p><blockquote><p>IndexedSet：UGUI中继承IList实现特定功能的容器</p></blockquote><p><a href="https://azurebubble.github.io/posts/75a13096.html"><strong>UGUI源码解析——IClipper</strong></a></p><blockquote><p>IClipper：裁剪接口（裁剪者）</p></blockquote><p><a href="https://azurebubble.github.io/posts/c266fbd7.html"><strong>UGUI源码解析——ClipperRegistry</strong></a></p><blockquote><p>ClipperRegistry：一个裁剪注册器单例</p></blockquote><p><a href="https://azurebubble.github.io/posts/6dcd3730.html"><strong>UGUI源码解析——CanvasUpdateRegistry</strong></a></p><blockquote><p>CanvasUpdateRegistry：图像、布局重建注册器</p></blockquote><p><a href="https://azurebubble.github.io/posts/2f5dfff6.html"><strong>UGUI源码解析——ILayoutElement</strong></a></p><blockquote><p>ILayoutElement：挂载了实现ILayoutElement的组件的对象被视为一个布局元素，布局元素不直接设置布局，只计算自身属性，设置布局由布局控制器设置</p></blockquote><p><a href="https://azurebubble.github.io/posts/21b56f8.html"><strong>UGUI源码解析——ILayoutController</strong></a></p><blockquote><p>ILayoutController：挂载了实现ILayoutController的组件的对象被视为一个布局控制器，布局控制器用于设置布局。布局控制器可分为两种：控制自身和控制子布局元素</p></blockquote><p><a href="https://azurebubble.github.io/posts/16a94385.html"><strong>UGUI源码解析——ILayoutGroup</strong></a></p><blockquote><p>ILayoutGroup：继承自ILayoutController，挂载了实现ILayoutGroup的组件的对象被视为一个布局控制器，用于控制子布局对象，例如：HorizontalLayoutGroup、VerticalLayoutGroup、GridLayoutGroup</p></blockquote><p><a href="https://azurebubble.github.io/posts/8ae908f0.html"><strong>UGUI源码解析——ILayoutSelfController</strong></a></p><blockquote><p>ILayoutSelfController：继承自ILayoutController(布局控制器)，挂载了实现ILayoutSelfController的组件的对象被视为一个布局控制器，用于控制自身布局对象，例如：ContentSizeFitter、AspectRatioFitter</p></blockquote><p><a href="https://azurebubble.github.io/posts/4c1d55d0.html"><strong>UGUI源码解析——ILayoutIgnorer</strong></a></p><blockquote><p>ILayoutIgnorer：挂载了实现ILayoutIgnorer接口的组件对象可以设置不受布局系统控制，例如：LayoutElement</p></blockquote><p><a href="https://azurebubble.github.io/posts/51e1a8f9.html"><strong>UGUI源码解析——LayoutGroup</strong></a></p><blockquote><p>LayoutGroup：LayoutGroup是控制子布局对象组件的基类，实现了ILayoutElement和ILayoutGroup接口，说明它既是一个布局元素也是一个布局控制器，HorizontalLayoutGroup、VerticalLayoutGroup、GridLayoutGroup都继承或间接继承了此类</p></blockquote><p><a href="https://azurebubble.github.io/posts/52e926ac.html"><strong>UGUI源码解析——LayoutRebuilder</strong></a></p><blockquote><p>LayoutRebuilder：主要负责布局的刷新(UI对象位置和大小的刷新)</p></blockquote>]]></content>
    
    
    <summary type="html">这是一篇阅读分析UGUI源码的文章分享，欢迎大佬指正，一起学习</summary>
    
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/C/"/>
    
    <category term="学习" scheme="https://azzurebubble.github.io/categories/C/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/C/%E5%AD%A6%E4%B9%A0/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    <category term="Unity3D" scheme="https://azzurebubble.github.io/tags/Unity3D/"/>
    
  </entry>
  
  <entry>
    <title>Untiy游戏框架QZGameFramework</title>
    <link href="https://azzurebubble.github.io/posts/3e60956b.html"/>
    <id>https://azzurebubble.github.io/posts/3e60956b.html</id>
    <published>2024-01-06T10:13:46.000Z</published>
    <updated>2024-07-05T03:39:10.984Z</updated>
    
    <content type="html"><![CDATA[<h3 id="框架仓库链接——《QZGameFramework》">框架仓库链接——<a href="https://github.com/AzureBubble/QZGameFramework"><strong>《QZGameFramework》</strong></a></h3><blockquote><p>本框架的基础是在本人参加多个项目，并且查阅积累了各类优秀代码后，自己总结优化的一个较为通用且易用的简易游戏框架，并会在未来自我能力提升的同时继续优化更新此框架，目标是一个适用于新手入门和中小公司节约成本的前提下的涵盖前后端Unity游戏框架(目前后端服务器还在学习中…)。</p></blockquote><h3 id="Unity-Editor-编辑器工具">Unity Editor 编辑器工具</h3><blockquote><p>本框架中的工具是原创+魔改实现的。</p></blockquote><h4 id="ExcelTool-——-读取-Excel-配置表工具">ExcelTool —— 读取 Excel 配置表工具</h4><blockquote><p>主要包含两种读表方式：Json和Binary。可自定义存储路径。</p><p>配置表规则<br>第一行：字段名(如修改规则，请更改 ExcelTool 脚本中的 BEGIN_VARIABLE_NAME_INDEX 变量)<br>第二行：字段类型(字段类型支持：int,float,bool,string)<br>如需增加新的字段类型读写规则，请在任务列表中找到对应的位置添加对应字段类型处理规则即可<br>(如修改规则，请更改 ExcelTool 脚本中的 BEGIN_VARIABLE_TYPE_INDEX 变量)<br>第三行：主键(key)，通过key来标识唯一主键(Json文件默认 id 为主键，不以自定义key为规则)<br>(如修改规则，请更改 ExcelTool 脚本中的 BEGIN_KEY_INDEX 变量)<br>第四行：描述信息(可选：增加注释，便于阅读理解)<br>(如修改规则，请更改 ExcelTool 脚本中的 BEGIN_DESCRIPTION_INDEX 变量)<br>第五行~第n行：具体数据信息<br>Excel 下的表名决定数据结构类名，容器类名，二进制文件名<br>(如修改规则，请更改 ExcelTool 脚本中的 BEGIN_INDEX 变量)</p><p>目前只支持int、float、bool、string四种数据类型配置表读取，如需增加，可直接打开ExcelTool脚本找到TODO任务列表添加即可。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/QZGameFramework/ExcelTool1.png" alt="ExcelTool1"></p><h4 id="ABTool-——-资源服务器AB包上传工具">ABTool —— 资源服务器AB包上传工具</h4><blockquote><p>本工具提供了AB包一键上传AB资源文件到指定资源服务器。使用的是MD5码加密生成的AB包对比文件。下载配合使用ABUpdateMgr脚本使用即可。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/QZGameFramework/ABTool1.png" alt="ABTool1"></p><h4 id="LuaTool-——-Lua脚本一键生成txt后缀并移动到指定AB包和文件夹工具">LuaTool —— Lua脚本一键生成txt后缀并移动到指定AB包和文件夹工具</h4><blockquote><p>本工具是为了方便Lua文件的迁移。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/QZGameFramework/LuaTool1.png" alt="LuaTool1"></p><h4 id="DialogueTool-——-对话树编辑器工具">DialogueTool —— 对话树编辑器工具</h4><blockquote><p>利用树的特性和UIToolkit编写的一个对话树插件，快速编辑剧情对话分支。对应的每个节点的具体行为逻辑，继承顺序节点和分支节点的基类重写对应方法即可。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/QZGameFramework/DialogueTreeTool.png" alt="DialogueTreeTool"></p><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/QZGameFramework/DialogueTreeTool1.png" alt="DialogueTreeTool"></p><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/QZGameFramework/DialogueTreeTool2.png" alt="DialogueTreeTool"></p><h4 id="BehaviourTreeTool-——-行为树编辑器">BehaviourTreeTool —— 行为树编辑器</h4><blockquote><p>一个简单的可视化行为树编辑器工具，自定义节点，只需要继承指定的Action类，decoration等节点类即可。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/QZGameFramework/BehaviourTool1.png" alt="BehaviourTool"></p><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/QZGameFramework/BehaviourTool2.png" alt="BehaviourTool"></p><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/QZGameFramework/BehaviourTool3.png" alt="BehaviourTool"></p><h3 id="Unity框架">Unity框架</h3><h4 id="成就管理器">成就管理器</h4><blockquote><p>一个简易的使用观察者实现的成就系统，待完善。</p></blockquote><h4 id="事件中心模块">事件中心模块</h4><blockquote><p>分发消息</p></blockquote><h4 id="有限状态机模块">有限状态机模块</h4><blockquote><p>通用的FSM系统：状态包含一个数据黑板。</p></blockquote><h4 id="输入系统">输入系统</h4><blockquote><p>命令模式实现的一个旧输入系统监听操纵。</p></blockquote><h4 id="背包系统">背包系统</h4><blockquote><p>待完善</p></blockquote><h4 id="音乐管理系统">音乐管理系统</h4><blockquote><p>结合对象池和资源加载模块实现的音乐管理器</p></blockquote><h4 id="对象池模块">对象池模块</h4><blockquote></blockquote><h4 id="包管理器模块">包管理器模块</h4><h4 id="数据持久化模块">数据持久化模块</h4><h4 id="场景切换管理器">场景切换管理器</h4><h4 id="单例模式管理器">单例模式管理器</h4><blockquote><p>这是一个管理全局所有单例的模块：管理全局所有的单例，相对于传统的单例模式创建，这样更便于对单例的管理和销毁，且如果需要进行帧更新的单例可以继承IUpdateSingleton接口即可实现单例帧更新函数OnUpdate，且这个帧更新的单例可以单独设置优先级，控制单例的帧更新顺序。</p></blockquote><h4 id="自动化UI框架">自动化UI框架</h4><blockquote><p>搭建好界面后，一键生成通用UI窗口脚本和UI元素脚本并挂载在窗口GameObject上</p></blockquote><h4 id="Timer计时器">Timer计时器</h4><h4 id="SceneName特性">SceneName特性</h4><blockquote><p>[SceneName]特性标记string变量，可快速在Inspector窗口通过下拉框选择场景</p></blockquote><h4 id="ReadOnly特性">ReadOnly特性</h4><blockquote><p>编辑在Inspector显示但只读的变量属性，可通过后面的单选框开启关闭只读绘制。</p></blockquote>]]></content>
    
    
    <summary type="html">这是一个自研框架，目前适用大部分Unity游戏开发，欠缺AB包模块和热更模块。</summary>
    
    
    
    <category term="框架搭建" scheme="https://azzurebubble.github.io/categories/%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/C/"/>
    
    <category term="Unity框架" scheme="https://azzurebubble.github.io/categories/%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/C/Unity%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Unity3D" scheme="https://azzurebubble.github.io/tags/Unity3D/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="游戏框架" scheme="https://azzurebubble.github.io/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>UnityEdior</title>
    <link href="https://azzurebubble.github.io/posts/ec874c57.html"/>
    <id>https://azzurebubble.github.io/posts/ec874c57.html</id>
    <published>2023-12-06T00:56:01.000Z</published>
    <updated>2024-04-20T01:10:48.249Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/UnityEditor/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%8A%A8%E5%9B%BE.gif" alt="插入排序"></p><blockquote><p>UnityEditor编辑器的代码必须放在Editor文件夹下，因为这个文件夹下的代码是不会被打包出去，只允许程序员在Unity编辑器下使用，如果不放在Editor这个文件夹下，打包时若包含UnityEditor的代码，会报错。</p></blockquote><h4 id="MenuItem">MenuItem</h4><h5 id="1-使用方法-MenuItem-“path”">1.使用方法:[MenuItem(“path”)]</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">EditorExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MenuItemExample</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// [MenuItem()] 修饰的必须是一个静态方法</span></span><br><span class="line">        <span class="comment">// 才会在Unity菜单栏出现先对应的按键</span></span><br><span class="line">        <span class="comment">// ()括号里的是这个方法在菜单栏的树形路径</span></span><br><span class="line">        [<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/EditorTest&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EditorTest</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;Hello Editor&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-Application-OpenURL-“path”-打开一个网址或者一个Application应用">2.Application.OpenURL(“path”) 打开一个网址或者一个Application应用</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/OpenBilibili&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenBilibili</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可以通过这个Api接口打开一个网址或者一个Application应用</span></span><br><span class="line">    Application.OpenURL(<span class="string">&quot;Http://bilibili.com&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-EditorUtility-RevealInFinder-“path”-打开一个指定的文件目录">3.EditorUtility.RevealInFinder(“path”) 打开一个指定的文件目录</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/打开策划目录&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenDesignFolder</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打开一个指定的文件目录 参数是一个文件的路径</span></span><br><span class="line">    EditorUtility.RevealInFinder(Application.dataPath.Replace(<span class="string">&quot;Assets&quot;</span>, <span class="string">&quot;Library&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-Menu-SetChecked-“path”-isChecked-可勾选的菜单栏">4.Menu.SetChecked(“path”,isChecked) 可勾选的菜单栏</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> openShotCut = <span class="literal">false</span>; <span class="comment">// 记录菜单栏勾选状态</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/快捷键开关&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ToggleShotCut</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    openShotCut = !openShotCut; <span class="comment">// 切换状态</span></span><br><span class="line">    Menu.SetChecked(<span class="string">&quot;EditorExtensions/MenuItem/快捷键开关&quot;</span>, openShotCut);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-MenuItem的快捷键设置">5.MenuItem的快捷键设置</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/EditorTestWithShotCut _c&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EditorTestWithShotCut</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 常用快捷键码</span></span><br><span class="line">    <span class="comment">// # -&gt; Shift &amp; -&gt; Alt % -&gt; Ctrl/Command</span></span><br><span class="line">    <span class="comment">// _a-z A-Z - a-z A-Z</span></span><br><span class="line">    Debug.Log(<span class="string">&quot;键盘C键的快捷键呼出菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/OpenBilibiliWithShotCut %#e&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenBilibiliWithShotCut</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    EditorUtility.RevealInFinder(Application.persistentDataPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-MenuItem-“path”-validate-true">6.[MenuItem(“path”, validate = true)]</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> openShotCut = <span class="literal">false</span>; <span class="comment">// 记录菜单栏勾选状态</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/快捷键开关&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ToggleShotCut</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    openShotCut = !openShotCut; <span class="comment">// 切换状态</span></span><br><span class="line">    Menu.SetChecked(<span class="string">&quot;EditorExtensions/MenuItem/快捷键开关&quot;</span>, openShotCut);</span><br><span class="line">&#125;</span><br><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/EditorTestWithShotCut _c&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EditorTestWithShotCut</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 常用快捷键码</span></span><br><span class="line">    <span class="comment">// # -&gt; Shift &amp; -&gt; Alt % -&gt; Ctrl/Command</span></span><br><span class="line">    <span class="comment">// _a-z A-Z - a-z A-Z</span></span><br><span class="line">    Debug.Log(<span class="string">&quot;键盘C键的快捷键呼出菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// openShotCut 为true时才能被使用</span></span><br><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/EditorTestWithShotCut %#e&quot;</span>, validate = true)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">EditorTestWithShotCutValidate</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> openShotCut;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/OpenBilibiliWithShotCut %#e&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenBilibiliWithShotCut</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    EditorUtility.RevealInFinder(Application.persistentDataPath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/OpenBilibiliWithShotCut %#e&quot;</span>, validate = true)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">OpenBilibiliWithShotCutValidate</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> openShotCut;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-EditorApplication-ExecuteMenuItem-“同名path”-复用MenuItem">7. EditorApplication.ExecuteMenuItem(“同名path”) 复用MenuItem</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/EditorTestWithShotCut _c&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EditorTestWithShotCut</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"> EditorApplication.ExecuteMenuItem(<span class="string">&quot;EditorExtensions/MenuItem/EditorTest&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="EditorWindow">EditorWindow</h4><h5 id="1-绘制一个编辑器窗口">1.绘制一个编辑器窗口</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/IMGUI/OpenGUILayoutExample&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenGUILayoutExample</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"> GUILayoutExample window = GetWindow&lt;GUILayoutExample&gt;();</span><br><span class="line"> window.Show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"> GUILayout.Label(<span class="string">&quot;Hello IMGUI&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/UnityEditor/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%8A%A8%E5%9B%BE.gif&quot; alt</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="Unity" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/Unity/"/>
    
    
    <category term="Unity" scheme="https://azzurebubble.github.io/tags/Unity/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="UnityEditor" scheme="https://azzurebubble.github.io/tags/UnityEditor/"/>
    
  </entry>
  
  <entry>
    <title>算法——最短路径算法</title>
    <link href="https://azzurebubble.github.io/posts/17cfe08f.html"/>
    <id>https://azzurebubble.github.io/posts/17cfe08f.html</id>
    <published>2023-08-01T12:45:09.000Z</published>
    <updated>2024-04-20T01:10:50.275Z</updated>
    
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="最短路径算法" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="最短路径算法" scheme="https://azzurebubble.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法——最小生成树算法</title>
    <link href="https://azzurebubble.github.io/posts/3cf1d1bf.html"/>
    <id>https://azzurebubble.github.io/posts/3cf1d1bf.html</id>
    <published>2023-08-01T12:44:34.000Z</published>
    <updated>2024-04-20T01:10:50.274Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>线性表</strong>：由同种数据类型的数据元素组成的有序序列。一般用于存储由顺序关系的数据序列。</p><p><strong>树</strong>：树存储结构不允许存在环路。</p><p><strong>图</strong>：图存储结构中可以存在环路。</p><p><strong>连通图</strong>：从任一顶点到另一个顶点都至少存在一条通路。</p><p><strong>非连通图</strong>：只要有某两个顶点之间找不到通路。</p><p><strong>生成树</strong>：包含图中所有的顶点。任意顶点之间有且仅有一条通路。</p><p><strong>最小生成树</strong>：指的就是在连通网中找到的总权值最小的生成树。常用的两种算法：</p><ul><li><strong>普里姆（Prim）算法</strong></li><li><strong>克鲁斯卡尔（kruskal）算法</strong></li></ul></blockquote><h4 id="普里姆（Prim）算法">普里姆（Prim）算法</h4><blockquote><p><strong>普里姆（Prim）算法</strong>：任选一个顶点出发，每次都选权值最小的边的顶点与原顶点相连。</p><p>采用的是贪心算法的思想。</p><ul><li>时间复杂度=O(n<sup>2</sup>)（n 为顶点数）</li><li>适用于<strong>稠密图</strong>，算法思想是选择<strong>点</strong></li></ul><p><strong>实现思路：</strong></p><ol><li>将连通网中的所有顶点分为两类（假设为 A 类和 B 类）。初始状态下，所有顶点位于 B 类；</li><li>选择任意一个顶点，将其从 B 类移动到 A 类；</li><li>从 B 类的所有顶点出发，找出一条连接着 A 类中的某个顶点且权值最小的边，将此边连接着的 A 类中的顶点移动到 B 类；</li><li>重复执行第 3 步，直至 B 类中的所有顶点全部移动到 A 类，恰好可以找到 N-1 条边。</li></ol></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><blockquote></blockquote><hr><h4 id="克鲁斯卡尔（kruskal）算法">克鲁斯卡尔（kruskal）算法</h4><blockquote><p><strong>克鲁斯卡尔（kruskal）算法</strong>：把所有顶点包含在生成树中，对边进行排序，然后直接选取权值最小的边加入到新生成的树中，途中不能形成环，直到所有顶点都连通为止。</p><ul><li>时间复杂度=O(elog<sub>2</sub>e)（e 为边数）</li><li>适用于<strong>稀疏图</strong>，算法思想是选择<strong>边</strong></li></ul></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><blockquote></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;线性表&lt;/strong&gt;：由同种数据类型的数据元素组成的有序序列。一般用于存储由顺序关系的数据序列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;树&lt;/strong&gt;：树存储结构不允许存在环路。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图&lt;/strong&gt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="最小生成树算法" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="最小生成树算法" scheme="https://azzurebubble.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法——查找算法</title>
    <link href="https://azzurebubble.github.io/posts/f43b98cb.html"/>
    <id>https://azzurebubble.github.io/posts/f43b98cb.html</id>
    <published>2023-08-01T12:43:16.000Z</published>
    <updated>2024-04-20T01:10:50.275Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>查找</strong>（<code>Search</code>）：是在一个数据集合中查找满足给定条件的记录。对于查找问题来说，没有一种算法对于任何情况下都是合适的。</p><p><strong>查找表</strong>（<code>Search Table</code>）：是由同一类型的数据元素（或记录）构成的集合。对查找表经常进行的操作：</p><ol><li>查询某个数据元素是否在查找表中**（静态查找表）**</li><li>检索某个数据元素的属性**（静态查找表）**</li><li>向查找表中添加一个数据元素**（动态查找表）**</li><li>向查找表中删除一个数据元素**（动态查找表）**</li></ol></blockquote><hr><h4 id="顺序查找算法">顺序查找算法</h4><blockquote><p><strong>顺序查找</strong>：又称<strong>顺序搜索算法</strong>或者<strong>线性搜索算法</strong>，是所有查找算法中最基本、最简单的。</p><p><strong>基本思想</strong>：从查找表的一端开始，顺序扫描线性表，逐个同记录的关键字作比较，如果匹配成功，则查找成功；反之，直到最后一个关键字都没有匹配成功，则为失败。</p><ul><li>时间复杂度=O(n)，空间复杂度=O(1)；最好时间复杂度为O(1)；</li><li>适用于绝大多数场景，既可以在有序序列中查找目标元素，也可以在无序序列中查找目标元素。</li><li>静态查找表既可以使用顺序表表示，也可以使用链表结构表示。</li><li>优点：算法简单而且使用面广。</li><li>缺点：查找效率较低，特别是当待查找集合中元素较多时，不推荐使用顺序查找。</li></ul></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">10</span>, <span class="number">14</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">31</span>, <span class="number">33</span>, <span class="number">35</span>, <span class="number">42</span>, <span class="number">44</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span> index = linear_search(arr, <span class="number">33</span>);</span><br><span class="line">        <span class="keyword">if</span> (index != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;查找成功！序列为第<span class="subst">&#123;index + <span class="number">1</span>&#125;</span>个元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;查找失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">linear_search</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == <span class="keyword">value</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>查找成功！序列为第7个元素</p></blockquote><hr><h4 id="二分查找算法">二分查找算法</h4><blockquote><p><strong>二分查找</strong>：又称<strong>折半查找、二分搜索、折半搜索</strong>等，是在分治算法基础上设计出来的查找算法。</p><p><strong>基本思想</strong>：将表中间位置记录的关键字与查找关键字比较，若相等，则查找成功；否则利用中间位置记录将表分为前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。</p><ul><li>时间复杂度=O(log<sub>2</sub>n)，循环方式：空间复杂度=O(1)，递归方式：时间复杂度=O(log<sub>2</sub>n)</li><li>数组元素必须有序，查找的数值不能多个，只能一个。必须采用顺序存储结构。</li><li>优点：比较次数少，查找速度块，平均性能好。</li><li>缺点：必须要求待查表为有序表；插入删除困难。</li></ul></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">10</span>, <span class="number">14</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">31</span>, <span class="number">33</span>, <span class="number">35</span>, <span class="number">42</span>, <span class="number">44</span> &#125;;</span><br><span class="line">        <span class="comment">//int index = binary_search1(arr, 0, 9, 31);</span></span><br><span class="line">        <span class="built_in">int</span> index = binary_search2(arr, <span class="number">0</span>, <span class="number">9</span>, <span class="number">31</span>);</span><br><span class="line">        <span class="keyword">if</span> (index != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;查找成功！序列为第<span class="subst">&#123;index + <span class="number">1</span>&#125;</span>个元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;查找失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">binary_search1</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> start, <span class="built_in">int</span> end, <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> == arr[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> &lt; arr[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> binary_search1(arr, start, mid - <span class="number">1</span>, <span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> binary_search1(arr, mid + <span class="number">1</span>, end, <span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非递归</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">binary_search2</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> start, <span class="built_in">int</span> end, <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> left = start;</span><br><span class="line">        <span class="built_in">int</span> right = end;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == <span class="keyword">value</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">value</span> &lt; arr[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>查找成功！序列为第6个元素</p></blockquote><hr><h4 id="插值查找算法">插值查找算法</h4><blockquote><p><strong>插值查找</strong>：又称为<strong>插值搜索算法</strong>，是在二分查找算法的基础上改进的一种查找算法，将查找点的选择改进位自适应选择，提高查找效率。</p><p><strong>基本思想</strong>：插值查找类似平时我们查字典的时候，查一个以 s 开头的单词时，绝对不会用二分查找，从字典的中间第一页开始，因为我们知道它的大概位置是在字典的较后面部分，所以可以从后面的某处查起。我们先从首字母 s 的地方开始查找，然后再根据第二个字母在字母表中的位置，找到对应位置再继续查找，这样重复这个过程，直到找到我们查找的这个单词这就是插值查找的基本思想</p><ul><li>顺序存储的有序数列，根据关键字在数据中均匀分布。</li><li>比较元素的位置公式：</li></ul><p>$$<br>Mid = Begin + ( (End - Begin) / (A[End] - A[Begin]) ) * (X - A[Begin])<br>$$</p><ul><li>Mid：计算得出的元素的位置；</li><li>End：搜索区域内最后一个元素所在的位置；</li><li>Begin：搜索区域内第一个元素所在的位置；</li><li>X：要查找的目标元素；</li><li>A[]：表示整个待搜索序列。</li></ul></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span> index = interpolation_search(arr, <span class="number">0</span>, <span class="number">9</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">if</span> (index != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;查找成功！序列为第<span class="subst">&#123;index + <span class="number">1</span>&#125;</span>个元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;查找失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">interpolation_search</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> begin, <span class="built_in">int</span> end, <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (begin &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果查找表中只有一个元素，则比较该元素和待查元素的值</span></span><br><span class="line">        <span class="keyword">if</span> (begin == end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[begin] == <span class="keyword">value</span> ? begin : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据公式找到中间元素的所在位置</span></span><br><span class="line">        <span class="built_in">int</span> mid = ((end - begin) / (arr[end] - arr[begin]) * (<span class="keyword">value</span> - arr[begin]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归出口</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> == arr[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归查询</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> &lt; arr[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> interpolation_search(arr, begin, mid - <span class="number">1</span>, <span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> interpolation_search(arr, mid + <span class="number">1</span>, end, <span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>查找成功！序列为第5个元素</p></blockquote><hr><h4 id="哈希查找算法">哈希查找算法</h4><blockquote><p><strong>哈希查找</strong>：又称<strong>散列查找算法</strong>，是一种借助哈希表（散列表）查找目标元素的方法，查找效率最高时对应的时间复杂度位O(2)。</p><p><strong>哈希表</strong>：又称散列表，是一种存储结构，通常用来存储多个元素。和其它存储结构（线性表、树等）相比，哈希表查找目标元素的效率非常高。每个存储到哈希表中的元素，都配有一个唯一的标识（又称“索引”或者“键”），用户想查找哪个元素，凭借该元素对应的标识就可以直接找到它，无需遍历整个哈希表。</p><ul><li>适用于大多数场景，既支持有序序列，也支持无序序列。</li><li>常见的散列函数：直接定址法，除留余数法，平方取余法等</li><li>处理冲突的方法：开放定址法，线性探测法，拉链法等</li><li>影响冲突的主要三个因素：<ul><li>散列函数是否均匀</li><li>处理冲突的方法</li><li>散列表的装填因子</li></ul></li></ul></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">5</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">55</span>, <span class="number">50</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span>[] hashArr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>];</span><br><span class="line">        CreateHash(arr, hashArr);</span><br><span class="line">        <span class="built_in">int</span> index = hash_search(hashArr, <span class="number">20</span>);</span><br><span class="line">        <span class="keyword">if</span> (index != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;查找成功！序列为第<span class="subst">&#123;index + <span class="number">1</span>&#125;</span>个元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;查找失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">hash</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">value</span> % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建哈希表</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateHash</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span>[] hashArr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> i, index;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 通过哈希函数计算当前元素在哈希表中的位置</span></span><br><span class="line">            index = hash(arr[i]);</span><br><span class="line">            <span class="keyword">while</span> (hashArr[index] != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            hashArr[index] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">hash_search</span>(<span class="params"><span class="built_in">int</span>[] hashArr, <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过哈希函数计算得到待查元素的下标</span></span><br><span class="line">        <span class="built_in">int</span> hashIndex = hash(<span class="keyword">value</span>);</span><br><span class="line">        <span class="comment">// 如果发生冲突，则使用线性探测法向后探测</span></span><br><span class="line">        <span class="keyword">while</span> (hashArr[hashIndex] != <span class="keyword">value</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            hashIndex = (hashIndex + <span class="number">1</span>) % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 如果探测位置为空</span></span><br><span class="line">            <span class="keyword">if</span> (hashArr[hashIndex] == <span class="number">0</span> || hashIndex == hash(<span class="keyword">value</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hashIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>查找成功！序列为第2个元素</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;查找&lt;/strong&gt;（&lt;code&gt;Search&lt;/code&gt;）：是在一个数据集合中查找满足给定条件的记录。对于查找问题来说，没有一种算法对于任何情况下都是合适的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查找表&lt;/strong&gt;（&lt;code</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="查找算法" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="查找算法" scheme="https://azzurebubble.github.io/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法——归并/计数/基数/桶排序</title>
    <link href="https://azzurebubble.github.io/posts/23241932.html"/>
    <id>https://azzurebubble.github.io/posts/23241932.html</id>
    <published>2023-07-28T14:41:30.000Z</published>
    <updated>2024-04-20T01:10:50.268Z</updated>
    
    <content type="html"><![CDATA[<h4 id="归并排序">归并排序</h4><blockquote><p>归并排序：将两个或两个以上的有序子序列<code>归并</code>为一个有序序列。基于分治思想。</p><ul><li>时间复杂度=O(nlog<sub>2</sub>n)，空间复杂度=O(n)。稳定排序</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" alt="归并排序"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = &#123; <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;未排序前的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        merge_sort(arr, <span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 分割数组</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge_sort</span>(<span class="params"><span class="built_in">int</span>[] arr,<span class="built_in">int</span> start,<span class="built_in">int</span> end</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span>(arr == <span class="literal">null</span> || start &gt;= end)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">int</span> mid = (start + end) / <span class="number">2</span>; <span class="comment">// 取得数组中间值下标</span></span><br><span class="line">         <span class="comment">// 继续分割</span></span><br><span class="line">         merge_sort(arr,start,mid);</span><br><span class="line">         merge_sort(arr,mid + <span class="number">1</span>,end);</span><br><span class="line">         merge(arr,start,mid,end);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="function">privatr <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span>(<span class="params"><span class="built_in">int</span>[] arr,<span class="built_in">int</span> start,<span class="built_in">int</span> mid,<span class="built_in">int</span> end</span>)<span class="comment">// 1 1 2</span></span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">int</span> left = mid - start + <span class="number">1</span>; <span class="comment">// 获得左边数组元素个数 </span></span><br><span class="line">         <span class="built_in">int</span> right = end - mid; <span class="comment">// 获得右边数组元素个数 </span></span><br><span class="line">         <span class="built_in">int</span> leftArr = <span class="keyword">new</span> <span class="built_in">int</span>[left + <span class="number">1</span>]; </span><br><span class="line">         <span class="built_in">int</span> rightArr = <span class="keyword">new</span> <span class="built_in">int</span>[right + <span class="number">1</span>]; </span><br><span class="line">         <span class="built_in">int</span> i;</span><br><span class="line">         <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; left; i++)</span><br><span class="line">         &#123;</span><br><span class="line">             leftArr[i] = arr[start - <span class="number">1</span> + i]; </span><br><span class="line">         &#125;</span><br><span class="line">         leftArr[i] = <span class="number">2147483647</span>; <span class="comment">// 把数组最后一个元素设置为最大值</span></span><br><span class="line">         <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; right; i++)</span><br><span class="line">         &#123;</span><br><span class="line">             rightArr[i] = arr[mid + i];</span><br><span class="line">         &#125;</span><br><span class="line">         leftArr[i] = <span class="number">2147483647</span>; <span class="comment">// 把数组最后一个元素设置为最大值</span></span><br><span class="line">         <span class="built_in">int</span> j = <span class="number">0</span>;</span><br><span class="line">         i = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="built_in">int</span> k = start; k &lt; end; k++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(leftArr[i] &lt;= rightArr[j])</span><br><span class="line">             &#123;</span><br><span class="line">                 arr[k - <span class="number">1</span>] = leftArr[i];</span><br><span class="line">                 i++;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">                 arr[k - <span class="number">1</span>] = rightArr[j];</span><br><span class="line">                 j++;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>未排序前的数组：<br>5 7 3 8 6 9 4 2<br>排序后的数组：<br>2 3 4 5 6 7 8 9</p></blockquote><hr><h4 id="计数排序">计数排序</h4><blockquote><p>计数排序：通过统计序列中各个元素出现的次数，完成对整个序列的升序或降序排序。（元素之间最好是在0~9之间的数值差）</p><ul><li>时间复杂度=O(n+k)，空间复杂度=O(n+k)。稳定排序</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="计数排序"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = &#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;未排序前的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        countingSort(arr);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">get_max</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countingSort</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> length = arr.Length;</span><br><span class="line">        <span class="comment">// 找出数组中的最大值</span></span><br><span class="line">        <span class="built_in">int</span> max = get_max(arr);</span><br><span class="line">        <span class="built_in">int</span>[] array = <span class="keyword">new</span> <span class="built_in">int</span>[max + <span class="number">1</span>]; <span class="comment">// 创建一个统计元素出现次数的数组</span></span><br><span class="line">        <span class="built_in">int</span>[] output = <span class="keyword">new</span> <span class="built_in">int</span>[length]; <span class="comment">// 排序数组</span></span><br><span class="line">        <span class="comment">// 统计元素出现个数，存储在对应的位置上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            array[arr[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 累加出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; max + <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            array[i] += array[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据次数进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            output[array[arr[i]] - <span class="number">1</span>] = arr[i];</span><br><span class="line">            array[arr[i]]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 复制到arr数组中 2, 4, 1, 2, 5, 3, 4, 8, 7</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = output[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>未排序前的数组：<br>2 4 1 2 5 3 4 8 7<br>排序后的数组：<br>1 2 2 3 4 4 5 7 8</p></blockquote><hr><h4 id="基数排序">基数排序</h4><blockquote><p>基数排序：数字逐位比较。</p><ul><li>时间复杂度=O(n×m)，空间复杂度=O(n×m)。稳定排序。n:数据个数，m:数据位数。</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="基数排序"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = &#123; <span class="number">121</span>, <span class="number">432</span>, <span class="number">564</span>, <span class="number">23</span>, <span class="number">1</span>, <span class="number">45</span>, <span class="number">788</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;未排序前的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        radixSort(arr);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">getMax</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countingSort</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> place</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> length = arr.Length;</span><br><span class="line">        <span class="built_in">int</span>[] output = <span class="keyword">new</span> <span class="built_in">int</span>[length];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> max = (arr[<span class="number">0</span>] / place) % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (((arr[i] / place) % <span class="number">10</span>) &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = (arr[i] / place) % <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span>[] count = <span class="keyword">new</span> <span class="built_in">int</span>[max + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            count[(arr[i] / place) % <span class="number">10</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; max + <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一定要从后往前排</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            output[count[(arr[i] / place) % <span class="number">10</span>] - <span class="number">1</span>] = arr[i];</span><br><span class="line">            count[(arr[i] / place) % <span class="number">10</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = output[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> max = getMax(arr);</span><br><span class="line">        <span class="comment">// 根据最高位数，从低位依次进行计数排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; max / i &gt; <span class="number">0</span>; i *= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            countingSort(arr, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>未排序前的数组：<br>121 432 564 23 1 45 788<br>排序后的数组：<br>1 23 45 121 432 564 788</p></blockquote><hr><h4 id="桶-箱排序">桶/箱排序</h4><blockquote><p>桶/箱排序：待排序数组，分配到若干个桶，各自执行排序任务。是一种基于分治思想、效率很高的排序算法。(适用于数据范围较小且分布均匀的浮点数数据)</p><ul><li>时间复杂度=O(n+m+n(logn-logm))，空间复杂度=O(n+m)。稳定排序。n:数据个数，m:数据位数。</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E6%A1%B6%E6%8E%92%E5%BA%8F.gif" alt="桶排序"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;归并排序&quot;&gt;归并排序&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;归并排序：将两个或两个以上的有序子序列&lt;code&gt;归并&lt;/code&gt;为一个有序序列。基于分治思想。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度=O(nlog&lt;sub&gt;2&lt;/sub&gt;n)，空间复杂度=O(n)</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="排序算法" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="排序算法" scheme="https://azzurebubble.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法——选择排序</title>
    <link href="https://azzurebubble.github.io/posts/18d056c9.html"/>
    <id>https://azzurebubble.github.io/posts/18d056c9.html</id>
    <published>2023-07-25T16:08:58.000Z</published>
    <updated>2024-04-20T01:10:50.272Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简单选择排序">简单选择排序</h4><blockquote><p>简单选择排序：在待排序的数据中选出最大（小）的元素放在其最终的位置。</p><ul><li>时间复杂度=O(n<sup>2</sup>)，空间复杂度=O(1)。稳定排序。</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%8A%A8%E5%9B%BE.gif" alt="选择排序动图"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = &#123; <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;未排序前的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        selection_sort(arr);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selection_sort</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> length = arr.Length;</span><br><span class="line">        <span class="built_in">int</span> i, j, min;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            min = i; <span class="comment">// 把第一个元素假设为最小</span></span><br><span class="line">            <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 从第二个元素开始遍历到最后一个</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[min])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 如果期间出现小于最小元素的值，则交换位置</span></span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (min != i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[min];</span><br><span class="line">                arr[min] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>未排序前的数组：<br>5 7 3 8 6 9<br>排序后的数组：<br>3 5 6 7 8 9</p></blockquote><hr><h4 id="堆排序">堆排序</h4><blockquote><p>堆排序：堆的是指就是满足二叉树中任一非叶子结点均小于（大于）它的孩子结点的完全二叉树。</p><ul><li>时间复杂度=O(nlog<sub>2</sub>n)，空间复杂度=O(1)。不稳定排序。</li><li>小根堆：若n个元素的序列{a<sub>1</sub>a<sub>2</sub>…a<sub>n</sub>}满足a<sub>i</sub> ≤ a<sub>2i</sub>和a<sub>i</sub> ≤ a<sub>2i+1</sub>。</li><li>大根堆：若n个元素的序列{a<sub>1</sub>a<sub>2</sub>…a<sub>n</sub>}满足a<sub>i</sub> ≥ a<sub>2i</sub>和a<sub>i</sub> ≥ a<sub>2i+1</sub>。</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E5%A0%86%E6%8E%92%E5%BA%8F.gif" alt="堆排序"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = &#123; <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;未排序前的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        <span class="comment">//big_heap_sort(arr);</span></span><br><span class="line">        small_heap_sort(arr);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">big_heap_sort</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从树的第arr.Length / 2 - 1个结点开始建立大根堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = arr.Length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            big_heap_adjust(arr, i, arr.Length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = arr.Length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 把根结点与最后一个结点进行交换，把最大值放到最后</span></span><br><span class="line">            <span class="built_in">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">            <span class="comment">// 交换后，以根结点开始，重新调整为大根堆</span></span><br><span class="line">            big_heap_adjust(arr, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立大根堆：升序，最大值（根结点）与最后一个结点交换位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">big_heap_adjust</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> parent, <span class="built_in">int</span> length</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 临时存储根结点数值</span></span><br><span class="line">        <span class="built_in">int</span> temp = arr[parent];</span><br><span class="line">        <span class="comment">// 找到根结点的左孩子</span></span><br><span class="line">        <span class="built_in">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 孩子结点不大于数组长度</span></span><br><span class="line">        <span class="keyword">while</span> (child &lt; length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果右孩子在数组长度内 &amp;&amp; 右孩子 &gt; 左孩子</span></span><br><span class="line">            <span class="keyword">if</span> (child + <span class="number">1</span> &lt; length &amp;&amp; arr[child + <span class="number">1</span>] &gt; arr[child])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 设置为右孩子</span></span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果根结点 &gt; 孩子结点</span></span><br><span class="line">            <span class="keyword">if</span> (temp &gt; arr[child])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 退出+</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则，根结点与最大的孩子结点交换位置</span></span><br><span class="line">            arr[parent] = arr[child];</span><br><span class="line">            <span class="comment">// 根结点设置为交换后的孩子结点下标</span></span><br><span class="line">            parent = child;</span><br><span class="line">            <span class="comment">// 找到新的左孩子下标</span></span><br><span class="line">            child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时parent已为最小的孩子结点，把temp放到此位置上</span></span><br><span class="line">        arr[parent] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">small_heap_sort</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = arr.Length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            small_heap_sort(arr, i, arr.Length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = arr.Length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">            small_heap_sort(arr, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小根堆:降序，最小值（根结点）与最后一个结点交换位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">small_heap_sort</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> parent, <span class="built_in">int</span> length</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> temp = arr[parent];</span><br><span class="line">        <span class="built_in">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (child &lt; length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (child + <span class="number">1</span> &lt; length &amp;&amp; arr[child + <span class="number">1</span>] &lt; arr[child])</span><br><span class="line">            &#123;</span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp &lt; arr[child])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[parent] = arr[child];</span><br><span class="line">            parent = child;</span><br><span class="line">            child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[parent] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;简单选择排序&quot;&gt;简单选择排序&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;简单选择排序：在待排序的数据中选出最大（小）的元素放在其最终的位置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度=O(n&lt;sup&gt;2&lt;/sup&gt;)，空间复杂度=O(1)。稳定排序。&lt;/li&gt;
&lt;/u</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="排序算法" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="排序算法" scheme="https://azzurebubble.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="选择排序" scheme="https://azzurebubble.github.io/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
</feed>
