<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fomalhaut🥝</title>
  
  
  <link href="https://azzurebubble.github.io/atom.xml" rel="self"/>
  
  <link href="https://azzurebubble.github.io/"/>
  <updated>2024-07-16T14:32:14.925Z</updated>
  <id>https://azzurebubble.github.io/</id>
  
  <author>
    <name>Rock</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UGUI源码解析——CanvasUpdateRegistry</title>
    <link href="https://azzurebubble.github.io/posts/6dcd3730.html"/>
    <id>https://azzurebubble.github.io/posts/6dcd3730.html</id>
    <published>2024-07-16T14:27:22.000Z</published>
    <updated>2024-07-16T14:32:14.925Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>CanvasUpdate：用于描述在Canvas更新过程中可能发生的不同阶段</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> CanvasUpdate</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 布局更新之前调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    Prelayout = <span class="number">0</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 布局更新时调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    Layout = <span class="number">1</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 布局更新之后调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    PostLayout = <span class="number">2</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 渲染之前调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    PreRender = <span class="number">3</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 渲染之前完成后调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    LatePreRender = <span class="number">4</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 表示枚举的范围，边界检测或者迭代</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    MaxUpdateValue = <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ICanvasElement：图像、布局重建接口。几乎所有UI对象都继承自ICanvasElement接口，一个UI对象若要重建都需要继承自ICanvasElement接口。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICanvasElement</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 重构方法，需要在继承类中实现，Graphic和LayoutRebuilder继承了此接口</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;executing&quot;&gt;</span>正在重建的当前的CanvasUpdate阶段<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">Rebuild</span>(<span class="params">CanvasUpdate executing</span>)</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 每个UI都继承自UIBehaviour类，UIBehaviour继承自MonoBehaviour，MonoBehaviour继承自Component类，而Component类实现了transform属性，所以子类可以不再实现这个属性</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     Transform transform &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 布局完成的回调函数</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">LayoutComplete</span>()</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 图像更新完成的回调函数</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">GraphicUpdateComplete</span>()</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 获取UI对象是否销毁</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">     <span class="function"><span class="built_in">bool</span> <span class="title">IsDestroyed</span>()</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>CanvasUpdateRegistry：是一个单例，它监听了Canvas即将渲染的事件，并调用已注册对象的Rebuild、LayoutComplete、GraphicUpdateComplete方法，<font color=red>而其中的Rebuild方法就是每个UI元素的刷新方法。</font></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例获取</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CanvasUpdateRegistry s_Instance;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CanvasUpdateRegistry instance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s_Instance == <span class="literal">null</span>)</span><br><span class="line">            s_Instance = <span class="keyword">new</span> CanvasUpdateRegistry();</span><br><span class="line">        <span class="keyword">return</span> s_Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数：给Canvas的静态事件willRenderCanvases注册一个名为PerformUpdate的方法</span></span><br><span class="line"><span class="comment">// (willRenderCanvases每帧在Canvas渲染前执行)，PerformUpdate中调用了布局和图像的更新</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">CanvasUpdateRegistry</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Canvas.willRenderCanvases += PerformUpdate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个标记是否在进行布局或图像更新的字段</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> m_PerformingLayoutUpdate;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> m_PerformingGraphicUpdate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于在性能分析器中识别和记录Canvas更新过程中的不同阶段的标识符</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span>[] m_CanvasUpdateProfilerStrings = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;CanvasUpdate.Prelayout&quot;</span>, <span class="string">&quot;CanvasUpdate.Layout&quot;</span>, <span class="string">&quot;CanvasUpdate.PostLayout&quot;</span>, <span class="string">&quot;CanvasUpdate.PreRender&quot;</span>, <span class="string">&quot;CanvasUpdate.LatePreRender&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 用于在性能分析器或调试器中标识剪切器注册表中执行裁剪的标识符</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> m_CullingUpdateProfilerString = <span class="string">&quot;ClipperRegistry.Cull&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 布局重建序列和图像重建序列</span></span><br><span class="line"><span class="comment">// 当需要更新布局或图像时，可以调用RegisterCanvasElementForLayoutRebuild和</span></span><br><span class="line"><span class="comment">// RegisterCanvasElementForGraphicRebuild两个方法将对象添加到对应的重建序列中</span></span><br><span class="line"><span class="comment">// PerformUpdate方法会调用Rebuild方法对这两个序列中中的对象进行更新操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> IndexedSet&lt;ICanvasElement&gt; m_LayoutRebuildQueue = <span class="keyword">new</span> IndexedSet&lt;ICanvasElement&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> IndexedSet&lt;ICanvasElement&gt; m_GraphicRebuildQueue = <span class="keyword">new</span> IndexedSet&lt;ICanvasElement&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查指定的Canvas元素是否是Unity的Object，是否可以进行有效更新</span></span><br><span class="line"><span class="comment">// Object是Unity所有对象的基类，object是C#中所有对象的基类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">ObjectValidForUpdate</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> valid = element != <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> isUnityObject = element <span class="keyword">is</span> Object;</span><br><span class="line">    <span class="keyword">if</span> (isUnityObject)</span><br><span class="line">        valid = (element <span class="keyword">as</span> Object) != <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> valid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理两个队列中的无效元素</span></span><br><span class="line"><span class="comment">// MonoBehaviour对空值相等性重载了==操作符，用于检查他们是否被销毁</span></span><br><span class="line"><span class="comment">// 这段代码中处理的是一个ICanvasElement接口类型的列表，而不是具体的MonoBehaviour类型</span></span><br><span class="line"><span class="comment">// 因此直接使用==操作符不能直接转发到MonoBehaviour，而只是检查接口本身是否为null</span></span><br><span class="line"><span class="comment">// IsDestroyed()方法用于检查元素的后端是否被销毁</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CleanInvalidItems</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> layoutRebuildQueueCount = m_LayoutRebuildQueue.Count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = layoutRebuildQueueCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> item = m_LayoutRebuildQueue[i];</span><br><span class="line">        <span class="comment">// 元素是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (item == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_LayoutRebuildQueue.RemoveAt(i);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 元素是否被销毁</span></span><br><span class="line">        <span class="keyword">if</span> (item.IsDestroyed())</span><br><span class="line">        &#123;</span><br><span class="line">            m_LayoutRebuildQueue.RemoveAt(i);</span><br><span class="line">            item.LayoutComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> graphicRebuildQueueCount = m_GraphicRebuildQueue.Count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = graphicRebuildQueueCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> item = m_GraphicRebuildQueue[i];</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_GraphicRebuildQueue.RemoveAt(i);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (item.IsDestroyed())</span><br><span class="line">        &#123;</span><br><span class="line">            m_GraphicRebuildQueue.RemoveAt(i);</span><br><span class="line">            item.GraphicUpdateComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算指定Transform对象的父级层级数目</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">ParentCount</span>(<span class="params">Transform child</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> parent = child.parent;</span><br><span class="line">    <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (parent != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        parent = parent.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个元素的祖先层级深度，祖先层级深度越深，则排在列表的更后面</span></span><br><span class="line"><span class="comment">// 决定元素的布局和图像重建顺序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">SortLayoutList</span>(<span class="params">ICanvasElement x, ICanvasElement y</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Transform t1 = x.transform;</span><br><span class="line">    Transform t2 = y.transform;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ParentCount(t1) - ParentCount(t2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个Canvas元素注册到布局重建队列中，一个带返回值一个不带返回值方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RegisterCanvasElementForLayoutRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    instance.InternalRegisterCanvasElementForLayoutRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">TryRegisterCanvasElementForLayoutRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> instance.InternalRegisterCanvasElementForLayoutRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">InternalRegisterCanvasElementForLayoutRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断元素是否存在布局重建队列中</span></span><br><span class="line">    <span class="keyword">if</span> (m_LayoutRebuildQueue.Contains(element))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 向布局重建队列中添加元素，确保不会重复添加</span></span><br><span class="line">    <span class="keyword">return</span> m_LayoutRebuildQueue.AddUnique(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个Canvas元素注册到图像重建队列中，一个带返回值一个不带返回值方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RegisterCanvasElementForGraphicRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    instance.InternalRegisterCanvasElementForGraphicRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">TryRegisterCanvasElementForGraphicRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> instance.InternalRegisterCanvasElementForGraphicRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">InternalRegisterCanvasElementForGraphicRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 是否正在进行图像重建更新操作，是的话将不会将元素添加到图像重建队列中</span></span><br><span class="line">    <span class="keyword">if</span> (m_PerformingGraphicUpdate)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="built_in">string</span>.Format(<span class="string">&quot;Trying to add &#123;0&#125; for graphic rebuild while we are already inside a graphic rebuild loop. This is not supported.&quot;</span>, element));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 向图像重建队列中添加元素，确保不会重复添加</span></span><br><span class="line">    <span class="keyword">return</span> m_GraphicRebuildQueue.AddUnique(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从布局和重建的队列中移除指定的Canvas元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnRegisterCanvasElementForRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    instance.InternalUnRegisterCanvasElementForLayoutRebuild(element);</span><br><span class="line">    instance.InternalUnRegisterCanvasElementForGraphicRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InternalUnRegisterCanvasElementForLayoutRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果正在进行布局重建更新操作，将不会移除指定元素</span></span><br><span class="line">    <span class="keyword">if</span> (m_PerformingLayoutUpdate)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="built_in">string</span>.Format(<span class="string">&quot;Trying to remove &#123;0&#125; from rebuild list while we are already inside a rebuild loop. This is not supported.&quot;</span>, element));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 调用元素的布局重建完成函数</span></span><br><span class="line">    element.LayoutComplete();</span><br><span class="line">    <span class="comment">// 从布局重建队列中移除元素</span></span><br><span class="line">    instance.m_LayoutRebuildQueue.Remove(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InternalUnRegisterCanvasElementForGraphicRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果正在进行图像重建更新操作，将不会移除指定元素</span></span><br><span class="line">    <span class="keyword">if</span> (m_PerformingGraphicUpdate)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="built_in">string</span>.Format(<span class="string">&quot;Trying to remove &#123;0&#125; from rebuild list while we are already inside a rebuild loop. This is not supported.&quot;</span>, element));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用元素的图像重建完成函数</span></span><br><span class="line">    element.GraphicUpdateComplete();</span><br><span class="line">    <span class="comment">// 从图像重建队列中移除元素</span></span><br><span class="line">    instance.m_GraphicRebuildQueue.Remove(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从布局和重建的队列中禁用指定的Canvas元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DisableCanvasElementForRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    instance.InternalDisableCanvasElementForLayoutRebuild(element);</span><br><span class="line">    instance.InternalDisableCanvasElementForGraphicRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InternalDisableCanvasElementForLayoutRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果正在进行布局重建更新操作，将不会禁用指定元素</span></span><br><span class="line">    <span class="keyword">if</span> (m_PerformingLayoutUpdate)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="built_in">string</span>.Format(<span class="string">&quot;Trying to remove &#123;0&#125; from rebuild list while we are already inside a rebuild loop. This is not supported.&quot;</span>, element));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 调用元素的布局重建完成函数</span></span><br><span class="line">    element.LayoutComplete();</span><br><span class="line">    <span class="comment">// 禁用指定元素</span></span><br><span class="line">    instance.m_LayoutRebuildQueue.DisableItem(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InternalDisableCanvasElementForGraphicRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果正在进行图像重建更新操作，将不会禁用指定元素</span></span><br><span class="line">    <span class="keyword">if</span> (m_PerformingGraphicUpdate)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="built_in">string</span>.Format(<span class="string">&quot;Trying to remove &#123;0&#125; from rebuild list while we are already inside a rebuild loop. This is not supported.&quot;</span>, element));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用元素的图像重建完成函数</span></span><br><span class="line">    element.GraphicUpdateComplete();</span><br><span class="line">    <span class="comment">// 禁用指定元素</span></span><br><span class="line">    instance.m_GraphicRebuildQueue.DisableItem(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前是否正在计算图形布局</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsRebuildingLayout</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> instance.m_PerformingLayoutUpdate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当前是否正在重建图形</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsRebuildingGraphics</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> instance.m_PerformingGraphicUpdate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接下来着重分析CanvasUpdateRegistry中的PerformUpdate方法的内部实现和执行顺序。<font color=red>可以在Profiler中通过查看标志性函数Canvas.willRenderCanvases的耗时，来了解重建的性能消耗</font></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先定义一个静态只读的比较函数委托</span></span><br><span class="line"><span class="comment">// Comparison&lt;T&gt;是C#已经预定义好的一个用于比较两个类型为T的对象并返回整数的委托</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Comparison&lt;ICanvasElement&gt; s_SortLayoutFunction = SortLayoutList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PerformUpdate</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 用于在代码块开始和结束时记录性能样本，监测布局更新的性能</span></span><br><span class="line">    UISystemProfilerApi.BeginSample(UISystemProfilerApi.SampleType.Layout);</span><br><span class="line">    <span class="comment">// 清理无效的元素或数据</span></span><br><span class="line">    CleanInvalidItems();</span><br><span class="line"><span class="comment">// 标记正在进行布局更新操作</span></span><br><span class="line">    m_PerformingLayoutUpdate = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 对布局重建队列中的元素进行排序</span></span><br><span class="line">    m_LayoutRebuildQueue.Sort(s_SortLayoutFunction);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= (<span class="built_in">int</span>)CanvasUpdate.PostLayout; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 标记每一个元素的性能分析</span></span><br><span class="line">        UnityEngine.Profiling.Profiler.BeginSample(m_CanvasUpdateProfilerStrings[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; m_LayoutRebuildQueue.Count; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> rebuild = m_LayoutRebuildQueue[j];</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 判断元素是否是有效元素</span></span><br><span class="line">                <span class="comment">// 对布局重建序列中的每一个元素进行CanvasUpdate的每个阶段更新</span></span><br><span class="line">                <span class="keyword">if</span> (ObjectValidForUpdate(rebuild))</span><br><span class="line">                    rebuild.Rebuild((CanvasUpdate)i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogException(e, rebuild.transform);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        UnityEngine.Profiling.Profiler.EndSample();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m_LayoutRebuildQueue.Count; ++i)</span><br><span class="line">        <span class="comment">// 调用布局重建完成函数</span></span><br><span class="line">        m_LayoutRebuildQueue[i].LayoutComplete();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空布局重建列表，并修改布局重建标志为false</span></span><br><span class="line">    m_LayoutRebuildQueue.Clear();</span><br><span class="line">    m_PerformingLayoutUpdate = <span class="literal">false</span>;</span><br><span class="line">    UISystemProfilerApi.EndSample(UISystemProfilerApi.SampleType.Layout);</span><br><span class="line">    UISystemProfilerApi.BeginSample(UISystemProfilerApi.SampleType.Render);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now layout is complete do culling...</span></span><br><span class="line">    UnityEngine.Profiling.Profiler.BeginSample(m_CullingUpdateProfilerString);</span><br><span class="line">    <span class="comment">// 执行实际的裁剪操作</span></span><br><span class="line">    ClipperRegistry.instance.Cull();</span><br><span class="line">    UnityEngine.Profiling.Profiler.EndSample();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记正在进行图像更新操作</span></span><br><span class="line">    m_PerformingGraphicUpdate = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = (<span class="built_in">int</span>)CanvasUpdate.PreRender; i &lt; (<span class="built_in">int</span>)CanvasUpdate.MaxUpdateValue; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        UnityEngine.Profiling.Profiler.BeginSample(m_CanvasUpdateProfilerStrings[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; m_GraphicRebuildQueue.Count; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> element = m_GraphicRebuildQueue[k];</span><br><span class="line">                <span class="comment">// 判断元素是否是有效元素</span></span><br><span class="line">                <span class="comment">// 对布局重建序列中的每一个元素进行CanvasUpdate的每个阶段更新</span></span><br><span class="line">                <span class="keyword">if</span> (ObjectValidForUpdate(element))</span><br><span class="line">                    element.Rebuild((CanvasUpdate)i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogException(e, m_GraphicRebuildQueue[k].transform);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        UnityEngine.Profiling.Profiler.EndSample();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m_GraphicRebuildQueue.Count; ++i)</span><br><span class="line">        <span class="comment">// 调用图像重建完成函数</span></span><br><span class="line">        m_GraphicRebuildQueue[i].GraphicUpdateComplete();</span><br><span class="line"><span class="comment">// 清空图像重建序列 并修改图像重建标志为false</span></span><br><span class="line">    m_GraphicRebuildQueue.Clear();</span><br><span class="line">    m_PerformingGraphicUpdate = <span class="literal">false</span>;</span><br><span class="line">    UISystemProfilerApi.EndSample(UISystemProfilerApi.SampleType.Render);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">图像、布局重建注册器</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——UIBehaviour</title>
    <link href="https://azzurebubble.github.io/posts/45311df6.html"/>
    <id>https://azzurebubble.github.io/posts/45311df6.html</id>
    <published>2024-07-15T15:07:52.000Z</published>
    <updated>2024-07-16T14:32:24.539Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>UIBehaviour：是所有UI组件的基类，UI组件都是直接或者间接继承UIBehaviour这个抽象类，<font color=red>它继承自MonoBehaviour，所以拥有和Unity相同的生命周期。</font></p></blockquote><h4 id="源码解析">源码解析</h4><blockquote><p>只会在物体创建时执行一次 ，与Mono Awake调用时机和次数保持一致</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在物体显示时执行一次，与Mono OnEnable一致</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在物体第一次激活时执行一次，在Awake之后，第一帧Update之前执行，与Mono Start一致</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Start</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在物体隐藏时执行一次，与Mono OnDisable 一致</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在当前界面被销毁时调用一次，与Mono Destroy一致</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在编辑器模式下：当脚本被加载(禁用或启用)或者Inspector窗口的值出现变化的时候会被调用，使用时添加#if UNITY_EDITOR</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnValidate</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在编辑器模式下：当脚本恢复默认值时调用，使用时添加#if UNITY_EDITOR</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Reset</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当RectTransform变化时候调用，Anchors、Pivot、Width、Height变化时调用，Transform、Rotation、Scale变化时不调用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnRectTransformDimensionsChange</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在父物体变化之前调用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnBeforeTransformParentChanged</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在父物体变化之后调用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnTransformParentChanged</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在Canvas状态变化时调用，比如禁用Canvas组件</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnDidApplyAnimationProperties</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在Canvas Group变化时调用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnCanvasGroupChanged</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当应用动画属性时调用</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnCanvasHierarchyChanged</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>获取GameObject和Component是否处于激活状态</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> <span class="title">IsActive</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> isActiveAndEnabled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>获取GameObject和Component是否被销毁</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsDestroyed</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">UI组件的基类，继承MonoBehaviour</summary>
    
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>UGUI源码解析——目录</title>
    <link href="https://azzurebubble.github.io/posts/42c102bd.html"/>
    <id>https://azzurebubble.github.io/posts/42c102bd.html</id>
    <published>2024-07-05T03:33:56.000Z</published>
    <updated>2024-07-16T14:37:25.055Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://azurebubble.github.io/posts/45311df6.html"><strong>UGUI源码解析——UIBehaviour</strong></a></p><blockquote><p>UIBehaviour：UI组件的基类，继承MonoBehaviour</p></blockquote><p><a href="https://azurebubble.github.io/posts/6dcd3730.html"><strong>UGUI源码解析——CanvasUpdateRegistry</strong></a></p><blockquote><p>CanvasUpdateRegistry：图像、布局重建注册器</p></blockquote>]]></content>
    
    
    <summary type="html">这是一篇阅读分析UGUI源码的文章分享，欢迎大佬指正，一起学习</summary>
    
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/C/"/>
    
    <category term="学习" scheme="https://azzurebubble.github.io/categories/C/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/categories/C/%E5%AD%A6%E4%B9%A0/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="UGUI源码解析" scheme="https://azzurebubble.github.io/tags/UGUI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    <category term="Unity3D" scheme="https://azzurebubble.github.io/tags/Unity3D/"/>
    
  </entry>
  
  <entry>
    <title>Untiy游戏框架QZGameFramework</title>
    <link href="https://azzurebubble.github.io/posts/3e60956b.html"/>
    <id>https://azzurebubble.github.io/posts/3e60956b.html</id>
    <published>2024-01-06T10:13:46.000Z</published>
    <updated>2024-07-05T03:39:10.984Z</updated>
    
    <content type="html"><![CDATA[<h3 id="框架仓库链接——《QZGameFramework》">框架仓库链接——<a href="https://github.com/AzureBubble/QZGameFramework"><strong>《QZGameFramework》</strong></a></h3><blockquote><p>本框架的基础是在本人参加多个项目，并且查阅积累了各类优秀代码后，自己总结优化的一个较为通用且易用的简易游戏框架，并会在未来自我能力提升的同时继续优化更新此框架，目标是一个适用于新手入门和中小公司节约成本的前提下的涵盖前后端Unity游戏框架(目前后端服务器还在学习中…)。</p></blockquote><h3 id="Unity-Editor-编辑器工具">Unity Editor 编辑器工具</h3><blockquote><p>本框架中的工具是原创+魔改实现的。</p></blockquote><h4 id="ExcelTool-——-读取-Excel-配置表工具">ExcelTool —— 读取 Excel 配置表工具</h4><blockquote><p>主要包含两种读表方式：Json和Binary。可自定义存储路径。</p><p>配置表规则<br>第一行：字段名(如修改规则，请更改 ExcelTool 脚本中的 BEGIN_VARIABLE_NAME_INDEX 变量)<br>第二行：字段类型(字段类型支持：int,float,bool,string)<br>如需增加新的字段类型读写规则，请在任务列表中找到对应的位置添加对应字段类型处理规则即可<br>(如修改规则，请更改 ExcelTool 脚本中的 BEGIN_VARIABLE_TYPE_INDEX 变量)<br>第三行：主键(key)，通过key来标识唯一主键(Json文件默认 id 为主键，不以自定义key为规则)<br>(如修改规则，请更改 ExcelTool 脚本中的 BEGIN_KEY_INDEX 变量)<br>第四行：描述信息(可选：增加注释，便于阅读理解)<br>(如修改规则，请更改 ExcelTool 脚本中的 BEGIN_DESCRIPTION_INDEX 变量)<br>第五行~第n行：具体数据信息<br>Excel 下的表名决定数据结构类名，容器类名，二进制文件名<br>(如修改规则，请更改 ExcelTool 脚本中的 BEGIN_INDEX 变量)</p><p>目前只支持int、float、bool、string四种数据类型配置表读取，如需增加，可直接打开ExcelTool脚本找到TODO任务列表添加即可。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/QZGameFramework/ExcelTool1.png" alt="ExcelTool1"></p><h4 id="ABTool-——-资源服务器AB包上传工具">ABTool —— 资源服务器AB包上传工具</h4><blockquote><p>本工具提供了AB包一键上传AB资源文件到指定资源服务器。使用的是MD5码加密生成的AB包对比文件。下载配合使用ABUpdateMgr脚本使用即可。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/QZGameFramework/ABTool1.png" alt="ABTool1"></p><h4 id="LuaTool-——-Lua脚本一键生成txt后缀并移动到指定AB包和文件夹工具">LuaTool —— Lua脚本一键生成txt后缀并移动到指定AB包和文件夹工具</h4><blockquote><p>本工具是为了方便Lua文件的迁移。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/QZGameFramework/LuaTool1.png" alt="LuaTool1"></p><h4 id="DialogueTool-——-对话树编辑器工具">DialogueTool —— 对话树编辑器工具</h4><blockquote><p>利用树的特性和UIToolkit编写的一个对话树插件，快速编辑剧情对话分支。对应的每个节点的具体行为逻辑，继承顺序节点和分支节点的基类重写对应方法即可。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/QZGameFramework/DialogueTreeTool.png" alt="DialogueTreeTool"></p><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/QZGameFramework/DialogueTreeTool1.png" alt="DialogueTreeTool"></p><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/QZGameFramework/DialogueTreeTool2.png" alt="DialogueTreeTool"></p><h4 id="BehaviourTreeTool-——-行为树编辑器">BehaviourTreeTool —— 行为树编辑器</h4><blockquote><p>一个简单的可视化行为树编辑器工具，自定义节点，只需要继承指定的Action类，decoration等节点类即可。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/QZGameFramework/BehaviourTool1.png" alt="BehaviourTool"></p><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/QZGameFramework/BehaviourTool2.png" alt="BehaviourTool"></p><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/QZGameFramework/BehaviourTool3.png" alt="BehaviourTool"></p><h3 id="Unity框架">Unity框架</h3><h4 id="成就管理器">成就管理器</h4><blockquote><p>一个简易的使用观察者实现的成就系统，待完善。</p></blockquote><h4 id="事件中心模块">事件中心模块</h4><blockquote><p>分发消息</p></blockquote><h4 id="有限状态机模块">有限状态机模块</h4><blockquote><p>通用的FSM系统：状态包含一个数据黑板。</p></blockquote><h4 id="输入系统">输入系统</h4><blockquote><p>命令模式实现的一个旧输入系统监听操纵。</p></blockquote><h4 id="背包系统">背包系统</h4><blockquote><p>待完善</p></blockquote><h4 id="音乐管理系统">音乐管理系统</h4><blockquote><p>结合对象池和资源加载模块实现的音乐管理器</p></blockquote><h4 id="对象池模块">对象池模块</h4><blockquote></blockquote><h4 id="包管理器模块">包管理器模块</h4><h4 id="数据持久化模块">数据持久化模块</h4><h4 id="场景切换管理器">场景切换管理器</h4><h4 id="单例模式管理器">单例模式管理器</h4><blockquote><p>这是一个管理全局所有单例的模块：管理全局所有的单例，相对于传统的单例模式创建，这样更便于对单例的管理和销毁，且如果需要进行帧更新的单例可以继承IUpdateSingleton接口即可实现单例帧更新函数OnUpdate，且这个帧更新的单例可以单独设置优先级，控制单例的帧更新顺序。</p></blockquote><h4 id="自动化UI框架">自动化UI框架</h4><blockquote><p>搭建好界面后，一键生成通用UI窗口脚本和UI元素脚本并挂载在窗口GameObject上</p></blockquote><h4 id="Timer计时器">Timer计时器</h4><h4 id="SceneName特性">SceneName特性</h4><blockquote><p>[SceneName]特性标记string变量，可快速在Inspector窗口通过下拉框选择场景</p></blockquote><h4 id="ReadOnly特性">ReadOnly特性</h4><blockquote><p>编辑在Inspector显示但只读的变量属性，可通过后面的单选框开启关闭只读绘制。</p></blockquote>]]></content>
    
    
    <summary type="html">这是一个自研框架，目前适用大部分Unity游戏开发，欠缺AB包模块和热更模块。</summary>
    
    
    
    <category term="框架搭建" scheme="https://azzurebubble.github.io/categories/%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/C/"/>
    
    <category term="Unity框架" scheme="https://azzurebubble.github.io/categories/%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/C/Unity%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Unity3D" scheme="https://azzurebubble.github.io/tags/Unity3D/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="游戏框架" scheme="https://azzurebubble.github.io/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>UnityEdior</title>
    <link href="https://azzurebubble.github.io/posts/ec874c57.html"/>
    <id>https://azzurebubble.github.io/posts/ec874c57.html</id>
    <published>2023-12-06T00:56:01.000Z</published>
    <updated>2024-04-20T01:10:48.249Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/UnityEditor/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%8A%A8%E5%9B%BE.gif" alt="插入排序"></p><blockquote><p>UnityEditor编辑器的代码必须放在Editor文件夹下，因为这个文件夹下的代码是不会被打包出去，只允许程序员在Unity编辑器下使用，如果不放在Editor这个文件夹下，打包时若包含UnityEditor的代码，会报错。</p></blockquote><h4 id="MenuItem">MenuItem</h4><h5 id="1-使用方法-MenuItem-“path”">1.使用方法:[MenuItem(“path”)]</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">EditorExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MenuItemExample</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// [MenuItem()] 修饰的必须是一个静态方法</span></span><br><span class="line">        <span class="comment">// 才会在Unity菜单栏出现先对应的按键</span></span><br><span class="line">        <span class="comment">// ()括号里的是这个方法在菜单栏的树形路径</span></span><br><span class="line">        [<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/EditorTest&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EditorTest</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;Hello Editor&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-Application-OpenURL-“path”-打开一个网址或者一个Application应用">2.Application.OpenURL(“path”) 打开一个网址或者一个Application应用</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/OpenBilibili&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenBilibili</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可以通过这个Api接口打开一个网址或者一个Application应用</span></span><br><span class="line">    Application.OpenURL(<span class="string">&quot;Http://bilibili.com&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-EditorUtility-RevealInFinder-“path”-打开一个指定的文件目录">3.EditorUtility.RevealInFinder(“path”) 打开一个指定的文件目录</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/打开策划目录&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenDesignFolder</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打开一个指定的文件目录 参数是一个文件的路径</span></span><br><span class="line">    EditorUtility.RevealInFinder(Application.dataPath.Replace(<span class="string">&quot;Assets&quot;</span>, <span class="string">&quot;Library&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-Menu-SetChecked-“path”-isChecked-可勾选的菜单栏">4.Menu.SetChecked(“path”,isChecked) 可勾选的菜单栏</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> openShotCut = <span class="literal">false</span>; <span class="comment">// 记录菜单栏勾选状态</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/快捷键开关&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ToggleShotCut</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    openShotCut = !openShotCut; <span class="comment">// 切换状态</span></span><br><span class="line">    Menu.SetChecked(<span class="string">&quot;EditorExtensions/MenuItem/快捷键开关&quot;</span>, openShotCut);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-MenuItem的快捷键设置">5.MenuItem的快捷键设置</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/EditorTestWithShotCut _c&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EditorTestWithShotCut</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 常用快捷键码</span></span><br><span class="line">    <span class="comment">// # -&gt; Shift &amp; -&gt; Alt % -&gt; Ctrl/Command</span></span><br><span class="line">    <span class="comment">// _a-z A-Z - a-z A-Z</span></span><br><span class="line">    Debug.Log(<span class="string">&quot;键盘C键的快捷键呼出菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/OpenBilibiliWithShotCut %#e&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenBilibiliWithShotCut</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    EditorUtility.RevealInFinder(Application.persistentDataPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-MenuItem-“path”-validate-true">6.[MenuItem(“path”, validate = true)]</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> openShotCut = <span class="literal">false</span>; <span class="comment">// 记录菜单栏勾选状态</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/快捷键开关&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ToggleShotCut</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    openShotCut = !openShotCut; <span class="comment">// 切换状态</span></span><br><span class="line">    Menu.SetChecked(<span class="string">&quot;EditorExtensions/MenuItem/快捷键开关&quot;</span>, openShotCut);</span><br><span class="line">&#125;</span><br><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/EditorTestWithShotCut _c&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EditorTestWithShotCut</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 常用快捷键码</span></span><br><span class="line">    <span class="comment">// # -&gt; Shift &amp; -&gt; Alt % -&gt; Ctrl/Command</span></span><br><span class="line">    <span class="comment">// _a-z A-Z - a-z A-Z</span></span><br><span class="line">    Debug.Log(<span class="string">&quot;键盘C键的快捷键呼出菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// openShotCut 为true时才能被使用</span></span><br><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/EditorTestWithShotCut %#e&quot;</span>, validate = true)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">EditorTestWithShotCutValidate</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> openShotCut;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/OpenBilibiliWithShotCut %#e&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenBilibiliWithShotCut</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    EditorUtility.RevealInFinder(Application.persistentDataPath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/OpenBilibiliWithShotCut %#e&quot;</span>, validate = true)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">OpenBilibiliWithShotCutValidate</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> openShotCut;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-EditorApplication-ExecuteMenuItem-“同名path”-复用MenuItem">7. EditorApplication.ExecuteMenuItem(“同名path”) 复用MenuItem</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/MenuItem/EditorTestWithShotCut _c&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EditorTestWithShotCut</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"> EditorApplication.ExecuteMenuItem(<span class="string">&quot;EditorExtensions/MenuItem/EditorTest&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="EditorWindow">EditorWindow</h4><h5 id="1-绘制一个编辑器窗口">1.绘制一个编辑器窗口</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;EditorExtensions/IMGUI/OpenGUILayoutExample&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenGUILayoutExample</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"> GUILayoutExample window = GetWindow&lt;GUILayoutExample&gt;();</span><br><span class="line"> window.Show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"> GUILayout.Label(<span class="string">&quot;Hello IMGUI&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/UnityEditor/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%8A%A8%E5%9B%BE.gif&quot; alt</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="Unity" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/Unity/"/>
    
    
    <category term="Unity" scheme="https://azzurebubble.github.io/tags/Unity/"/>
    
    <category term="UnityEditor" scheme="https://azzurebubble.github.io/tags/UnityEditor/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>算法——最短路径算法</title>
    <link href="https://azzurebubble.github.io/posts/17cfe08f.html"/>
    <id>https://azzurebubble.github.io/posts/17cfe08f.html</id>
    <published>2023-08-01T12:45:09.000Z</published>
    <updated>2024-04-20T01:10:50.275Z</updated>
    
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="最短路径算法" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="最短路径算法" scheme="https://azzurebubble.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法——最小生成树算法</title>
    <link href="https://azzurebubble.github.io/posts/3cf1d1bf.html"/>
    <id>https://azzurebubble.github.io/posts/3cf1d1bf.html</id>
    <published>2023-08-01T12:44:34.000Z</published>
    <updated>2024-04-20T01:10:50.274Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>线性表</strong>：由同种数据类型的数据元素组成的有序序列。一般用于存储由顺序关系的数据序列。</p><p><strong>树</strong>：树存储结构不允许存在环路。</p><p><strong>图</strong>：图存储结构中可以存在环路。</p><p><strong>连通图</strong>：从任一顶点到另一个顶点都至少存在一条通路。</p><p><strong>非连通图</strong>：只要有某两个顶点之间找不到通路。</p><p><strong>生成树</strong>：包含图中所有的顶点。任意顶点之间有且仅有一条通路。</p><p><strong>最小生成树</strong>：指的就是在连通网中找到的总权值最小的生成树。常用的两种算法：</p><ul><li><strong>普里姆（Prim）算法</strong></li><li><strong>克鲁斯卡尔（kruskal）算法</strong></li></ul></blockquote><h4 id="普里姆（Prim）算法">普里姆（Prim）算法</h4><blockquote><p><strong>普里姆（Prim）算法</strong>：任选一个顶点出发，每次都选权值最小的边的顶点与原顶点相连。</p><p>采用的是贪心算法的思想。</p><ul><li>时间复杂度=O(n<sup>2</sup>)（n 为顶点数）</li><li>适用于<strong>稠密图</strong>，算法思想是选择<strong>点</strong></li></ul><p><strong>实现思路：</strong></p><ol><li>将连通网中的所有顶点分为两类（假设为 A 类和 B 类）。初始状态下，所有顶点位于 B 类；</li><li>选择任意一个顶点，将其从 B 类移动到 A 类；</li><li>从 B 类的所有顶点出发，找出一条连接着 A 类中的某个顶点且权值最小的边，将此边连接着的 A 类中的顶点移动到 B 类；</li><li>重复执行第 3 步，直至 B 类中的所有顶点全部移动到 A 类，恰好可以找到 N-1 条边。</li></ol></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><blockquote></blockquote><hr><h4 id="克鲁斯卡尔（kruskal）算法">克鲁斯卡尔（kruskal）算法</h4><blockquote><p><strong>克鲁斯卡尔（kruskal）算法</strong>：把所有顶点包含在生成树中，对边进行排序，然后直接选取权值最小的边加入到新生成的树中，途中不能形成环，直到所有顶点都连通为止。</p><ul><li>时间复杂度=O(elog<sub>2</sub>e)（e 为边数）</li><li>适用于<strong>稀疏图</strong>，算法思想是选择<strong>边</strong></li></ul></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><blockquote></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;线性表&lt;/strong&gt;：由同种数据类型的数据元素组成的有序序列。一般用于存储由顺序关系的数据序列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;树&lt;/strong&gt;：树存储结构不允许存在环路。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图&lt;/strong&gt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="最小生成树算法" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="最小生成树算法" scheme="https://azzurebubble.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法——查找算法</title>
    <link href="https://azzurebubble.github.io/posts/f43b98cb.html"/>
    <id>https://azzurebubble.github.io/posts/f43b98cb.html</id>
    <published>2023-08-01T12:43:16.000Z</published>
    <updated>2024-04-20T01:10:50.275Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>查找</strong>（<code>Search</code>）：是在一个数据集合中查找满足给定条件的记录。对于查找问题来说，没有一种算法对于任何情况下都是合适的。</p><p><strong>查找表</strong>（<code>Search Table</code>）：是由同一类型的数据元素（或记录）构成的集合。对查找表经常进行的操作：</p><ol><li>查询某个数据元素是否在查找表中**（静态查找表）**</li><li>检索某个数据元素的属性**（静态查找表）**</li><li>向查找表中添加一个数据元素**（动态查找表）**</li><li>向查找表中删除一个数据元素**（动态查找表）**</li></ol></blockquote><hr><h4 id="顺序查找算法">顺序查找算法</h4><blockquote><p><strong>顺序查找</strong>：又称<strong>顺序搜索算法</strong>或者<strong>线性搜索算法</strong>，是所有查找算法中最基本、最简单的。</p><p><strong>基本思想</strong>：从查找表的一端开始，顺序扫描线性表，逐个同记录的关键字作比较，如果匹配成功，则查找成功；反之，直到最后一个关键字都没有匹配成功，则为失败。</p><ul><li>时间复杂度=O(n)，空间复杂度=O(1)；最好时间复杂度为O(1)；</li><li>适用于绝大多数场景，既可以在有序序列中查找目标元素，也可以在无序序列中查找目标元素。</li><li>静态查找表既可以使用顺序表表示，也可以使用链表结构表示。</li><li>优点：算法简单而且使用面广。</li><li>缺点：查找效率较低，特别是当待查找集合中元素较多时，不推荐使用顺序查找。</li></ul></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">10</span>, <span class="number">14</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">31</span>, <span class="number">33</span>, <span class="number">35</span>, <span class="number">42</span>, <span class="number">44</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span> index = linear_search(arr, <span class="number">33</span>);</span><br><span class="line">        <span class="keyword">if</span> (index != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;查找成功！序列为第<span class="subst">&#123;index + <span class="number">1</span>&#125;</span>个元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;查找失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">linear_search</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == <span class="keyword">value</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>查找成功！序列为第7个元素</p></blockquote><hr><h4 id="二分查找算法">二分查找算法</h4><blockquote><p><strong>二分查找</strong>：又称<strong>折半查找、二分搜索、折半搜索</strong>等，是在分治算法基础上设计出来的查找算法。</p><p><strong>基本思想</strong>：将表中间位置记录的关键字与查找关键字比较，若相等，则查找成功；否则利用中间位置记录将表分为前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。</p><ul><li>时间复杂度=O(log<sub>2</sub>n)，循环方式：空间复杂度=O(1)，递归方式：时间复杂度=O(log<sub>2</sub>n)</li><li>数组元素必须有序，查找的数值不能多个，只能一个。必须采用顺序存储结构。</li><li>优点：比较次数少，查找速度块，平均性能好。</li><li>缺点：必须要求待查表为有序表；插入删除困难。</li></ul></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">10</span>, <span class="number">14</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">31</span>, <span class="number">33</span>, <span class="number">35</span>, <span class="number">42</span>, <span class="number">44</span> &#125;;</span><br><span class="line">        <span class="comment">//int index = binary_search1(arr, 0, 9, 31);</span></span><br><span class="line">        <span class="built_in">int</span> index = binary_search2(arr, <span class="number">0</span>, <span class="number">9</span>, <span class="number">31</span>);</span><br><span class="line">        <span class="keyword">if</span> (index != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;查找成功！序列为第<span class="subst">&#123;index + <span class="number">1</span>&#125;</span>个元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;查找失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">binary_search1</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> start, <span class="built_in">int</span> end, <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> == arr[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> &lt; arr[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> binary_search1(arr, start, mid - <span class="number">1</span>, <span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> binary_search1(arr, mid + <span class="number">1</span>, end, <span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非递归</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">binary_search2</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> start, <span class="built_in">int</span> end, <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> left = start;</span><br><span class="line">        <span class="built_in">int</span> right = end;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == <span class="keyword">value</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">value</span> &lt; arr[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>查找成功！序列为第6个元素</p></blockquote><hr><h4 id="插值查找算法">插值查找算法</h4><blockquote><p><strong>插值查找</strong>：又称为<strong>插值搜索算法</strong>，是在二分查找算法的基础上改进的一种查找算法，将查找点的选择改进位自适应选择，提高查找效率。</p><p><strong>基本思想</strong>：插值查找类似平时我们查字典的时候，查一个以 s 开头的单词时，绝对不会用二分查找，从字典的中间第一页开始，因为我们知道它的大概位置是在字典的较后面部分，所以可以从后面的某处查起。我们先从首字母 s 的地方开始查找，然后再根据第二个字母在字母表中的位置，找到对应位置再继续查找，这样重复这个过程，直到找到我们查找的这个单词这就是插值查找的基本思想</p><ul><li>顺序存储的有序数列，根据关键字在数据中均匀分布。</li><li>比较元素的位置公式：</li></ul><p>$$<br>Mid = Begin + ( (End - Begin) / (A[End] - A[Begin]) ) * (X - A[Begin])<br>$$</p><ul><li>Mid：计算得出的元素的位置；</li><li>End：搜索区域内最后一个元素所在的位置；</li><li>Begin：搜索区域内第一个元素所在的位置；</li><li>X：要查找的目标元素；</li><li>A[]：表示整个待搜索序列。</li></ul></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span> index = interpolation_search(arr, <span class="number">0</span>, <span class="number">9</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">if</span> (index != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;查找成功！序列为第<span class="subst">&#123;index + <span class="number">1</span>&#125;</span>个元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;查找失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">interpolation_search</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> begin, <span class="built_in">int</span> end, <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (begin &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果查找表中只有一个元素，则比较该元素和待查元素的值</span></span><br><span class="line">        <span class="keyword">if</span> (begin == end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[begin] == <span class="keyword">value</span> ? begin : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据公式找到中间元素的所在位置</span></span><br><span class="line">        <span class="built_in">int</span> mid = ((end - begin) / (arr[end] - arr[begin]) * (<span class="keyword">value</span> - arr[begin]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归出口</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> == arr[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归查询</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> &lt; arr[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> interpolation_search(arr, begin, mid - <span class="number">1</span>, <span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> interpolation_search(arr, mid + <span class="number">1</span>, end, <span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>查找成功！序列为第5个元素</p></blockquote><hr><h4 id="哈希查找算法">哈希查找算法</h4><blockquote><p><strong>哈希查找</strong>：又称<strong>散列查找算法</strong>，是一种借助哈希表（散列表）查找目标元素的方法，查找效率最高时对应的时间复杂度位O(2)。</p><p><strong>哈希表</strong>：又称散列表，是一种存储结构，通常用来存储多个元素。和其它存储结构（线性表、树等）相比，哈希表查找目标元素的效率非常高。每个存储到哈希表中的元素，都配有一个唯一的标识（又称“索引”或者“键”），用户想查找哪个元素，凭借该元素对应的标识就可以直接找到它，无需遍历整个哈希表。</p><ul><li>适用于大多数场景，既支持有序序列，也支持无序序列。</li><li>常见的散列函数：直接定址法，除留余数法，平方取余法等</li><li>处理冲突的方法：开放定址法，线性探测法，拉链法等</li><li>影响冲突的主要三个因素：<ul><li>散列函数是否均匀</li><li>处理冲突的方法</li><li>散列表的装填因子</li></ul></li></ul></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">5</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">55</span>, <span class="number">50</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span>[] hashArr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>];</span><br><span class="line">        CreateHash(arr, hashArr);</span><br><span class="line">        <span class="built_in">int</span> index = hash_search(hashArr, <span class="number">20</span>);</span><br><span class="line">        <span class="keyword">if</span> (index != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;查找成功！序列为第<span class="subst">&#123;index + <span class="number">1</span>&#125;</span>个元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;查找失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">hash</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">value</span> % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建哈希表</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateHash</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span>[] hashArr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> i, index;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 通过哈希函数计算当前元素在哈希表中的位置</span></span><br><span class="line">            index = hash(arr[i]);</span><br><span class="line">            <span class="keyword">while</span> (hashArr[index] != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            hashArr[index] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">hash_search</span>(<span class="params"><span class="built_in">int</span>[] hashArr, <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过哈希函数计算得到待查元素的下标</span></span><br><span class="line">        <span class="built_in">int</span> hashIndex = hash(<span class="keyword">value</span>);</span><br><span class="line">        <span class="comment">// 如果发生冲突，则使用线性探测法向后探测</span></span><br><span class="line">        <span class="keyword">while</span> (hashArr[hashIndex] != <span class="keyword">value</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            hashIndex = (hashIndex + <span class="number">1</span>) % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 如果探测位置为空</span></span><br><span class="line">            <span class="keyword">if</span> (hashArr[hashIndex] == <span class="number">0</span> || hashIndex == hash(<span class="keyword">value</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hashIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>查找成功！序列为第2个元素</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;查找&lt;/strong&gt;（&lt;code&gt;Search&lt;/code&gt;）：是在一个数据集合中查找满足给定条件的记录。对于查找问题来说，没有一种算法对于任何情况下都是合适的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查找表&lt;/strong&gt;（&lt;code</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="查找算法" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="查找算法" scheme="https://azzurebubble.github.io/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法——归并/计数/基数/桶排序</title>
    <link href="https://azzurebubble.github.io/posts/23241932.html"/>
    <id>https://azzurebubble.github.io/posts/23241932.html</id>
    <published>2023-07-28T14:41:30.000Z</published>
    <updated>2024-04-20T01:10:50.268Z</updated>
    
    <content type="html"><![CDATA[<h4 id="归并排序">归并排序</h4><blockquote><p>归并排序：将两个或两个以上的有序子序列<code>归并</code>为一个有序序列。基于分治思想。</p><ul><li>时间复杂度=O(nlog<sub>2</sub>n)，空间复杂度=O(n)。稳定排序</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" alt="归并排序"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = &#123; <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;未排序前的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        merge_sort(arr, <span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 分割数组</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge_sort</span>(<span class="params"><span class="built_in">int</span>[] arr,<span class="built_in">int</span> start,<span class="built_in">int</span> end</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span>(arr == <span class="literal">null</span> || start &gt;= end)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">int</span> mid = (start + end) / <span class="number">2</span>; <span class="comment">// 取得数组中间值下标</span></span><br><span class="line">         <span class="comment">// 继续分割</span></span><br><span class="line">         merge_sort(arr,start,mid);</span><br><span class="line">         merge_sort(arr,mid + <span class="number">1</span>,end);</span><br><span class="line">         merge(arr,start,mid,end);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="function">privatr <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span>(<span class="params"><span class="built_in">int</span>[] arr,<span class="built_in">int</span> start,<span class="built_in">int</span> mid,<span class="built_in">int</span> end</span>)<span class="comment">// 1 1 2</span></span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">int</span> left = mid - start + <span class="number">1</span>; <span class="comment">// 获得左边数组元素个数 </span></span><br><span class="line">         <span class="built_in">int</span> right = end - mid; <span class="comment">// 获得右边数组元素个数 </span></span><br><span class="line">         <span class="built_in">int</span> leftArr = <span class="keyword">new</span> <span class="built_in">int</span>[left + <span class="number">1</span>]; </span><br><span class="line">         <span class="built_in">int</span> rightArr = <span class="keyword">new</span> <span class="built_in">int</span>[right + <span class="number">1</span>]; </span><br><span class="line">         <span class="built_in">int</span> i;</span><br><span class="line">         <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; left; i++)</span><br><span class="line">         &#123;</span><br><span class="line">             leftArr[i] = arr[start - <span class="number">1</span> + i]; </span><br><span class="line">         &#125;</span><br><span class="line">         leftArr[i] = <span class="number">2147483647</span>; <span class="comment">// 把数组最后一个元素设置为最大值</span></span><br><span class="line">         <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; right; i++)</span><br><span class="line">         &#123;</span><br><span class="line">             rightArr[i] = arr[mid + i];</span><br><span class="line">         &#125;</span><br><span class="line">         leftArr[i] = <span class="number">2147483647</span>; <span class="comment">// 把数组最后一个元素设置为最大值</span></span><br><span class="line">         <span class="built_in">int</span> j = <span class="number">0</span>;</span><br><span class="line">         i = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="built_in">int</span> k = start; k &lt; end; k++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(leftArr[i] &lt;= rightArr[j])</span><br><span class="line">             &#123;</span><br><span class="line">                 arr[k - <span class="number">1</span>] = leftArr[i];</span><br><span class="line">                 i++;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">                 arr[k - <span class="number">1</span>] = rightArr[j];</span><br><span class="line">                 j++;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>未排序前的数组：<br>5 7 3 8 6 9 4 2<br>排序后的数组：<br>2 3 4 5 6 7 8 9</p></blockquote><hr><h4 id="计数排序">计数排序</h4><blockquote><p>计数排序：通过统计序列中各个元素出现的次数，完成对整个序列的升序或降序排序。（元素之间最好是在0~9之间的数值差）</p><ul><li>时间复杂度=O(n+k)，空间复杂度=O(n+k)。稳定排序</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="计数排序"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = &#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;未排序前的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        countingSort(arr);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">get_max</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countingSort</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> length = arr.Length;</span><br><span class="line">        <span class="comment">// 找出数组中的最大值</span></span><br><span class="line">        <span class="built_in">int</span> max = get_max(arr);</span><br><span class="line">        <span class="built_in">int</span>[] array = <span class="keyword">new</span> <span class="built_in">int</span>[max + <span class="number">1</span>]; <span class="comment">// 创建一个统计元素出现次数的数组</span></span><br><span class="line">        <span class="built_in">int</span>[] output = <span class="keyword">new</span> <span class="built_in">int</span>[length]; <span class="comment">// 排序数组</span></span><br><span class="line">        <span class="comment">// 统计元素出现个数，存储在对应的位置上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            array[arr[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 累加出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; max + <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            array[i] += array[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据次数进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            output[array[arr[i]] - <span class="number">1</span>] = arr[i];</span><br><span class="line">            array[arr[i]]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 复制到arr数组中 2, 4, 1, 2, 5, 3, 4, 8, 7</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = output[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>未排序前的数组：<br>2 4 1 2 5 3 4 8 7<br>排序后的数组：<br>1 2 2 3 4 4 5 7 8</p></blockquote><hr><h4 id="基数排序">基数排序</h4><blockquote><p>基数排序：数字逐位比较。</p><ul><li>时间复杂度=O(n×m)，空间复杂度=O(n×m)。稳定排序。n:数据个数，m:数据位数。</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="基数排序"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = &#123; <span class="number">121</span>, <span class="number">432</span>, <span class="number">564</span>, <span class="number">23</span>, <span class="number">1</span>, <span class="number">45</span>, <span class="number">788</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;未排序前的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        radixSort(arr);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">getMax</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countingSort</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> place</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> length = arr.Length;</span><br><span class="line">        <span class="built_in">int</span>[] output = <span class="keyword">new</span> <span class="built_in">int</span>[length];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> max = (arr[<span class="number">0</span>] / place) % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (((arr[i] / place) % <span class="number">10</span>) &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = (arr[i] / place) % <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span>[] count = <span class="keyword">new</span> <span class="built_in">int</span>[max + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            count[(arr[i] / place) % <span class="number">10</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; max + <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一定要从后往前排</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            output[count[(arr[i] / place) % <span class="number">10</span>] - <span class="number">1</span>] = arr[i];</span><br><span class="line">            count[(arr[i] / place) % <span class="number">10</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = output[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> max = getMax(arr);</span><br><span class="line">        <span class="comment">// 根据最高位数，从低位依次进行计数排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; max / i &gt; <span class="number">0</span>; i *= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            countingSort(arr, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>未排序前的数组：<br>121 432 564 23 1 45 788<br>排序后的数组：<br>1 23 45 121 432 564 788</p></blockquote><hr><h4 id="桶-箱排序">桶/箱排序</h4><blockquote><p>桶/箱排序：待排序数组，分配到若干个桶，各自执行排序任务。是一种基于分治思想、效率很高的排序算法。(适用于数据范围较小且分布均匀的浮点数数据)</p><ul><li>时间复杂度=O(n+m+n(logn-logm))，空间复杂度=O(n+m)。稳定排序。n:数据个数，m:数据位数。</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E6%A1%B6%E6%8E%92%E5%BA%8F.gif" alt="桶排序"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;归并排序&quot;&gt;归并排序&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;归并排序：将两个或两个以上的有序子序列&lt;code&gt;归并&lt;/code&gt;为一个有序序列。基于分治思想。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度=O(nlog&lt;sub&gt;2&lt;/sub&gt;n)，空间复杂度=O(n)</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="排序算法" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="排序算法" scheme="https://azzurebubble.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法——选择排序</title>
    <link href="https://azzurebubble.github.io/posts/18d056c9.html"/>
    <id>https://azzurebubble.github.io/posts/18d056c9.html</id>
    <published>2023-07-25T16:08:58.000Z</published>
    <updated>2024-04-20T01:10:50.272Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简单选择排序">简单选择排序</h4><blockquote><p>简单选择排序：在待排序的数据中选出最大（小）的元素放在其最终的位置。</p><ul><li>时间复杂度=O(n<sup>2</sup>)，空间复杂度=O(1)。稳定排序。</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%8A%A8%E5%9B%BE.gif" alt="选择排序动图"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = &#123; <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;未排序前的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        selection_sort(arr);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selection_sort</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> length = arr.Length;</span><br><span class="line">        <span class="built_in">int</span> i, j, min;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            min = i; <span class="comment">// 把第一个元素假设为最小</span></span><br><span class="line">            <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 从第二个元素开始遍历到最后一个</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[min])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 如果期间出现小于最小元素的值，则交换位置</span></span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (min != i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[min];</span><br><span class="line">                arr[min] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>未排序前的数组：<br>5 7 3 8 6 9<br>排序后的数组：<br>3 5 6 7 8 9</p></blockquote><hr><h4 id="堆排序">堆排序</h4><blockquote><p>堆排序：堆的是指就是满足二叉树中任一非叶子结点均小于（大于）它的孩子结点的完全二叉树。</p><ul><li>时间复杂度=O(nlog<sub>2</sub>n)，空间复杂度=O(1)。不稳定排序。</li><li>小根堆：若n个元素的序列{a<sub>1</sub>a<sub>2</sub>…a<sub>n</sub>}满足a<sub>i</sub> ≤ a<sub>2i</sub>和a<sub>i</sub> ≤ a<sub>2i+1</sub>。</li><li>大根堆：若n个元素的序列{a<sub>1</sub>a<sub>2</sub>…a<sub>n</sub>}满足a<sub>i</sub> ≥ a<sub>2i</sub>和a<sub>i</sub> ≥ a<sub>2i+1</sub>。</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E5%A0%86%E6%8E%92%E5%BA%8F.gif" alt="堆排序"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = &#123; <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;未排序前的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        <span class="comment">//big_heap_sort(arr);</span></span><br><span class="line">        small_heap_sort(arr);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">big_heap_sort</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从树的第arr.Length / 2 - 1个结点开始建立大根堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = arr.Length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            big_heap_adjust(arr, i, arr.Length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = arr.Length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 把根结点与最后一个结点进行交换，把最大值放到最后</span></span><br><span class="line">            <span class="built_in">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">            <span class="comment">// 交换后，以根结点开始，重新调整为大根堆</span></span><br><span class="line">            big_heap_adjust(arr, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立大根堆：升序，最大值（根结点）与最后一个结点交换位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">big_heap_adjust</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> parent, <span class="built_in">int</span> length</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 临时存储根结点数值</span></span><br><span class="line">        <span class="built_in">int</span> temp = arr[parent];</span><br><span class="line">        <span class="comment">// 找到根结点的左孩子</span></span><br><span class="line">        <span class="built_in">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 孩子结点不大于数组长度</span></span><br><span class="line">        <span class="keyword">while</span> (child &lt; length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果右孩子在数组长度内 &amp;&amp; 右孩子 &gt; 左孩子</span></span><br><span class="line">            <span class="keyword">if</span> (child + <span class="number">1</span> &lt; length &amp;&amp; arr[child + <span class="number">1</span>] &gt; arr[child])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 设置为右孩子</span></span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果根结点 &gt; 孩子结点</span></span><br><span class="line">            <span class="keyword">if</span> (temp &gt; arr[child])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 退出+</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则，根结点与最大的孩子结点交换位置</span></span><br><span class="line">            arr[parent] = arr[child];</span><br><span class="line">            <span class="comment">// 根结点设置为交换后的孩子结点下标</span></span><br><span class="line">            parent = child;</span><br><span class="line">            <span class="comment">// 找到新的左孩子下标</span></span><br><span class="line">            child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时parent已为最小的孩子结点，把temp放到此位置上</span></span><br><span class="line">        arr[parent] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">small_heap_sort</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = arr.Length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            small_heap_sort(arr, i, arr.Length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = arr.Length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">            small_heap_sort(arr, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小根堆:降序，最小值（根结点）与最后一个结点交换位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">small_heap_sort</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> parent, <span class="built_in">int</span> length</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> temp = arr[parent];</span><br><span class="line">        <span class="built_in">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (child &lt; length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (child + <span class="number">1</span> &lt; length &amp;&amp; arr[child + <span class="number">1</span>] &lt; arr[child])</span><br><span class="line">            &#123;</span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp &lt; arr[child])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[parent] = arr[child];</span><br><span class="line">            parent = child;</span><br><span class="line">            child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[parent] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;简单选择排序&quot;&gt;简单选择排序&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;简单选择排序：在待排序的数据中选出最大（小）的元素放在其最终的位置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度=O(n&lt;sup&gt;2&lt;/sup&gt;)，空间复杂度=O(1)。稳定排序。&lt;/li&gt;
&lt;/u</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="排序算法" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="排序算法" scheme="https://azzurebubble.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="选择排序" scheme="https://azzurebubble.github.io/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序算法——插入排序</title>
    <link href="https://azzurebubble.github.io/posts/cd5503e2.html"/>
    <id>https://azzurebubble.github.io/posts/cd5503e2.html</id>
    <published>2023-07-24T11:43:40.000Z</published>
    <updated>2024-04-20T01:10:50.271Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在有序序列中插入一个元素，保持序列有序，有序长度不断增加。</p></blockquote><h4 id="直接插入排序">直接插入排序</h4><blockquote><p>直接插入排序：采用顺序查找法查找插入位置。</p><ul><li>原始数据越接近有序，排序速度越快。</li><li>时间复杂度=O(n<sup>2</sup>)，空间复杂度=O(1)。稳定排序。</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%8A%A8%E5%9B%BE.gif" alt="插入排序"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = &#123; <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;未排序前的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        insert_sort(arr);</span><br><span class="line">        <span class="comment">// insert_sort1(arr);</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for + while 实现</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert_sort</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> length = arr.Length;</span><br><span class="line">        <span class="comment">// 以第一个元素为基准元素，下标为0</span></span><br><span class="line">        <span class="comment">// 从第二个元素开始进行直接插入排序，下标为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 临时保存需要进行插入的元素</span></span><br><span class="line">            <span class="built_in">int</span> insert_elem = arr[i];</span><br><span class="line">            <span class="comment">// 记录当前需要进行插入排序的元素的位置</span></span><br><span class="line">            <span class="built_in">int</span> position = i;</span><br><span class="line">            <span class="comment">// 从 position 向前遍历，大于插入元素则后移，直至找到目标元素插入位置</span></span><br><span class="line">            <span class="keyword">while</span> (position &gt; <span class="number">0</span> &amp;&amp; arr[position - <span class="number">1</span>] &gt; insert_elem)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 后移</span></span><br><span class="line">                arr[position] = arr[position - <span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 向前遍历</span></span><br><span class="line">                position--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (position != i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将目标元素插入到指定位置</span></span><br><span class="line">                arr[position] = insert_elem;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 两个 for 循环</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert_sort1</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> i, j;</span><br><span class="line">        <span class="built_in">int</span> length = arr.Length;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 临时存储目标元素</span></span><br><span class="line">            <span class="built_in">int</span> temp = arr[i];</span><br><span class="line">            <span class="comment">// 从目标元素的前一个元素开始向前遍历</span></span><br><span class="line">            <span class="comment">// 直到遍历下标 &lt;= 0，并且遍历元素大于目标元素时</span></span><br><span class="line">            <span class="comment">// 将大于目标元素的元素向后移</span></span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将目标元素插入到指定位置</span></span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>未排序前的数组：<br>5 7 3 8 6 9<br>排序后的数组：<br>3 5 6 7 8 9</p></blockquote><hr><h4 id="折半插入排序">折半插入排序</h4><blockquote><p>折半插入排序：减少比较次数，但没有减少移动次数。</p><ul><li><p>平均性能优于直接插入排序。</p></li><li><p>时间复杂度=O(n<sup>2</sup>)，空间复杂度=O(1)。稳定排序。</p></li></ul></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = &#123; <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;未排序前的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        half_sort(arr);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">half_sort</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> temp, low, high, mid;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            low = <span class="number">0</span>; <span class="comment">// 左边第一个元素位置</span></span><br><span class="line">            high = i - <span class="number">1</span>; <span class="comment">// 待排元素的前一个元素</span></span><br><span class="line">            temp = arr[i]; <span class="comment">// 待排元素临时存储</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt;= high) <span class="comment">// 当 high &lt; low 时退出循环</span></span><br><span class="line">            &#123;</span><br><span class="line">                mid = low + (high - low) / <span class="number">2</span>; <span class="comment">// 取排好数组中的中间元素位置</span></span><br><span class="line">                <span class="keyword">if</span> (arr[mid] &gt; temp)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 如果中间元素大于待排元素，则high向前移动，继续比较</span></span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 如果中间元素小于待排元素，则low向后移动，继续比较</span></span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = i - <span class="number">1</span>; j &gt;= high + <span class="number">1</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[high + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>未排序前的数组：<br>5 7 3 8 6 9<br>排序后的数组：<br>3 5 6 7 8 9</p></blockquote><hr><h4 id="希尔排序">希尔排序</h4><blockquote><p>希尔排序：先将整个代排序列分割成若干子序列，分别进行直接插入排序，待整个序列中的记录<code>基本有序</code>时，再对全体记录进行一次直接插入排序。</p><ul><li><p>缩小增量，多遍插入排序。</p></li><li><p>时间复杂度=O(n<sup>1.25</sup>~1.6n<sup>1.25</sup>)，空间复杂度=O(1)，不稳定排序。不适合在链式存储结构上实现。</p></li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif" alt="希尔排序"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = &#123; <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;未排序前的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        shell_sort(arr);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shell_sort</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> length = arr.Length;</span><br><span class="line">        <span class="built_in">int</span> interval = <span class="number">1</span>; <span class="comment">// 初始化间隔为1</span></span><br><span class="line">        <span class="comment">// 计算最大间隔</span></span><br><span class="line">        <span class="keyword">while</span> (interval &lt; length / <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            interval = interval * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据间隔数，不断划分子序列，并对各子序列排序</span></span><br><span class="line">        <span class="keyword">while</span> (interval &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> i, j, temp;</span><br><span class="line">            <span class="keyword">for</span> (i = interval; i &lt; length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = arr[i];</span><br><span class="line">                j = i;</span><br><span class="line">                <span class="keyword">while</span> (j &gt; interval - <span class="number">1</span> &amp;&amp; arr[j - interval] &gt;= temp)</span><br><span class="line">                &#123;</span><br><span class="line">                    arr[j] = arr[j - interval];</span><br><span class="line">                    j -= interval;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j != i)</span><br><span class="line">                &#123;</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算新间隔</span></span><br><span class="line">            interval = (interval - <span class="number">1</span>) / <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>未排序前的数组：<br>5 7 3 8 6 9<br>排序后的数组：<br>3 5 6 7 8 9</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在有序序列中插入一个元素，保持序列有序，有序长度不断增加。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;直接插入排序&quot;&gt;直接插入排序&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;直接插入排序：采用顺序查找法查找插入位置。&lt;/p&gt;
&lt;ul&gt;
&lt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="排序算法" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="排序算法" scheme="https://azzurebubble.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="插入排序" scheme="https://azzurebubble.github.io/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序算法——交换排序</title>
    <link href="https://azzurebubble.github.io/posts/327191a2.html"/>
    <id>https://azzurebubble.github.io/posts/327191a2.html</id>
    <published>2023-07-20T11:42:10.000Z</published>
    <updated>2024-04-20T01:10:50.269Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>交换排序基本思想：两两比较，如果发生逆序则交换，直到所有记录都排好序为止。</p></blockquote><h4 id="冒泡排序">冒泡排序</h4><blockquote><p>冒泡排序：每趟不断将记录两两比较，并按“前小后大”规则交换。</p><ul><li>事件复杂度=O(n<sup>2</sup>)，空间复杂的=O(1)。稳定排序。</li><li>优点：每趟结束，不仅能挤出一个最大值到最后位置，还能同时部分理顺其他元素。</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%8A%A8%E5%9B%BE.gif" alt="冒泡排序动图"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] list = &#123; <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;未排序前的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(list[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        Bubble_sort(list);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(list[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Bubble_sort</span>(<span class="params"><span class="built_in">int</span>[] list</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> temp;</span><br><span class="line">        <span class="comment">// 比较 length - 1 趟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Length - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 每趟比较次数比前一趟少一次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; list.Length - <span class="number">1</span> - i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 两两比较元素，小的前移，大的后移</span></span><br><span class="line">                <span class="keyword">if</span> (list[j] &gt; list[j + <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    temp = list[j];</span><br><span class="line">                    list[j] = list[j + <span class="number">1</span>];</span><br><span class="line">                    list[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>未排序前的数组：<br>1 5 9 7 3<br>排序后的数组：<br>1 3 5 7 9</p></blockquote><hr><h4 id="快速排序">快速排序</h4><blockquote><p>快速排序（分治算法思想）：任取一个元素为中心，所有比它小的元素一律前放，大的后放，形成左右两个子表。</p><ul><li>最坏情况，时间复杂度=O(n<sup>2</sup>)。理想状态，时间复杂度=O(nlog<sub>2</sub>n)，空间复杂度=O(1)，不稳定排序，不是自然排序。</li><li>不适于原本有序或基本有序的记录序列进行排序。</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" alt="快速排序"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 挖坑法：用一个临时变量存储基准元素</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = &#123; <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;未排序前的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        quick_sort(arr, <span class="number">0</span>, arr.Length - <span class="number">1</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick_sort</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> left, <span class="built_in">int</span> right</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> l = left; <span class="comment">// 记录左指针元素</span></span><br><span class="line">        <span class="built_in">int</span> r = right; <span class="comment">// 记录右指针元素</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 递归退出条件：左指针 &gt;= 右指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> pivot = arr[left]; <span class="comment">// 以数组左边第一个元素为基准元素</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从数组最右开始，找到第一个比基准元素小的元素</span></span><br><span class="line">            <span class="keyword">while</span> (arr[right] &gt; pivot &amp;&amp; left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 把右边第一个比基准小的元素，放到数组左边</span></span><br><span class="line">                arr[left++] = arr[right];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从最左边找到第一个比基准元素大的元素</span></span><br><span class="line">            <span class="keyword">while</span> (arr[left] &lt; pivot &amp;&amp; left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 把左边第一个比基准大的元素，放到数组右边</span></span><br><span class="line">                arr[right--] = arr[left];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当左右指针重合退出 while 后，把基准元素放到当前 left 位置</span></span><br><span class="line">        arr[left] = pivot;</span><br><span class="line">        quick_sort(arr, l, left - <span class="number">1</span>); <span class="comment">// 递归调用快速排序，排好基准元素左边的元素</span></span><br><span class="line">        quick_sort(arr, left + <span class="number">1</span>, r); <span class="comment">// 递归调用快速排序，排好基准元素右边的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hoare版：基本思想就是用两个指针分别指向待排序数组的开头和结尾。</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = &#123; <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;未排序前的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        Hoare_quick_sort(arr, <span class="number">0</span>, arr.Length - <span class="number">1</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Hoare_quick_sort</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> left, <span class="built_in">int</span> right</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> pivot = left; <span class="comment">// 存储基准元素的下标</span></span><br><span class="line">        <span class="built_in">int</span> l = left;</span><br><span class="line">        <span class="built_in">int</span> r = right;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= arr[pivot])</span><br><span class="line">            &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= arr[pivot])</span><br><span class="line">            &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, pivot, left);</span><br><span class="line">        Hoare_quick_sort(arr, l, left - <span class="number">1</span>);</span><br><span class="line">        Hoare_quick_sort(arr, left + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> left, <span class="built_in">int</span> right</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> temp = arr[left];</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        arr[right] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>未排序前的数组：<br>5 7 3 8 6 9<br>排序后的数组：<br>3 5 6 7 8 9</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;交换排序基本思想：两两比较，如果发生逆序则交换，直到所有记录都排好序为止。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;冒泡排序&quot;&gt;冒泡排序&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;冒泡排序：每趟不断将记录两两比较，并按“前小后大”规则交</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="排序算法" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="排序算法" scheme="https://azzurebubble.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="交换排序" scheme="https://azzurebubble.github.io/tags/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法——回溯算法</title>
    <link href="https://azzurebubble.github.io/posts/69848392.html"/>
    <id>https://azzurebubble.github.io/posts/69848392.html</id>
    <published>2023-07-15T13:00:58.000Z</published>
    <updated>2024-04-20T01:10:50.274Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>回溯算法的基本思想：实际上是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现不满足求解条件时，就“回溯”返回，尝试别的路径。是一种选优搜索法，按选优条件向前搜索，以达到目标。</p><p>回溯算法经常以递归的方式实现，用来解决以下3类问题：</p><ul><li>决策问题：从众多选择中找到一个可行的解决方案；</li><li>优化问题：从众多选择中找到一个最佳的解决方案；</li><li>枚举问题：找出解决问题的所有方案。</li></ul><p>经典问题有：N皇后问题，迷宫问题等。</p></blockquote><h5 id="找到从A到K的行走路线">找到从A到K的行走路线</h5><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E2%80%94%E6%89%BE%E4%BB%8EA-K%E7%9A%84%E8%A1%8C%E8%B5%B0%E8%B7%AF%E7%BA%BF.png" alt="回溯算法—找从A-K的行走路线"></p><h5 id="解题思路：">解题思路：</h5><blockquote><p>所谓“回溯”，其实就是回退、倒退的意思。仍以图 1 为例，回溯算法查找从 A 到 K 路线的过程是：</p><ul><li>从 A 出发，先选择 A-B 路线；继续从 B 出发，先选择 B-C 路线；到达 C 点后发现无路可选，表明当前路线无法达到 K 点，该算法会立刻回退到上一个节点，也就是 B 点；</li><li>从 B 点出发，选择 B-D 路线，达到 D 点后发现无法到达 K 点，该算法再回退到 B 点；</li><li>从 B 点出发已经没有新的线路可以选择，该算法再次回退到 A 点，选择新的 A-E 路线；</li><li>继续以同样的方式测试 A-E-F-G、A-E-F-H、A-E-J-I 这 3 条线路后，最终找到 A-E-J-K 路线。</li></ul></blockquote><h3 id="回溯算法的经典应用">回溯算法的经典应用</h3><h4 id="迷宫问题">迷宫问题</h4><blockquote><p>迷宫问题是指：在给定区域内，找到一条甚至所有从某个位置到另一个位置的移动路线。如下图：在白色区域内找到一条（甚至所有）从起点到终点的路线。</p><p>解决思路：</p><ol><li>从当前位置开始，分别判断是否可以向 4 个方向（上、下、左、右）移动：</li><li>选择一个方向并移动到下个位置。判断此位置是否为终点，如果是就表示找到了一条移动路线；如果不是，在当前位置继续判断是否可以向 4 个方向移动；</li><li>如果 4 个方向都无法移动，则回退至之前的位置，继续判断其它的方向；</li><li>重复 2、3 步，最终要么成功找到可行的路线，要么回退至起点位置，表明所有的路线都已经判断完毕。</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98.png" alt="迷宫问题"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 1 表示白色区域，用 0 表示黑色区域。</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> ROW = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> COL = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> find = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">char</span>[,] maze = <span class="keyword">new</span> <span class="built_in">char</span>[,]</span><br><span class="line">        &#123;</span><br><span class="line">            &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        maze_puzzle(maze, <span class="number">0</span>, <span class="number">0</span>, ROW - <span class="number">1</span>, COL - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!find)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;该迷宫无解&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 起点：(row, col)     终点：(outRow, outCol)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maze_puzzle</span>(<span class="params"><span class="built_in">char</span>[,] maze, <span class="built_in">int</span> row, <span class="built_in">int</span> col, <span class="built_in">int</span> outRow, <span class="built_in">int</span> outCol</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        maze[row, col] = <span class="string">&#x27;Y&#x27;</span>; <span class="comment">// 将走过的区域标记为 Y</span></span><br><span class="line">        <span class="comment">// 如果走到终点，则表明起点到终点有路线</span></span><br><span class="line">        <span class="keyword">if</span> (row == outRow &amp;&amp; col == outCol)</span><br><span class="line">        &#123;</span><br><span class="line">            find = <span class="literal">true</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;成功走出迷宫，路线图是：&quot;</span>);</span><br><span class="line">            printMaze(maze);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断上方是否可移动</span></span><br><span class="line">        <span class="keyword">if</span> (canMove(maze, row - <span class="number">1</span>, col))</span><br><span class="line">        &#123;</span><br><span class="line">            maze_puzzle(maze, row - <span class="number">1</span>, col, outRow, outCol);</span><br><span class="line">            <span class="comment">// 如果程序不结束，则此路不通，恢复该区域的标志</span></span><br><span class="line">            maze[row - <span class="number">1</span>, col] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断左方是否可移动</span></span><br><span class="line">        <span class="keyword">if</span> (canMove(maze, row, col - <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            maze_puzzle(maze, row, col - <span class="number">1</span>, outRow, outCol);</span><br><span class="line">            <span class="comment">// 如果程序不结束，则此路不通，恢复该区域的标志</span></span><br><span class="line">            maze[row, col - <span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断下方是否可移动</span></span><br><span class="line">        <span class="keyword">if</span> (canMove(maze, row + <span class="number">1</span>, col))</span><br><span class="line">        &#123;</span><br><span class="line">            maze_puzzle(maze, row + <span class="number">1</span>, col, outRow, outCol);</span><br><span class="line">            <span class="comment">// 如果程序不结束，则此路不通，恢复该区域的标志</span></span><br><span class="line">            maze[row + <span class="number">1</span>, col] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断右方是否可移动</span></span><br><span class="line">        <span class="keyword">if</span> (canMove(maze, row, col + <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            maze_puzzle(maze, row, col + <span class="number">1</span>, outRow, outCol);</span><br><span class="line">            <span class="comment">// 如果程序不结束，则此路不通，恢复该区域的标志</span></span><br><span class="line">            maze[row, col + <span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">canMove</span>(<span class="params"><span class="built_in">char</span>[,] maze, <span class="built_in">int</span> row, <span class="built_in">int</span> col</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 判断输入的位置是否在迷宫范围内，且可移动，且还未移动过</span></span><br><span class="line">        <span class="keyword">return</span> row &gt;= <span class="number">0</span> &amp;&amp; row &lt;= ROW - <span class="number">1</span> &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt;= COL - <span class="number">1</span></span><br><span class="line">            &amp;&amp; maze[row, col] != <span class="string">&#x27;0&#x27;</span> &amp;&amp; maze[row, col] != <span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMaze</span>(<span class="params"><span class="built_in">char</span>[,] maze</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; ROW; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; COL; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(maze[i, j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>成功走出迷宫，路线图是：<br>Y 0 Y Y Y<br>Y Y Y 0 Y<br>1 0 0 Y Y<br>1 0 0 Y 0<br>1 0 0 Y Y</p></blockquote><h4 id="N皇后问题">N皇后问题</h4><blockquote><p>N皇后问题源自国际象棋，所有棋子中权力最大的称为皇后，它可以直着走、横着走、斜着走（沿45度角），可以攻击移动途中遇到的任何棋子。N皇后问题的具体内容是：如何将N个皇后摆放在N*N的棋盘中，使它们无法相互攻击。如下图所示。</p><p>解决思路：</p><p>要想使 N 个皇后不相互攻击，应将它们放置在不同的行、不同的列、还不能位于同一条 45°（或 135°）角的斜线上。</p><p>回溯算法解决N皇后问题的具体思路是：将 N 个皇后逐一放置在不同的行，以“回溯”的方式逐一测试出每行皇后所在行的具体位置，最终确定所有皇后的位置。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98.png" alt="N皇后问题"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span>[] q = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">20</span>]; <span class="comment">// 每个皇后的所在列数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> count = <span class="number">0</span>; <span class="comment">// count 种解决方案</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">&quot;请输入皇后的个数：&quot;</span>);</span><br><span class="line">        <span class="built_in">string</span> sc = Console.ReadLine();</span><br><span class="line">        <span class="built_in">int</span> n = <span class="built_in">int</span>.Parse(sc);</span><br><span class="line">        n_queues(<span class="number">1</span>, n);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;共有 &quot;</span> + count + <span class="string">&quot; 种摆放方式&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> N皇后算法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;k&quot;&gt;</span>第几行数<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;n&quot;&gt;</span>皇后个数<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">n_queues</span>(<span class="params"><span class="built_in">int</span> k, <span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> j;</span><br><span class="line">        <span class="comment">// 递归出口：当前行数大于皇后个数</span></span><br><span class="line">        <span class="keyword">if</span> (k &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            print(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 尝试第 k 行的每一列，找到符合要求的列</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (isSafe(k, j))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 存进数组中保存</span></span><br><span class="line">                    q[k] = j;</span><br><span class="line">                    <span class="comment">// 确认第 k 行皇后位置后，继续下一行的皇后的位置判断。</span></span><br><span class="line">                    n_queues(k + <span class="number">1</span>, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">isSafe</span>(<span class="params"><span class="built_in">int</span> k, <span class="built_in">int</span> j</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> i;</span><br><span class="line">        <span class="comment">// 判断是否有其他皇后位置在同一列，或者位于该位置的斜线位置上，如果有，则不能放</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 同一斜线判断规则：|行号差值| = |列号差值|</span></span><br><span class="line">            <span class="keyword">if</span> (q[i] == j || Math.Abs(i - k) == Math.Abs(q[i] - j))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> i, j;</span><br><span class="line">        count++;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;第 &quot;</span> + count + <span class="string">&quot; 个解为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// 行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= n; j++) <span class="comment">// 列</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (q[i] != j)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.Write(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Console.Write(<span class="string">&quot;Q&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输入：4</p><p>第 1 个解为：<br>xxQxx<br>xxxxQ<br>xQxxx<br>xxxQx</p><p>第 2 个解为：<br>xxxQx<br>xQxxx<br>xxxxQ<br>xxQxx</p><p>共有 2 种摆放方式</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;回溯算法的基本思想：实际上是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现不满足求解条件时，就“回溯”返回，尝试别的路径。是一种选优搜索法，按选优条件向前搜索，以达到目标。&lt;/p&gt;
&lt;p&gt;回溯算法经常以递归的方式实现，用来解</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="算法" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="算法" scheme="https://azzurebubble.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="回溯算法" scheme="https://azzurebubble.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法——动态规划算法</title>
    <link href="https://azzurebubble.github.io/posts/d7fe9934.html"/>
    <id>https://azzurebubble.github.io/posts/d7fe9934.html</id>
    <published>2023-06-07T08:18:24.000Z</published>
    <updated>2024-04-20T01:10:50.272Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>动规的基本思想：动规的实质是分治思想和解决冗余。将原问题分解为若干子问题，通过解决子问题的最优解来得到原问题的最优解。是一种解决多阶段决策问题的优化方法。</p><p>与分治算法的不同之处在于，分治算法拆分出的小问题之间是相互独立的，而动规拆分的小问题之间是相互关联的，想要解决问题 A ，就必须先解决问题 B 和 C。</p><p>动态规划算法的关键在于将原问题分解为子问题，并利用子问题的最优解来构造原问题的最优解。通过状态转移方程的定义和递推求解过程，动态规划算法能够避免重复计算，提高问题求解的效率。它适用于那些具有重叠子问题和最优子结构性质的问题，如最短路径问题、背包问题、序列比对等。（空间换时间的算法）</p></blockquote><h3 id="动规算法的解题思路">动规算法的解题思路</h3><p>用 f(n) 表示凑齐面值 n 所需纸币的最少数量，面值 15 的拼凑方案有 3 种，分别是：</p><ul><li>f(15) = f(14) +1：挑选一张面值为 1 的纸币，f(14) 表示拼凑出面值 14 所需要的最少的纸币数量；</li><li>f(15) = f(8) + 1：挑选一张面值为 7 的纸币，f(8) 表示拼凑出面值 8 所需要的最少的纸币数量；</li><li>f(15) = f(5) + 1：选择一张面值为10 的纸币，f(5) 表示拼凑出面值 5 所需要的最少的纸币数量。</li></ul><p>也就是说，f(14)+1、f(8)+1 和 f(5)+1 三者中的最小值就是最优的拼凑方案。采用同样的方法，继续求 f(14)、f(8)、f(5) 的值：</p><ul><li>f(5) = f(4) + 1；</li><li>f(8) = f(7) + 1 = f(1) +1；</li><li>f(14) = f(13)+1 = f(7) + 1 = f(4) +1。</li></ul><h3 id="动态规划算法的经典应用">动态规划算法的经典应用</h3><h4 id="0-1背包问题">0-1背包问题</h4><blockquote><p>虚拟一个场景，商店中拥有 5 件商品，它们各自的重量和收益分别是：</p><ul><li>商品 1：重量 1 斤，收益 1 元；</li><li>商品 2：重量 2 斤，收益 6 元；</li><li>商品 3：重量 5 斤，收益 18 元；</li><li>商品 4：重量 6 斤，收益 22 元；</li><li>商品 5：重量 7 斤，收益 28 元。</li></ul><p>所有商品不可再分，顾客要么“整件”购买商品，要么放弃购买。一个小偷想窃取商品，他的背包只能装 11 斤商品，如何选择商品才能获得最大的收益呢？</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98_1.png" alt="01背包问题_1"></p><blockquote><p>表格中，wi 表示第 i 件商品的重量，vi 表示第 i 件商品的收益值。承重不同的各个背包尚未装入商品时，对应的收益值都为 0。</p></blockquote><ol><li><p>首先考虑将商品一装入各个背包，除了承重值为 0 的背包，其它背包都能装入，且与不装任何商品相比，装入商品一后各个背包的收益更大</p><p><img src="https://cdn.staticaly.com/gh/AzureBubble/PicBed@main/showImg/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98_2.png" alt="01背包问题_2"></p><p>我们用 f(n) 表示承重值为 n 的背包对应的最大收益。从算法的角度，各个背包收益值是这样计算的：f(1)=1+f(0)、f(2)=1+f(1)、…、f(11)=1+f(10)，其中等号右侧表达式中的 1 指的是商品一的收益值，f(0) - f(10) 指的是不装任何商品时承重分别为 0 - 10 的背包对应的收益值，借助表格可以看到，它们的值都为 0。</p></li><li><p>考虑将商品二装入各个背包，除了承重值为 0 和 1 的背包，其它背包都可以装入。我们可以计算出它们各自对应的收益值：</p><blockquote><p>f(2) = 6 + f(0) = 6<br>f(3) = 6 + f(1) = 7<br>f(4) = 6 + f(2) = 7<br>…<br>f(9) = 6 + f(7) = 7<br>f(10) = 6 + f(8) = 7<br>f(11) = 6 + f(9) = 7</p></blockquote><p>等号右侧 f(0)~f(9) 的值是表 2 中装入商品一的各个背包对应的收益值。相比装入商品一统计的各个背包的收益值，装入商品二能使提高各个背包的收益。更新后的表格为：</p><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98_3.png" alt="01背包问题_3"></p></li><li><p>考虑将商品三装入各个背包，除了承重值为小于 5 的背包，其它背包都可以装入。我们可以计算出它们各自对应的收益值：</p><blockquote><p>f(5) = 18 + f(0) = 18<br>f(6) = 18 + f(1) = 19<br>f(7) = 18 + f(2) = 24<br>f(8) = 18 + f(3) = 25<br>f(9) = 18 + f(4) = 25<br>f(10) = 18 + f(5) = 25<br>f(11) = 18 + f(6) = 25</p></blockquote><p>等号右侧 f(0)~f(6) 的值是表 2 中装入商品二的各个背包对应的收益值。和装入商品二时统计的各个背包的收益值相比，装入商品三能提高各个背包的收益。更新后的表格为：</p><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98_4.png" alt="01背包问题_4"></p></li><li><p>采用同样的方法，我们可以将表 4 中缺失的数据补全，最终得到的表格为：</p><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98_5.png" alt="01背包问题_5"></p><blockquote><p>注意，并不是每试图装入一个新商品，背包的收益一定会提高。举个例子，承重为 7 斤的背包装入商品四时的最大收益是：f(7) = 22+f(1) = 23，装入商品三时最大的收益值为：f(7) = 18+f(2) = 24。因此，上图中承重 7 斤的背包装入商品 4 时对应的收益值仍为 24，并未发生改变。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> N = <span class="number">5</span>; <span class="comment">// 商品种类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> W = <span class="number">11</span>; <span class="comment">// 背包的最大承重</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 动态规划算法解决01背包问题</span></span><br><span class="line"><span class="comment">     * result[N + 1][W + 1]：存储最终的结果</span></span><br><span class="line"><span class="comment">     * w[N + 1]：存储各商品的重量</span></span><br><span class="line"><span class="comment">     * v[N + 1]：存储各商品的价值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] w = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span>[] v = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">18</span>, <span class="number">22</span>, <span class="number">28</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span>[,] result = <span class="keyword">new</span> <span class="built_in">int</span>[N + <span class="number">1</span>, W + <span class="number">1</span>];</span><br><span class="line">        knapsack01(result, w, v);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;背包承重为 &#123;0&#125;,最大收益为 &#123;1&#125;&quot;</span>, W, result[N, W]);</span><br><span class="line">        Console.Write(<span class="string">&quot;选择了：&quot;</span>);</span><br><span class="line">        <span class="keyword">select</span>(result, w, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">knapsack01</span>(<span class="params"><span class="built_in">int</span>[,] result, <span class="built_in">int</span>[] w, <span class="built_in">int</span>[] v</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 逐个遍历每个商品</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 求出从 1 到 W 各个称重对应的最大收益</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= W; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果背包载重小于商品总重量，则该商品无法放进背包，收益不变</span></span><br><span class="line">                <span class="keyword">if</span> (j &lt; w[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    result[i, j] = result[i - <span class="number">1</span>, j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 比较装入该商品和不装该商品，哪种情况获得的收益更大，记录最大收益值</span></span><br><span class="line">                    result[i, j] = result[i - <span class="number">1</span>, j] &gt; (v[i] + result[i - <span class="number">1</span>, j - w[i]])</span><br><span class="line">                        ? result[i - <span class="number">1</span>, j] : (v[i] + result[i - <span class="number">1</span>, j - w[i]]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select</span>(<span class="params"><span class="built_in">int</span>[,] result, <span class="built_in">int</span>[] w, <span class="built_in">int</span>[] v</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> n = N;</span><br><span class="line">        <span class="built_in">int</span> bagw = W;</span><br><span class="line">        <span class="comment">// 逐个商品进行判断</span></span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果在指定载重量下，该商品对应的收益和上一个商品对应的收益相同，则表明未选中</span></span><br><span class="line">            <span class="keyword">if</span> (result[n, bagw] == result[n - <span class="number">1</span>, bagw])</span><br><span class="line">            &#123;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 输出被选用商品的重量和价值</span></span><br><span class="line">                Console.Write(<span class="string">$&quot;(<span class="subst">&#123;w[n]&#125;</span>,<span class="subst">&#123;v[n]&#125;</span>) &quot;</span>);</span><br><span class="line">                bagw = bagw - w[n];</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;动规的基本思想：动规的实质是分治思想和解决冗余。将原问题分解为若干子问题，通过解决子问题的最优解来得到原问题的最优解。是一种解决多阶段决策问题的优化方法。&lt;/p&gt;
&lt;p&gt;与分治算法的不同之处在于，分治算法拆分出的小问题之间是相互独立的，而动规拆分的</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="算法" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="算法" scheme="https://azzurebubble.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划算法" scheme="https://azzurebubble.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法——贪心算法</title>
    <link href="https://azzurebubble.github.io/posts/fa27ba66.html"/>
    <id>https://azzurebubble.github.io/posts/fa27ba66.html</id>
    <published>2023-06-07T07:54:22.000Z</published>
    <updated>2024-04-20T01:10:50.276Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>贪心算法基本思想：在对问题求解时，总是做出在当前看来是最好的选择。也就是说不从整体最优上加以考虑，算法得到的是某种意义上的局部最优解。</p><p>注意：贪心算法的每一步都是最优的解决方案，但整个算法并不一定是最优的（局部最优解）。</p></blockquote><h3 id="贪心算法的经典应用">贪心算法的经典应用</h3><h4 id="部分背包问题">部分背包问题</h4><blockquote><p>背包问题：在限定条件下，如何从众多物品中选出收益最高的几件物品。</p><p>背包问题可细分为以下四种：</p><ul><li>0-1 背包问题：每件物品都不可再分，要么整个装入背包，要么放弃，不允许出现类似“将物品的 1/3 装入背包”的情况；</li><li>部分背包问题：每件物品是可再分的，即允许将某件物品的一部分（例如 1/3）放入背包；</li><li>完全背包问题：挑选物品时，每件物品可以选择多个，也就是说不限物品的数量。</li><li>多重背包问题：每件物品的数量是有严格规定的，比如物品 A 有 2 件，物品 B 有 3 件。</li></ul><p>不同背包问题，对应的解决方案也不用，贪心算法主要解决的就是部分背包问题。</p></blockquote><h5 id="部分背包问题-2">部分背包问题</h5><p>假设商店中有三种商品，它们各自的重量和收益：</p><ul><li>商品 1：重量10斤，收益60元；</li><li>商品 2：重量20斤，收益100元；</li><li>商品 3：重量30斤，收益120元；</li></ul><blockquote><p>部分背包问题，对于每一件商品，顾客可以只购买其一部分（可再分）。现</p><p>现在你有一个最多装50斤商品的背包，你如何购买商品才能使背包中的商品收益达到最大化？</p><p>贪心算法思路，计算每个商品的收益率（收益/重量）每次优先选择收益率最大的商品，直到所选商品的总重量达到了50斤。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> N = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// w存储各个商品的重量，p存储各个商品的收益，W表示背包的承重，v是收益率</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Sort</span>(<span class="params"><span class="built_in">float</span>[] w, <span class="built_in">float</span>[] p</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> temp;</span><br><span class="line">        <span class="comment">// 使用一个数组按升序来存放每件商品的收益率</span></span><br><span class="line">        <span class="built_in">float</span>[] v = <span class="keyword">new</span> <span class="built_in">float</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 计算收益率（收益/重量）</span></span><br><span class="line">            v[i] = p[i] / w[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据收益率升序排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = i + <span class="number">1</span>; j &lt; N; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (v[i] &lt; v[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    temp = v[i];</span><br><span class="line">                    v[i] = v[j];</span><br><span class="line">                    v[j] = temp;</span><br><span class="line"></span><br><span class="line">                    temp = w[i];</span><br><span class="line">                    w[i] = w[j];</span><br><span class="line">                    w[j] = temp;</span><br><span class="line"></span><br><span class="line">                    temp = p[i];</span><br><span class="line">                    p[i] = p[j];</span><br><span class="line">                    p[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 贪心算法解决部分背包问题</span></span><br><span class="line"><span class="comment">     * w：记录各个商品的总重量</span></span><br><span class="line"><span class="comment">     * p：记录各个商品的总价值</span></span><br><span class="line"><span class="comment">     * result：记录各个商品装入背包的比例</span></span><br><span class="line"><span class="comment">     * W：背包的容量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fractional_knaspack</span>(<span class="params"><span class="built_in">float</span>[] w, <span class="built_in">float</span>[] p,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">float</span>[] result, <span class="built_in">float</span> W</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 根据收益率排序</span></span><br><span class="line">        Sort(w, p);</span><br><span class="line">        <span class="keyword">while</span> (W &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从排好序的数组中判断选中物品是否可以整个装进背包</span></span><br><span class="line">            temp = W &gt; w[i] ? w[i] : W;</span><br><span class="line">            <span class="comment">// 不可以，则计算出背包容量还能装下多少</span></span><br><span class="line">            result[i] = temp / w[i];</span><br><span class="line">            <span class="comment">// 背包减去装进物品的重量</span></span><br><span class="line">            W -= temp;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 背包总收益</span></span><br><span class="line">        <span class="built_in">float</span> values = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 每个商品的重量</span></span><br><span class="line">        <span class="built_in">float</span>[] w = &#123; <span class="number">10</span>, <span class="number">30</span>, <span class="number">20</span> &#125;;</span><br><span class="line">        <span class="comment">// 每个商品的价值</span></span><br><span class="line">        <span class="built_in">float</span>[] p = &#123; <span class="number">60</span>, <span class="number">100</span>, <span class="number">120</span> &#125;;</span><br><span class="line">        <span class="built_in">float</span>[] result = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="comment">// 背包容量</span></span><br><span class="line">        <span class="built_in">float</span> W = <span class="number">50</span>;</span><br><span class="line">        fractional_knaspack(w, p, result, W);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; w.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 放入比例为1，则为整个商品装入背包</span></span><br><span class="line">            <span class="keyword">if</span> (result[i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;总重量为&#123;0&#125;，总价值为&#123;1&#125;的商品全部装入背包。&quot;</span>, w[i], p[i]);</span><br><span class="line">                values += p[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 放入比例为0，则不装入背包</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (result[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;总重量为&#123;0&#125;，总价值为&#123;1&#125;的商品不装入背包。&quot;</span>, w[i], p[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 某个商品放入多少比例进背包</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;总重量为&#123;0&#125;，总价值为&#123;1&#125;的商品装入&#123;2&#125;%背包。&quot;</span>,</span><br><span class="line">                    w[i], p[i], result[i] * <span class="number">100</span>);</span><br><span class="line">                values += p[i] * result[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;最终收获的商品价值为&#123;0:N6&#125;。&quot;</span>, values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果：</p><p>总重量为10，总价值为60的商品全部装入背包。<br>总重量为20，总价值为120的商品全部装入背包。<br>总重量为30，总价值为100的商品装入66.66667%背包。<br>最终收获的商品价值为246.666672。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;贪心算法基本思想：在对问题求解时，总是做出在当前看来是最好的选择。也就是说不从整体最优上加以考虑，算法得到的是某种意义上的局部最优解。&lt;/p&gt;
&lt;p&gt;注意：贪心算法的每一步都是最优的解决方案，但整个算法并不一定是最优的（局部最优解）。&lt;/p&gt;
&lt;/</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="算法" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="算法" scheme="https://azzurebubble.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="贪心算法" scheme="https://azzurebubble.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法——分治算法</title>
    <link href="https://azzurebubble.github.io/posts/2a9d432c.html"/>
    <id>https://azzurebubble.github.io/posts/2a9d432c.html</id>
    <published>2023-06-07T01:17:46.000Z</published>
    <updated>2024-04-20T01:10:50.273Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>分治算法的基本思想：先将整个问题拆分成多个相互独立且数据量更少的小问题，通过逐一解决这些简单的小问题，最终找到解决整个问题的方案。</p><p>所谓问题间相互独立，简单理解就是每个问题都可以单独处理，不存在“谁先处理，谁后处理”的次序问题。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95.png" alt="分治算法"></p><blockquote><p>如上图所示，分治算法解决问题的过程分为三个阶段：</p><ol><li>分：将整个问题划分成多个相对独立、涉及数据量更少的小问题，有些小问题还可以划分成很多更小的问题，直至每个问题都不可再分；</li><li>治：逐个解决所有的小问题；</li><li>合并：将所有小问题的解决方案合并到一起，找到解决整个问题的方案。</li></ol></blockquote><h3 id="分治算法的经典应用">分治算法的经典应用</h3><h4 id="汉诺塔问题">汉诺塔问题</h4><blockquote><ul><li><p>每次只能移动柱子最顶端的一个圆盘；</p></li><li><p>每个柱子上，小圆盘永远要位于大圆盘之上；</p></li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98.gif" alt="汉诺塔问题"></p><h5 id="分治算法解决汉诺塔问题">分治算法解决汉诺塔问题</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> i = <span class="number">1</span>; <span class="comment">// 统计移动次数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Hanoi(圆盘个数，起始柱子，目标柱子，辅助柱子)</span></span><br><span class="line">        Hanoi(<span class="number">3</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Hanoi</span>(<span class="params"><span class="built_in">int</span> n, <span class="built_in">char</span> sou, <span class="built_in">char</span> tar, <span class="built_in">char</span> aux</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="comment">// 只有一个圆盘，直接从起始柱移动到目标柱</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;第&#123;0&#125;次，从&#123;1&#125;移动到&#123;2&#125;&quot;</span>, i, sou, tar);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 递归调用 Hanoi 方法，将 num-1 个圆盘从起始移动到辅助柱上</span></span><br><span class="line">            Hanoi(n - <span class="number">1</span>, sou, aux, tar);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;第&#123;0&#125;次，从&#123;1&#125;移动到&#123;2&#125;&quot;</span>, i, sou, tar);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="comment">// 将辅助柱上的num-1圆盘移动到目标柱上</span></span><br><span class="line">            Hanoi(n - <span class="number">1</span>, aux, tar, sou);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果：</p><p>第1次，从A移动到B<br>第2次，从A移动到B<br>第3次，从C移动到B<br>第4次，从A移动到B<br>第5次，从C移动到B<br>第6次，从C移动到B<br>第7次，从A移动到B</p></blockquote><h4 id="寻找数组中最大最小值问题">寻找数组中最大最小值问题</h4><blockquote><p>查找数组（序列）中最大值或最小值的算法有很多</p></blockquote><h5 id="普通的迭代算法法求最大最小值">普通的迭代算法法求最大最小值</h5><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%80%BC%E9%97%AE%E9%A2%98_%E6%99%AE%E9%80%9A%E7%AE%97%E6%B3%95.gif" alt="最大最小值问题_普通算法"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> n;</span><br><span class="line">        n = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">        <span class="built_in">int</span>[] a = <span class="keyword">new</span> <span class="built_in">int</span>[n];</span><br><span class="line">        <span class="built_in">string</span>? input = Console.ReadLine();</span><br><span class="line">        <span class="comment">// 通过空格分割输入的字符串</span></span><br><span class="line">        <span class="built_in">string</span>[] inputs = input?.Split(<span class="string">&#x27; &#x27;</span>) ?? <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; inputs.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i] = <span class="built_in">int</span>.Parse(inputs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        GetMaxMin(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetMaxMin</span>(<span class="params"><span class="built_in">int</span>[] a</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> max = a[<span class="number">0</span>], min = a[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 迭代对比，选出其中最大值和最小值存储起来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; a.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; min)</span><br><span class="line">            &#123;</span><br><span class="line">                min = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;最大值为：&quot;</span> + max + <span class="string">&quot;\n最小值为：&quot;</span> + min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输入：</p><p>4</p><p>3 7 2 1</p><p>输入结果：</p><p>最大值为：7<br>最小值为：1</p></blockquote><h5 id="分治算法求解">分治算法求解</h5><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%80%BC%E9%97%AE%E9%A2%98_%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95.png" alt="最大最小值问题_分治算法.png"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> n;</span><br><span class="line">        n = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">        <span class="built_in">int</span>[] a = <span class="keyword">new</span> <span class="built_in">int</span>[n];</span><br><span class="line">        <span class="built_in">string</span>? input = Console.ReadLine();</span><br><span class="line">        <span class="comment">// 通过空格分割输入的字符串</span></span><br><span class="line">        <span class="built_in">string</span>[] inputs = input?.Split(<span class="string">&#x27; &#x27;</span>) ?? <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; inputs.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i] = <span class="built_in">int</span>.Parse(inputs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;最大值为：&quot;</span>GetMax(a, <span class="number">0</span>, n - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">GetMax</span>(<span class="params"><span class="built_in">int</span>[] a, <span class="built_in">int</span> left, <span class="built_in">int</span> right</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> maxLeft = <span class="number">0</span>, maxRight = <span class="number">0</span>, middle = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果数据为空</span></span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果比较的数据只剩下一个数</span></span><br><span class="line">        <span class="keyword">if</span> (right - left == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果比较的数据只剩下两个数</span></span><br><span class="line">        <span class="comment">// 则返回大的那个数</span></span><br><span class="line">        <span class="keyword">if</span> (right - left &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[left] &gt;= a[right])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> a[left];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a[right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取数组中间索引值</span></span><br><span class="line">        middle = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">        <span class="comment">// 递归调用 GetMax 找到数组左边数据中的最大值</span></span><br><span class="line">        maxLeft = GetMax(a, left, middle);</span><br><span class="line">        <span class="comment">// 递归调用 GetMax 找到数组右边数据中的最大值</span></span><br><span class="line">        maxRight = GetMax(a, middle + <span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">// 判断得到的左右两边最后返回的值的大小</span></span><br><span class="line">        <span class="keyword">if</span> (maxLeft &gt;= maxRight)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> maxLeft;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> maxRight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输入：</p><p>4</p><p>3 7 2 1</p><p>输入结果：</p><p>最大值为： 7</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;分治算法的基本思想：先将整个问题拆分成多个相互独立且数据量更少的小问题，通过逐一解决这些简单的小问题，最终找到解决整个问题的方案。&lt;/p&gt;
&lt;p&gt;所谓问题间相互独立，简单理解就是每个问题都可以单独处理，不存在“谁先处理，谁后处理”的次序问题。&lt;/p</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="算法" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="算法" scheme="https://azzurebubble.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="分治算法" scheme="https://azzurebubble.github.io/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法——递归算法</title>
    <link href="https://azzurebubble.github.io/posts/1999c5c.html"/>
    <id>https://azzurebubble.github.io/posts/1999c5c.html</id>
    <published>2023-06-06T09:27:28.000Z</published>
    <updated>2024-04-20T01:10:50.277Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>递归算法的基本思想：就是程序中不断反复的调用自身来解决问题的方法。这里强调的重点是调用自身，就是要求解的问题能够被分解成<strong>多个相同的小问题</strong>这样通过多次递归调用，便可以完成求解。</p><p>递归：函数（方法）调用其自身的过程。</p><p>递归函数：调用自身的函数。</p><p>递归算法：用递归的方式解决问题的算法。</p></blockquote><h3 id="函数（方法）调用自身的实现方式有2种，分别是：">函数（方法）调用自身的实现方式有2种，分别是：</h3><h4 id="直接调用自身">直接调用自身</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">function</span>(<span class="params"><span class="comment">/*...*/</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 调用自身</span></span><br><span class="line">    function(<span class="comment">/*...*/</span>);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="间接调用自身">间接调用自身</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">function1</span>(<span class="params"><span class="comment">/*...*/</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 调用另一个函数</span></span><br><span class="line">    function2(<span class="comment">/*...*/</span>);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">function2</span>(<span class="params"><span class="comment">/*...*/</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 调用 function1() 函数</span></span><br><span class="line">    function1(<span class="comment">/*...*/</span>);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>设计递归函数的时候，我们必须为它设置一个结束递归的“出口”，否则函数会一直调用自身，造成死循环，直到系统崩溃。以下为一个使用递归算法求解 n！的例子。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> input = Console.ReadLine();</span><br><span class="line">        <span class="built_in">int</span> n = <span class="built_in">int</span>.Parse(input);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;n&#125;</span>的阶乘是：<span class="subst">&#123;Factorial(n)&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Factorial</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 递归结束的出口</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用自身</span></span><br><span class="line">        <span class="keyword">return</span> n * Factorial(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输入：3</p><p>输出结果为：</p><p>3的阶乘是：6</p></blockquote><h3 id="递归算法的底层机制">递归算法的底层机制</h3><blockquote><p>递归算法的底层机制实现其实就是通过数据结构中栈实现的，使用栈结构保存调用者的状态信息，包括暂停时局部变量的值、寄存器中保存的数据等等。如下图所示：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%A0%88.png" alt="递归算法的栈"></p><h3 id="递归算法的经典应用">递归算法的经典应用</h3><h4 id="斐波那契数列">斐波那契数列</h4><blockquote><p>前两个数的值分别为 0 、1 或者 1、1；</p><p>从第 3 个数字开始，它的值是前两个数字的和；</p><p>如：1 1 2 3 5 8 13 21 34…</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.gif" alt="斐波那契数列"></p><h5 id="递归算法实现斐波那契数列">递归算法实现斐波那契数列</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> input = Console.ReadLine();</span><br><span class="line">        <span class="built_in">int</span> n = <span class="built_in">int</span>.Parse(input);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;n&#125;</span>个数的斐波那契数列为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(<span class="string">&quot;&#123;0&#125; &quot;</span>, Fibonacci(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Fibonacci</span>(<span class="params"><span class="built_in">int</span> n</span>) <span class="comment">// index 索引第几个数</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="comment">// 如果是第1个和第2个数则都返回1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回前两数之和</span></span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输入：10</p><p>输出结果为：</p><p>10个数的斐波那契数列为：<br>1 1 2 3 5 8 13 21 34 55</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;递归算法的基本思想：就是程序中不断反复的调用自身来解决问题的方法。这里强调的重点是调用自身，就是要求解的问题能够被分解成&lt;strong&gt;多个相同的小问题&lt;/strong&gt;这样通过多次递归调用，便可以完成求解。&lt;/p&gt;
&lt;p&gt;递归：函数（方法）调用其</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="算法" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="算法" scheme="https://azzurebubble.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="递归算法" scheme="https://azzurebubble.github.io/tags/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>行为型设计模式（Behavioral Design Patterns） - 11种</title>
    <link href="https://azzurebubble.github.io/posts/33555d0d.html"/>
    <id>https://azzurebubble.github.io/posts/33555d0d.html</id>
    <published>2023-04-15T02:00:44.000Z</published>
    <updated>2024-04-20T01:10:50.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="行为型设计模式-（Behavioral-Design-Patterns）-11种">行为型设计模式 （Behavioral Design Patterns）- 11种</h2><p>[TOC]</p><h3 id="什么是行为型设计模式">什么是行为型设计模式</h3><blockquote><p>行为型设计模式（Behavioral Design Patterns）是软件设计模式中的一类，用于描述对象之间的交互和通信方式，关注对象的行为和相互作用。行为型设计模式通常用于处理对象之间的算法、责任、状态等行为相关的问题，以实现更灵活、可复用、可扩展的软件系统。</p><p>行为型设计模式包括以下十一种常见的模式：</p><ol><li>责任链模式（Chain of Responsibility Pattern）：将请求的发送者和接收者解耦，通过一条链式的方式依次处理请求，直到找到合适的处理者。</li><li>命令模式（Command Pattern）：将请求封装成一个对象，并将其发送给不同的接收者，从而将请求的发送者和接收者解耦。</li><li>解释器模式（Interpreter Pattern）：定义了一种语言的文法和解释器，用于解释和执行特定的语言表达式。</li><li>迭代器模式（Iterator Pattern）：提供一种一致的方式来遍历集合对象中的元素，而不暴露其内部结构。</li><li>中介者模式（Mediator Pattern）：将对象之间的相互调用和通信封装到一个中介者对象中，从而减少对象之间的直接依赖关系。</li><li>备忘录模式（Memento Pattern）：在不破坏封装性的前提下，保存和恢复对象的内部状态。</li><li>观察者模式（Observer Pattern）：定义了一种一对多的关系，当一个对象的状态发生变化时，所有依赖于它的对象都会得到通知并自动更新。</li><li>状态模式（State Pattern）：允许对象在内部状态发生改变时改变其行为，从而看起来像是改变了其类。</li><li>策略模式（Strategy Pattern）：定义了一系列算法，并将其封装成独立的对象，使得它们可以相互替换，从而在运行时动态选择不同的算法。</li><li>模板方法模式（Template Method Pattern）：定义一个算法骨架，将其中的某些步骤延迟到子类中实现，从而在不改变算法结构的情况下，可以通过子类来改变算法的具体实现。</li><li>访问者模式（Visitor Pattern）：将对一个复杂对象的操作分离成多个独立的操作，从而可以在不改变对象结构的情况下增加新的操作。</li></ol></blockquote><hr><h3 id="一、责任链模式（Chain-of-Responsibility-Pattern）">一、责任链模式（Chain of Responsibility Pattern）</h3><blockquote><p>责任链模式（Chain of Responsibility Pattern）是一种行为型设计模式，用于将处理请求的对象组成一条链，并在该链上依次处理请求，直到找到合适的处理者为止。责任链模式将请求的发送者和接收者解耦，使得多个对象都有机会处理请求，从而避免了将请求发送给固定的接收者。</p><p>在责任链模式中，通常会将处理者组成一条链，并将请求从链的起始点发送给第一个处理者，然后该处理者可以选择处理请求或者将请求传递给链上的下一个处理者，依次类推，直到找到合适的处理者或者请求到达链的末尾。这样可以实现一种请求处理的流程，不同的处理者可以根据自己的逻辑来处理请求，从而实现灵活的请求处理方式。</p><p><u>意图：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，知道有一个对象处理它为止。</u></p><p><u><code>Chain of Responsibility Pattern适用于：</code></u></p><ol><li>有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。</li><li>想在不明确指定接收者的情况下向多个对象种的一个提交请求。</li><li>可处理一个请求的对象集合应被动态指定。</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="责任链模式结构图"></p><h5 id="责任链模式的主要角色包括：">责任链模式的主要角色包括：</h5><ol><li><p><strong>抽象处理者（Handler）</strong></p><blockquote><p>定义了处理请求的接口，通常包含一个处理请求的方法，以及设置和获取下一个处理者的方法。</p></blockquote></li><li><p><strong>具体处理者（Concrete Handler）</strong></p><blockquote><p>实现了抽象处理者接口，具体处理请求的逻辑，并可以选择将请求传递给下一个处理者。</p></blockquote></li><li><p><strong>客户端（Client）</strong></p><blockquote><p>创建并组织责任链，将请求发送给第一个处理者，并负责将请求传递给下一个处理者，直到找到合适的处理者。</p></blockquote></li></ol><h5 id="责任链模式实现参考代码">责任链模式实现参考代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 责任链模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象处理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Handler* next;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Handler</span>(Handler* n = <span class="literal">nullptr</span>) :<span class="built_in">next</span>(n) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetNext</span><span class="params">(Handler* n)</span> </span>&#123; next = n; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">HandlerRequest</span><span class="params">(<span class="type">int</span> request)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Handler</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理者A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HandlerA</span> :<span class="keyword">public</span> Handler</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HandlerRequest</span><span class="params">(<span class="type">int</span> request)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (request &lt;= <span class="number">7</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;HandlerA 的处理完成！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (next)</span><br><span class="line">&#123;</span><br><span class="line">next-&gt;<span class="built_in">HandlerRequest</span>(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无法处理请求！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理者B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HandlerB</span> :<span class="keyword">public</span> Handler</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HandlerRequest</span><span class="params">(<span class="type">int</span> request)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (request &lt;= <span class="number">15</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;HandlerB 的处理完成！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (next)</span><br><span class="line">&#123;</span><br><span class="line">next-&gt;<span class="built_in">HandlerRequest</span>(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无法处理请求！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理者C</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HandlerC</span> :<span class="keyword">public</span> Handler</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HandlerRequest</span><span class="params">(<span class="type">int</span> request)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (request &lt;= <span class="number">30</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;HandlerC 的处理完成！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (next)</span><br><span class="line">&#123;</span><br><span class="line">next-&gt;<span class="built_in">HandlerRequest</span>(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无法处理请求！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Handler* handlerA = <span class="keyword">new</span> <span class="built_in">HandlerA</span>();</span><br><span class="line">Handler* handlerB = <span class="keyword">new</span> <span class="built_in">HandlerB</span>();</span><br><span class="line">Handler* handlerC = <span class="keyword">new</span> <span class="built_in">HandlerC</span>();</span><br><span class="line">handlerA-&gt;<span class="built_in">SetNext</span>(handlerB);</span><br><span class="line">handlerB-&gt;<span class="built_in">SetNext</span>(handlerC);</span><br><span class="line"></span><br><span class="line">handlerA-&gt;<span class="built_in">HandlerRequest</span>(<span class="number">5</span>);</span><br><span class="line">handlerA-&gt;<span class="built_in">HandlerRequest</span>(<span class="number">10</span>);</span><br><span class="line">handlerA-&gt;<span class="built_in">HandlerRequest</span>(<span class="number">25</span>);</span><br><span class="line">handlerA-&gt;<span class="built_in">HandlerRequest</span>(<span class="number">35</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、-命令模式（Command-Pattern）">二、 命令模式（Command Pattern）</h3><blockquote><p>命令模式（Command Pattern）是一种行为型设计模式，用于将请求封装成一个对象，从而允许客户端通过不同的请求对象来参数化和传递请求，使得请求的发出者和接收者解耦。命令模式将请求的发送者（客户端）和请求的接收者（执行者）分离，通过引入一个命令对象来间接地传递请求，从而实现了请求的解耦和灵活性。</p><p>命令模式的核心思想是将请求封装成一个对象，从而可以实现请求的参数化、传递、撤销等操作，同时也可以实现请求的队列、日志、事务等功能。命令模式通常适用于需要将请求的发出者和接收者解耦的场景，例如，需要实现撤销、重做、延迟执行等功能的应用场景。</p><p><u>意图：将一个请求封装为一个对象，从而使得可以用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</u></p><p><u><code>Command Pattern四适用于：</code></u></p><ol><li>抽象出待执行的动作以参数化某对象。</li><li>在不同的时刻指定、排列和执行请求。</li><li>支持取消操作。</li><li>支持修改日志。</li><li>用构建在原语操作上的高层操作构造一个系统。</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="命令模式结构图"></p><h5 id="命令模式的主要角色包括：">命令模式的主要角色包括：</h5><ol><li><p><strong>命令接口（Command Interface）</strong></p><blockquote><p>定义了执行命令的接口，通常包含一个或多个抽象方法，如 <code>Execute()</code> 方法。</p></blockquote></li><li><p><strong>具体命令（Concrete Command）</strong></p><blockquote><p>实现了命令接口，具体命令对象通常包含了对请求的接收者的引用，以及具体的执行逻辑。</p></blockquote></li><li><p><strong>请求接收者（Receiver）</strong></p><blockquote><p>执行命令所要求的操作，实际完成请求的处理。</p></blockquote></li><li><p><strong>请求发送者（Client）</strong></p><blockquote><p>负责创建命令对象，并将命令对象发送给请求的接收者，请求发送者通常持有一个命令对象，可以通过命令对象来发出请求。</p></blockquote></li></ol><h5 id="命令模式实现参考代码">命令模式实现参考代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 命令链模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求接收者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Action1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;接收者执行动作1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Action2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;接收者执行动作2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Receiver</span>() &#123; ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Command</span>() &#123; ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体命令1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command1</span> :<span class="keyword">public</span> Command</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Receiver* receiver;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Command1</span>(Receiver* r) :<span class="built_in">receiver</span>(r) &#123; ; &#125;</span><br><span class="line">~<span class="built_in">Command1</span>() &#123; ; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;执行具体命令1&quot;</span> &lt;&lt; endl;</span><br><span class="line">receiver-&gt;<span class="built_in">Action1</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体命令2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command2</span> :<span class="keyword">public</span> Command</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Receiver* receiver;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Command2</span>(Receiver* r) :<span class="built_in">receiver</span>(r) &#123; ; &#125;</span><br><span class="line">~<span class="built_in">Command2</span>() &#123; ; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;执行具体命令2&quot;</span> &lt;&lt; endl;</span><br><span class="line">receiver-&gt;<span class="built_in">Action2</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令调用者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Invoker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Command* command;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetCommand</span><span class="params">(Command* cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">command = cmd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExcuteCommand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (command)</span><br><span class="line">&#123;</span><br><span class="line">command-&gt;<span class="built_in">Execute</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Invoker</span>() &#123; ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Receiver* receiver = <span class="keyword">new</span> <span class="built_in">Receiver</span>();</span><br><span class="line"></span><br><span class="line">Command* command1 = <span class="keyword">new</span> <span class="built_in">Command1</span>(receiver);</span><br><span class="line">Command* command2 = <span class="keyword">new</span> <span class="built_in">Command2</span>(receiver);</span><br><span class="line"></span><br><span class="line">Invoker* invoker = <span class="keyword">new</span> <span class="built_in">Invoker</span>();</span><br><span class="line">invoker-&gt;<span class="built_in">SetCommand</span>(command1);</span><br><span class="line">invoker-&gt;<span class="built_in">ExcuteCommand</span>();</span><br><span class="line"></span><br><span class="line">invoker-&gt;<span class="built_in">SetCommand</span>(command2);</span><br><span class="line">invoker-&gt;<span class="built_in">ExcuteCommand</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="三、解释器模式（Interpreter-Pattern）">三、解释器模式（Interpreter Pattern）</h3><blockquote><p>解释器模式（Interpreter Pattern）是一种行为型设计模式，用于处理如何解释和执行特定语言或规则的问题。它定义了一种语言的文法表示，并且可以用于解释语言中的表达式。通过使用解释器模式，可以将一个问题或表达式表示为一个语法树，并且可以在运行时递归地对语法树进行解释和求值。</p><p>解释器模式的主要目的是将一个问题或表达式转化为一种可以解释的数据结构，并且提供一种灵活的方式来解释和执行这些数据结构，从而实现对复杂规则和语言的处理。</p><p><u>意图：给定一个语言，定于它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言种的句子。</u></p><p><u><code>Interpreter Pattern适用于:</code></u></p><ol><li>当有一个语言需要解释执行，并且可将该语言中的句子表示为一个抽象语法树时，一下效果最好：</li></ol><ul><li>该文法简单。</li><li>效率不是一个关键问题。</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="解释器模式结构图"></p><h5 id="解释器模式通常包含以下角色：">解释器模式通常包含以下角色：</h5><ol><li><p><strong>抽象表达式（Abstract Expression）</strong></p><blockquote><p>定义了解释器的接口，包含一个解释方法（interpret）用于解释表达式。</p></blockquote></li><li><p><strong>终结符表达式（Terminal Expression）</strong></p><blockquote><p>实现抽象表达式接口，用于表示语言中的终结符，也就是不再可以解释的最小单元。</p></blockquote></li><li><p><strong>非终结符表达式（Non-terminal Expression）</strong></p><blockquote><p>实现抽象表达式接口，用于表示语言中的非终结符，它包含了一个或多个子表达式，并且可以递归地进行解释。</p></blockquote></li><li><p><strong>上下文（Context）</strong></p><blockquote><p>包含了解释器需要的全局信息，可以在解释器中共享。</p></blockquote></li><li><p><strong>客户端（Client）</strong></p><blockquote><p>使用解释器模式的客户端，负责创建、配置和使用解释器模式的对象。</p></blockquote></li></ol><h5 id="解释器模式实现参考代码">解释器模式实现参考代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 解释器模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象表达式类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Expression</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Expression</span>() &#123; ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">interpret</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终结符表达式：数字</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberExpression</span> :<span class="keyword">public</span> Expression</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">NumberExpression</span>(<span class="type">int</span> num) :<span class="built_in">number</span>(num) &#123;&#125;</span><br><span class="line">~<span class="built_in">NumberExpression</span>() &#123; ; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非终结符表达式：加法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddExpression</span> :<span class="keyword">public</span> Expression</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Expression* left;</span><br><span class="line">Expression* right;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">AddExpression</span>(Expression* l, Expression* r) :<span class="built_in">left</span>(l), <span class="built_in">right</span>(r) &#123;&#125;</span><br><span class="line">~<span class="built_in">AddExpression</span>() &#123; ; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> left-&gt;<span class="built_in">interpret</span>() + right-&gt;<span class="built_in">interpret</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非终结符表达式：乘法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulExpression</span> :<span class="keyword">public</span> Expression</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Expression* left;</span><br><span class="line">Expression* right;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MulExpression</span>(Expression* l, Expression* r) :<span class="built_in">left</span>(l), <span class="built_in">right</span>(r) &#123;&#125;</span><br><span class="line">~<span class="built_in">MulExpression</span>() &#123; ; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> left-&gt;<span class="built_in">interpret</span>() * right-&gt;<span class="built_in">interpret</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解释器上下文</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Expression* expression;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setExpression</span><span class="params">(Expression* exp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">expression = exp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (expression)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> expression-&gt;<span class="built_in">interpret</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Context</span>() &#123; ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Expression* number1 = <span class="keyword">new</span> <span class="built_in">NumberExpression</span>(<span class="number">1</span>);</span><br><span class="line">Expression* number2 = <span class="keyword">new</span> <span class="built_in">NumberExpression</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Expression* addExpression = <span class="keyword">new</span> <span class="built_in">AddExpression</span>(number1, number2);</span><br><span class="line"></span><br><span class="line">Context context;</span><br><span class="line">context.<span class="built_in">setExpression</span>(addExpression);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result = context.<span class="built_in">interpret</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;result: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;=================================&quot;</span> &lt;&lt; endl;</span><br><span class="line">Expression* number3 = <span class="keyword">new</span> <span class="built_in">NumberExpression</span>(<span class="number">3</span>);</span><br><span class="line">Expression* number4 = <span class="keyword">new</span> <span class="built_in">NumberExpression</span>(<span class="number">4</span>);</span><br><span class="line">Expression* mulExpression = <span class="keyword">new</span> <span class="built_in">MulExpression</span>(number3, number4);</span><br><span class="line">context.<span class="built_in">setExpression</span>(mulExpression);</span><br><span class="line">result = context.<span class="built_in">interpret</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;result: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="四、迭代器模式（Iterator-Pattern）">四、迭代器模式（Iterator Pattern）</h3><blockquote><p>迭代器模式（Iterator Pattern）是一种行为型设计模式，它提供了一种在集合对象中遍历元素的方式，而无需暴露集合对象的内部结构。通过使用迭代器模式，可以让客户端代码更加简洁和灵活地遍历集合对象中的元素，同时也减少了与集合对象的耦合。</p><p><u>意图：提供一种方法顺序访问一个聚合对象中的各个元素，且不需要暴露该对象的内部表示。</u></p><p><u><code>Iterator Pattern适用于:</code></u></p><ol><li>访问一个聚合对象的内容而无须暴露它的内部表示。</li><li>支持对聚合对象的多种遍历。</li><li>为遍历不同的聚合结构提供一个同一的接口。</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt="迭代器模式"></p><h5 id="迭代器模式通常包含以下角色：">迭代器模式通常包含以下角色：</h5><ol><li><p><strong>迭代器（Iterator）</strong></p><blockquote><p>定义了遍历集合对象的接口，包括了访问集合中下一个元素、获取当前元素、判断是否还有下一个元素等方法。</p></blockquote></li><li><p><strong>集合（Collection）</strong></p><blockquote><p>定义了集合对象的接口，包括了添加、删除、获取迭代器等方法，用于管理和操作集合中的元素。</p></blockquote></li></ol><h5 id="迭代器模式实现参考代码">迭代器模式实现参考代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 迭代器模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Collection</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Iterator* <span class="title">CreateIterator</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体迭代器1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator1</span> :<span class="keyword">public</span> Iterator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; collection;</span><br><span class="line"><span class="type">int</span> index;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Iterator1</span>(vector&lt;<span class="type">int</span>&gt; coll) :<span class="built_in">collection</span>(coll), <span class="built_in">index</span>(<span class="number">0</span>) &#123; ; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> collection[index++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> index &lt; collection.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体集合1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Collection1</span> :<span class="keyword">public</span> Collection</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; collection;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">collection.<span class="built_in">push_back</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Iterator* <span class="title">CreateIterator</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Iterator1</span>(collection);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Collection1 collection1;</span><br><span class="line">collection1.<span class="built_in">Add</span>(<span class="number">1</span>);</span><br><span class="line">collection1.<span class="built_in">Add</span>(<span class="number">2</span>);</span><br><span class="line">collection1.<span class="built_in">Add</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">Iterator* iterator = collection1.<span class="built_in">CreateIterator</span>();</span><br><span class="line"><span class="keyword">while</span> (iterator-&gt;<span class="built_in">hasNext</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; iterator-&gt;<span class="built_in">next</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="五、中介者模式（Mediator-Pattern）">五、中介者模式（Mediator Pattern）</h3><blockquote><p>中介者模式（Mediator Pattern）是一种行为型设计模式，用于解耦多个对象之间的复杂交互关系，通过引入一个中介者对象，将对象之间的交互集中管理和控制。中介者模式通过将对象之间的通信集中到中介者对象，从而减少了对象之间的直接依赖关系，降低了耦合性，增加了系统的可维护性和扩展性。</p><p><u>意图：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</u></p><p><u><code>Mediator Pattern适用于:</code></u></p><ol><li>一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解。</li><li>一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象。</li><li>想定制一个分布在多个类中的行为，而又不想生成太多的子类。</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="中介者模式结构图"></p><h5 id="中介者模式通常包含以下角色：">中介者模式通常包含以下角色：</h5><ol><li><p><strong>中介者（Mediator）</strong></p><blockquote><p>中介者是一个接口或者抽象类，定义了同事对象之间的通信接口。中介者负责管理和协调同事对象之间的交互关系，通常包括注册和移除同事对象的方法，以及定义处理不同交互场景的逻辑。</p></blockquote></li><li><p><strong>具体中介者（Concrete Mediator）</strong></p><blockquote><p>具体中介者是中介者接口的实现类，实现了同事对象之间的具体通信逻辑。具体中介者对象通常会持有对所有相关同事对象的引用，并负责处理它们之间的交互。</p></blockquote></li><li><p><strong>同事对象（Colleague）</strong></p><blockquote><p>同事对象是需要进行通信的对象，每个同事对象持有对中介者对象的引用，并通过中介者对象来与其他同事对象进行通信。同事对象通常会实现一个接口或者继承一个抽象类，定义了与中介者对象通信的方法。</p></blockquote></li><li><p><strong>具体同事对象（Concrete Colleague）</strong></p><blockquote><p>具体同事对象是同事对象接口的实现类，实现了与中介者对象通信的具体逻辑。具体同事对象通过调用中介者对象的方法来与其他同事对象进行通信。</p></blockquote></li></ol><h5 id="中介者模式实现参考代码">中介者模式实现参考代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 中介者模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中介者接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mediator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendMessage</span><span class="params">(string message, <span class="keyword">class</span> Colleague* colleague)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同事类接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Colleague</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string message;</span><br><span class="line">Mediator* mediator;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Colleague</span>(Mediator* m) :<span class="built_in">mediator</span>(m) &#123; ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ReceiveMessage</span><span class="params">(string message)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体同事A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ColleagueA</span> :<span class="keyword">public</span> Colleague</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ColleagueA</span>(Mediator* m) :<span class="built_in">Colleague</span>(m) &#123; ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ReceiveMessage</span><span class="params">(string message)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ColleagueA receive message: &quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mediator-&gt;<span class="built_in">SendMessage</span>(message, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体同事B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ColleagueB</span> :<span class="keyword">public</span> Colleague</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ColleagueB</span>(Mediator* m) :<span class="built_in">Colleague</span>(m) &#123; ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ReceiveMessage</span><span class="params">(string message)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ColleagueB receive message: &quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mediator-&gt;<span class="built_in">SendMessage</span>(message, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> :<span class="keyword">public</span> Mediator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Colleague* colleagueA;</span><br><span class="line">Colleague* colleagueB;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetColleagueA</span><span class="params">(Colleague* colleague)</span> </span>&#123; colleagueA = colleague; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetColleagueB</span><span class="params">(Colleague* colleague)</span> </span>&#123; colleagueB = colleague; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SendMessage</span><span class="params">(string message, Colleague* colleague)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (colleague == colleagueA)</span><br><span class="line">&#123;</span><br><span class="line">colleagueB-&gt;<span class="built_in">ReceiveMessage</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (colleague == colleagueB)</span><br><span class="line">&#123;</span><br><span class="line">colleagueA-&gt;<span class="built_in">ReceiveMessage</span>(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ConcreteMediator* mediator = <span class="keyword">new</span> <span class="built_in">ConcreteMediator</span>();</span><br><span class="line"></span><br><span class="line">Colleague* colleagueA = <span class="keyword">new</span> <span class="built_in">ColleagueA</span>(mediator);</span><br><span class="line">Colleague* colleagueB = <span class="keyword">new</span> <span class="built_in">ColleagueB</span>(mediator);</span><br><span class="line">mediator-&gt;<span class="built_in">SetColleagueA</span>(colleagueA);</span><br><span class="line">mediator-&gt;<span class="built_in">SetColleagueB</span>(colleagueB);</span><br><span class="line">colleagueA-&gt;<span class="built_in">SendMessage</span>(<span class="string">&quot;你好啊！同事B&quot;</span>);</span><br><span class="line">colleagueB-&gt;<span class="built_in">SendMessage</span>(<span class="string">&quot;你好啊！同事A&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="六、备忘录模式（Memento-Pattern）">六、备忘录模式（Memento Pattern）</h3><blockquote><p>备忘录模式（Memento Pattern）是一种行为型设计模式，用于在不破坏对象封装性的前提下，捕获和恢复对象的内部状态。备忘录模式通过在不同的对象间保存对象状态的快照，使得对象可以在后续需要时还原到之前的状态。</p><p>备忘录模式的核心思想是通过将对象的状态保存到外部的备忘录对象中，从而实现了状态的可保存和可恢复性。发起人对象可以根据需要创建备忘录对象，并将自己的状态保存到备忘录中。管理者对象可以保存备忘录对象，也可以从备忘录对象中恢复发起人对象的状态，从而实现了对象状态的历史记录和撤销/恢复功能。</p><p><u>意图：在不破坏封装性的前提下捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可以将对象恢复到原先保存的状态。</u></p><p><u><code>Memento Pattern适用于:</code></u></p><ol><li>必须保存一个对象在某一时刻的（部分状态），这样以后需要时，它才能恢复到先前的状态。</li><li>如果一个用接口来让其他对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="备忘录模式结构图"></p><h5 id="备忘录模式通常包含以下角色：">备忘录模式通常包含以下角色：</h5><ol><li><p><strong>发起人（Originator）</strong></p><blockquote><p>负责创建和持有需要保存状态的对象，并可以通过创建备忘录来保存其内部状态。</p></blockquote></li><li><p><strong>备忘录（Memento）</strong></p><blockquote><p>用于存储发起人的内部状态，包含了需要保存的状态信息。</p></blockquote></li><li><p><strong>管理者（Caretaker）</strong></p><blockquote><p>负责管理备忘录对象，可以保存多个备忘录对象，并在需要时将其还原给发起人。</p></blockquote></li></ol><h5 id="备忘录模式实现参考代码">备忘录模式实现参考代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 备忘录模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 备忘录类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memento</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string state;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Memento</span>() &#123; ; &#125;</span><br><span class="line"><span class="built_in">Memento</span>(string s)</span><br><span class="line">&#123;</span><br><span class="line">state = s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">GetState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原发器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Originator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string state;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Originator</span>(string s) :<span class="built_in">state</span>(s) &#123; ; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetState</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">state = s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">GetState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Memento <span class="title">CreateMemento</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Memento</span>(state);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetMemento</span><span class="params">(Memento memento)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">state = memento.<span class="built_in">GetState</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Caretaker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Memento memento;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SaveMemento</span><span class="params">(<span class="type">const</span> Memento&amp; m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">memento = m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Memento <span class="title">RetrieveMemento</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> memento;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Caretaker caretaker;</span><br><span class="line"><span class="function">Originator <span class="title">originator</span><span class="params">(<span class="string">&quot;状态1&quot;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;初始状态：&quot;</span> &lt;&lt; originator.<span class="built_in">GetState</span>() &lt;&lt; endl;</span><br><span class="line">caretaker.<span class="built_in">SaveMemento</span>(originator.<span class="built_in">CreateMemento</span>());</span><br><span class="line">originator.<span class="built_in">SetState</span>(<span class="string">&quot;状态2&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;修改状态：&quot;</span> &lt;&lt; originator.<span class="built_in">GetState</span>() &lt;&lt; endl;</span><br><span class="line">originator.<span class="built_in">SetMemento</span>(caretaker.<span class="built_in">RetrieveMemento</span>());</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;恢复状态：&quot;</span> &lt;&lt; originator.<span class="built_in">GetState</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="七、观察者模式（Observer-Pattern）">七、观察者模式（Observer Pattern）</h3><blockquote><p>观察者模式（Observer Pattern）是一种行为型设计模式，用于定义对象之间的一对多依赖关系，当一个对象的状态发生变化时，其所有依赖对象都会得到通知并自动更新。</p><p>观察者模式的核心思想是解耦对象之间的依赖关系，让主题和观察者之间通过接口进行通信，从而实现了松耦合的设计。当主题的状态发生变化时，观察者会被自动通知，并根据需要进行相应的处理，从而实现了对象间的动态协作和响应式的行为。观察者模式常用于事件处理、GUI编程、消息系统等场景。</p><p><u>意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到了通知并被自动更新。</u></p><p><u><code>Observer Pattern适用于:</code></u></p><ol><li>当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两者封装在独立的对象中以使它们可以各自独立地改变和复用。</li><li>当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变时。</li><li>当一个对象必须通知其他对象，而它又不能假定其他对象是谁，即不希望这些对象是紧耦合的。</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="观察者模式结构图"></p><h5 id="观察者模式通常包含以下角色：">观察者模式通常包含以下角色：</h5><ol><li><p><strong>主题（Subject）</strong></p><blockquote><p>也称为被观察者或发布者，负责维护一组观察者对象，并通知它们自己的状态变化。</p></blockquote></li><li><p><strong>观察者（Observer）</strong></p><blockquote><p>也称为订阅者或观察者，定义了一个更新接口，用于接收主题通知的更新。</p></blockquote></li><li><p><strong>具体主题（Concrete Subject）</strong></p><blockquote><p>实现了主题接口，负责维护自己的状态，并在状态发生变化时通知所有观察者。</p></blockquote></li><li><p><strong>具体观察者（Concrete Observer）</strong></p><blockquote><p>实现了观察者接口，负责接收并处理主题发来的通知，以便更新自己的状态。</p></blockquote></li></ol><h5 id="观察者模式实现参考代码">观察者模式实现参考代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 观察者模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象观察者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Update</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象主题类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Attach</span><span class="params">(Observer* observer)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Detach</span><span class="params">(Observer* observer)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Notify</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体观察者1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer1</span> :<span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string name;</span><br><span class="line">Subject* subject;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Observer1</span>(string n, Subject* s) :<span class="built_in">name</span>(n), <span class="built_in">subject</span>(s)</span><br><span class="line">&#123;</span><br><span class="line">subject-&gt;<span class="built_in">Attach</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Observer1</span>(string n) :<span class="built_in">name</span>(n) &#123; ; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;观察者：&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;收到更新通知！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体观察者2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer2</span> :<span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string name;</span><br><span class="line">Subject* subject;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Observer2</span>(string n, Subject* s) :<span class="built_in">name</span>(n), <span class="built_in">subject</span>(s)</span><br><span class="line">&#123;</span><br><span class="line">subject-&gt;<span class="built_in">Attach</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Observer2</span>(string n) :<span class="built_in">name</span>(n) &#123; ; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;观察者：&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;收到更新通知！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体主题1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject1</span> :<span class="keyword">public</span> Subject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;Observer*&gt; observers;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Attach</span><span class="params">(Observer* observer)</span> <span class="comment">// 添加观察者</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">observers.<span class="built_in">push_back</span>(observer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Detach</span><span class="params">(Observer* observer)</span> <span class="comment">// 删除观察者</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = observers.<span class="built_in">begin</span>(); it != observers.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*it == observer)</span><br><span class="line">&#123;</span><br><span class="line">observers.<span class="built_in">erase</span>(it);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Notify</span><span class="params">()</span> <span class="comment">// 通知观察者</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通知所有的观察者...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : observers)</span><br><span class="line">&#123;</span><br><span class="line">it-&gt;<span class="built_in">Update</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Subject1* subject1 = <span class="keyword">new</span> <span class="built_in">Subject1</span>();</span><br><span class="line">Observer* observer1 = <span class="keyword">new</span> <span class="built_in">Observer1</span>(<span class="string">&quot;observer1&quot;</span>, subject1);</span><br><span class="line">Observer* observer2 = <span class="keyword">new</span> <span class="built_in">Observer2</span>(<span class="string">&quot;observer2&quot;</span>, subject1);</span><br><span class="line"><span class="comment">//Observer* observer1 = new Observer1(&quot;observer1&quot;);</span></span><br><span class="line"><span class="comment">//Observer* observer2 = new Observer2(&quot;observer2&quot;);</span></span><br><span class="line"><span class="comment">//subject1-&gt;Attach(observer1);</span></span><br><span class="line"><span class="comment">//subject1-&gt;Attach(observer2);</span></span><br><span class="line">subject1-&gt;<span class="built_in">Notify</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;==========分割线=============&quot;</span> &lt;&lt; endl;</span><br><span class="line">subject1-&gt;<span class="built_in">Detach</span>(observer2);</span><br><span class="line">subject1-&gt;<span class="built_in">Notify</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="八、状态模式（State-Pattern）">八、状态模式（State Pattern）</h3><blockquote><p>状态模式（State Pattern）是一种行为型设计模式，用于在对象的状态发生变化时，使对象能够改变其行为，而不需要通过多个条件语句来实现。状态模式将对象的行为封装在不同的状态对象中，使得状态之间可以相互切换，从而实现对象在不同状态下的不同行为。</p><p>状态模式的主要目的是将对象的行为和状态分离，使得对象的行为能够根据不同的状态发生变化，从而实现更灵活、可扩展和易维护的代码。它适用于对象在不同状态下需要有不同行为的场景，避免了大量的条件语句，使代码更加清晰、简洁和可维护。</p><p><u>意图：允许一个对象在内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</u></p><p><u><code>State Pattern适用于:</code></u></p><ol><li>一个对象的行为决定于它的状态，并且它必须在运行时刻根据状态改变它的行为。</li><li>一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="状态模式结构图"></p><h5 id="状态模式通常包含以下角色：">状态模式通常包含以下角色：</h5><ol><li><p><strong>环境（Context）</strong></p><blockquote><p>负责维护一个当前状态对象的引用，并将与状态相关的请求委派给当前状态处理。</p></blockquote></li><li><p><strong>抽象状态（State）</strong></p><blockquote><p>定义状态的接口，通常包含了处理请求的方法。</p></blockquote></li><li><p><strong>具体状态（Concrete State）</strong></p><blockquote><p>实现抽象状态的接口，并定义了在该状态下的具体行为。</p></blockquote></li></ol><h5 id="状态模式实现参考代码">状态模式实现参考代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 状态者模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span>; <span class="comment">// 前向声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StateA</span>; <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象状态类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Handle</span><span class="params">(Context* context)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态类B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StateB</span> :<span class="keyword">public</span> State</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Handle</span><span class="params">(Context* context)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态类A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StateA</span> :<span class="keyword">public</span> State</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Handle</span><span class="params">(Context* context)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 贩卖机</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line">State* state;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Context</span>()</span><br><span class="line">&#123;</span><br><span class="line">count = <span class="number">3</span>;</span><br><span class="line">state = <span class="keyword">new</span> <span class="built_in">StateA</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetCount</span><span class="params">(<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">count = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">State* <span class="title">GetState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetState</span><span class="params">(State* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">state = s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">state-&gt;<span class="built_in">Handle</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StateA 类成员函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StateA::Handle</span><span class="params">(Context* context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> count = context-&gt;<span class="built_in">GetCount</span>();</span><br><span class="line"><span class="keyword">if</span> (count &gt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;购买成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">context-&gt;<span class="built_in">SetCount</span>(count - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (count - <span class="number">1</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">context-&gt;<span class="built_in">SetState</span>(<span class="keyword">new</span> <span class="built_in">StateB</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;库存无货，购买失败！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StateB 类成员函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StateB::Handle</span><span class="params">(Context* context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> count = context-&gt;<span class="built_in">GetCount</span>();</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;库存无货，购买失败！&quot;</span> &lt;&lt; endl;</span><br><span class="line">context-&gt;<span class="built_in">SetCount</span>(<span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;补货成功，可重新购买！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Context* context = <span class="keyword">new</span> <span class="built_in">Context</span>();</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(*context-&gt;<span class="built_in">GetState</span>()).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">context-&gt;<span class="built_in">Request</span>();</span><br><span class="line">context-&gt;<span class="built_in">Request</span>();</span><br><span class="line">context-&gt;<span class="built_in">Request</span>();</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(*context-&gt;<span class="built_in">GetState</span>()).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">context-&gt;<span class="built_in">Request</span>();</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(*context-&gt;<span class="built_in">GetState</span>()).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="九、策略模式（Strategy-Pattern）">九、策略模式（Strategy Pattern）</h3><blockquote><p>策略模式（Strategy Pattern）是一种行为型设计模式，它允许在运行时根据需要选择不同的算法或策略来完成特定的任务，而不需要在代码中硬编码这些算法或策略。策略模式通过将算法或策略封装成独立的类，并通过一个统一的接口进行调用，实现了算法或策略的独立切换和替换。</p><p>策略模式在实际应用中可以用于很多场景，例如在排序算法、支付方式、日志记录等场景中，根据不同的需求选择不同的策略来完成任务。</p><p><u>意图：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换，此模式使得算法可以独立于使用它们的客户而变化。</u></p><p><u><code>Strategy Pattern适用于:</code></u></p><ol><li>许多相关的类仅仅是行为有异。”策略“提供了一种用多个行为中的一个行为来配置一个类的方法。</li><li>需要使用一个算法的不同变体。</li><li>算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。</li><li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，将相关的条件分支移入它们各自的Strategy类中，以替代这些条件语句。</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="策略模式结构图"></p><h5 id="策略模式通常包含以下角色：">策略模式通常包含以下角色：</h5><ol><li><p><strong>环境类（Context）</strong></p><blockquote><p>它包含一个策略接口的引用，并在运行时根据需要调用策略对象的方法来完成任务。</p></blockquote></li><li><p><strong>策略接口（Strategy）</strong></p><blockquote><p>它定义了策略模式的接口，通常包含一个或多个方法，用于描述不同的算法或策略。</p></blockquote></li><li><p><strong>具体策略类（Concrete Strategy）</strong></p><blockquote><p>它实现了策略接口，并实现了具体的算法或策略。在运行时，环境类可以根据需要选择合适的具体策略类来完成任务。</p></blockquote></li></ol><h5 id="策略模式实现参考代码">策略模式实现参考代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 策略模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Strategy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">TwoNumberOperation</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrategyA</span> :<span class="keyword">public</span> Strategy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TwoNumberOperation</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrategyB</span> :<span class="keyword">public</span> Strategy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TwoNumberOperation</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; a - b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略C</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrategyC</span> :<span class="keyword">public</span> Strategy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TwoNumberOperation</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; a * b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Strategy* strategy;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Context</span>(Strategy* s) &#123; strategy = s; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Operation</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">strategy-&gt;<span class="built_in">TwoNumberOperation</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Strategy* strategyA = <span class="keyword">new</span> <span class="built_in">StrategyA</span>();</span><br><span class="line">Strategy* strategyB = <span class="keyword">new</span> <span class="built_in">StrategyB</span>();</span><br><span class="line">Strategy* strategyC = <span class="keyword">new</span> <span class="built_in">StrategyC</span>();</span><br><span class="line">Context* context = <span class="keyword">new</span> <span class="built_in">Context</span>(strategyA);</span><br><span class="line">context-&gt;<span class="built_in">Operation</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">context = <span class="keyword">new</span> <span class="built_in">Context</span>(strategyB);</span><br><span class="line">context-&gt;<span class="built_in">Operation</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">context = <span class="keyword">new</span> <span class="built_in">Context</span>(strategyC);</span><br><span class="line">context-&gt;<span class="built_in">Operation</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="十、模板方法模式（Template-Method-Pattern）">十、模板方法模式（Template Method Pattern）</h3><blockquote><p>模板方法模式（Template Method Pattern）是一种行为型设计模式，用于定义一个算法的骨架，将一些步骤的实现延迟到子类中，从而使子类可以重新定义算法的某些特定步骤，而不改变算法的结构。</p><p>在模板方法模式中，定义一个抽象基类（或接口），其中包含了一个模板方法（Template Method），该方法是一个算法的骨架，包含了一系列的步骤，其中某些步骤可以是抽象的，留给子类实现。这样子类可以根据自身的需求，提供具体的实现，从而影响算法的行为。</p><p><u>意图：定义一个操作中的算法骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</u></p><p><u><code>Template Method Pattern适用于:</code></u></p><ol><li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</li><li>各子类中公共的行为应被提取出来并集中到一个公共父类中，以避免代码重复。</li><li>控制子类扩展。模板方法旨在特定点调用“hook”操作（默认的行为，子类可以在必要时进行重定义扩展），这就只允许在这些点进行扩展。</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="模板方法模式结构图"></p><h5 id="模板方法模式通常包含以下角色：">模板方法模式通常包含以下角色：</h5><ol><li><p><strong>抽象基类（Abstract Class）</strong></p><blockquote><p>定义了模板方法，包含了一系列的抽象和具体方法，是模板方法模式的核心。</p></blockquote></li><li><p><strong>具体子类（Concrete Class）</strong></p><blockquote><p>继承抽象基类，实现抽象方法，从而提供具体的实现。</p></blockquote></li></ol><h5 id="模板方法模式实现参考代码">模板方法模式实现参考代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 模板方法模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TemplateMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;去教室&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">PrimitiveOperation1</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;离开教室&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">PrimitiveOperation2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PrimitiveOperation1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PrimitiveOperation2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> :<span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrimitiveOperation1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;学生听课&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrimitiveOperation2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;学生写作业&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> :<span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrimitiveOperation1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;老师上课&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrimitiveOperation2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;老师布置作业&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person* student = <span class="keyword">new</span> <span class="built_in">Student</span>();</span><br><span class="line">Person* teacher = <span class="keyword">new</span> <span class="built_in">Teacher</span>();</span><br><span class="line">student-&gt;<span class="built_in">TemplateMethod</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;================================&quot;</span> &lt;&lt; endl;</span><br><span class="line">teacher-&gt;<span class="built_in">TemplateMethod</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="十一、访问者模式（Visitor-Pattern）">十一、访问者模式（Visitor Pattern）</h3><blockquote><p>访问者模式（Visitor Pattern）是一种行为型设计模式，用于在不修改已有对象结构的情况下，定义对这些对象结构中各个元素的新操作。访问者模式通过将对元素的操作封装成独立的访问者类，使得可以在不修改元素类的情况下，新增、扩展或变化元素的操作。</p><p>需要注意的是，访问者模式在设计时需要谨慎使用，一般适用于对一组对象的操作比较稳定、固定，并且需要对这组对象进行不同的操作，而不是对每个对象进行不同的操作。</p><p><u>意图：表示一个作用于某对象结构中的各元素的操作。它允许在不改变各元素的类的前提下定义作用于这些元素的新操作。</u></p><p><u><code>Visitor Pattern适用于:</code></u></p><ol><li>一个对象结构包含很多类对象，它们有不同的接口，而用户相对这些对象实施一些依赖于其具体类的操作。</li><li>需要对一个对象结构中的对象进行很多不同的并且不想关的操作，而又想要避免这些操作“污染”这些对象的类。Visitor 使得用户可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用 Visitor 模式让每个应用仅包含需要用到的操作。</li><li>定于对象结构体的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价，如果对象结构类经常改变，那么还是在这些类中定义这些操作较好。</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="访问者模式结构图"></p><h5 id="访问者模式通常包含以下角色：">访问者模式通常包含以下角色：</h5><ol><li><p><strong>访问者（Visitor）</strong></p><blockquote><p>定义了对每个元素的访问操作接口，可以通过这个接口访问元素的各个部分。</p></blockquote></li><li><p><strong>元素（Element）</strong></p><blockquote><p>定义了一个接受访问者的接口，使得访问者可以访问自己的内部元素结构，并可以对这些结构进行操作。</p></blockquote></li></ol><h5 id="访问者模式实现参考代码">访问者模式实现参考代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 访问者模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElementA</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElementB</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问者接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visit</span><span class="params">(ElementA* elementA)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visit</span><span class="params">(ElementB* elementB)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Element</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">accept</span><span class="params">(Visitor* visitor)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体元素A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElementA</span> :<span class="keyword">public</span> Element</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(Visitor* visitor)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">visitor-&gt;<span class="built_in">visit</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OperationA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;元素 A 的方法&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体元素B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElementB</span> :<span class="keyword">public</span> Element</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(Visitor* visitor)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">visitor-&gt;<span class="built_in">visit</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OperationB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;元素 B 的方法&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体访问者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteVisitor</span> :<span class="keyword">public</span> Visitor</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ElementA* elementA)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;访问者访问元素 A 的方法：&quot;</span> &lt;&lt; endl;</span><br><span class="line">elementA-&gt;<span class="built_in">OperationA</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ElementB* elementB)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;访问者访问元素 B 的方法：&quot;</span> &lt;&lt; endl;</span><br><span class="line">elementB-&gt;<span class="built_in">OperationB</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象结构体类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectStructure</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;Element*&gt;elements;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">AddElement</span><span class="params">(Element* element)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">elements.<span class="built_in">push_back</span>(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(Visitor* visitor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> element : elements)</span><br><span class="line">&#123;</span><br><span class="line">element-&gt;<span class="built_in">accept</span>(visitor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ElementA elementA;</span><br><span class="line">ElementB elementB;</span><br><span class="line">ConcreteVisitor visitor;</span><br><span class="line">ObjectStructure objectStructure;</span><br><span class="line">objectStructure.<span class="built_in">AddElement</span>(&amp;elementA);</span><br><span class="line">objectStructure.<span class="built_in">AddElement</span>(&amp;elementB);</span><br><span class="line">objectStructure.<span class="built_in">accept</span>(&amp;visitor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;行为型设计模式-（Behavioral-Design-Patterns）-11种&quot;&gt;行为型设计模式 （Behavioral Design Patterns）- 11种&lt;/h2&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;什么是行为型设计模式&quot;&gt;什么是行为型设计模式</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="设计模式" scheme="https://azzurebubble.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="C++" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="行为型设计模式" scheme="https://azzurebubble.github.io/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>《巫鬼》</title>
    <link href="https://azzurebubble.github.io/posts/1253424b.html"/>
    <id>https://azzurebubble.github.io/posts/1253424b.html</id>
    <published>2023-04-15T02:00:00.000Z</published>
    <updated>2024-04-20T01:10:50.265Z</updated>
    
    <content type="html"><![CDATA[<h5 id="2023年4月15日第三届中国大学生CUSGA游戏开发创作大赛《巫鬼》">2023年4月15日第三届中国大学生CUSGA游戏开发创作大赛《巫鬼》</h5><h4 id="游戏类型：">游戏类型：</h4><blockquote><p>2D 横版国风恐怖解谜 RPG 游戏</p></blockquote><h4 id="故事背景：">故事背景：</h4><blockquote><p>糅杂巫风和山海经元素的志异怪奇风游戏。背景设定在崇尚巫术的楚国。主角作为掌握巫术的女巫，游行于民间帮各户人家解决各种问题，游戏中将讲述主角来往各户人家所经历的志异奇事，由玩家逐渐揭示迷雾背后的各个真相。</p></blockquote><h4 id="核心机制：">核心机制：</h4><blockquote><p>RPG解密类游戏。玩家通过WASD操控主角移动，f看对话、检查物品、开门，b键打开物品栏查看，鼠标点击道具来探索解谜。</p></blockquote><h4 id="灵感来源：">灵感来源：</h4><blockquote><p>取材自春秋战国时期的尚巫之风的楚国，糅合《山海经》奇幻元素和《聊斋》的猎奇志异，并添加了我国传统文化傩戏元素。</p></blockquote><h4 id="美术风格：">美术风格：</h4><blockquote><p>参考上海美术学院的国画画风</p></blockquote><h4 id="游戏打包地址：">游戏打包地址：</h4><blockquote><p><a href="https://pan.baidu.com/s/1LCYxDfYBj3RmrTD-LgADDg?pwd=if7p"><strong>《巫鬼》</strong></a>   提取码：if7p</p></blockquote><h4 id="B站演示视频：">B站演示视频：</h4><blockquote><p><a href="https://www.bilibili.com/video/BV13s4y127Uk/?spm_id_from=333.337.search-card.all.click&amp;vd_source=34e7951566592d9161f65c8aaa799f1f"><strong>BV13s4y127Uk</strong></a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/SampleReels@main/Picture/%E5%B7%AB%E9%AC%BC.png" alt="巫鬼"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;2023年4月15日第三届中国大学生CUSGA游戏开发创作大赛《巫鬼》&quot;&gt;2023年4月15日第三届中国大学生CUSGA游戏开发创作大赛《巫鬼》&lt;/h5&gt;
&lt;h4 id=&quot;游戏类型：&quot;&gt;游戏类型：&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;2D 横版国风恐怖解谜 </summary>
      
    
    
    
    <category term="游戏开发" scheme="https://azzurebubble.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="团队合作" scheme="https://azzurebubble.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E5%9B%A2%E9%98%9F%E5%90%88%E4%BD%9C/"/>
    
    
    <category term="Unity" scheme="https://azzurebubble.github.io/tags/Unity/"/>
    
    <category term="C#" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="2D" scheme="https://azzurebubble.github.io/tags/2D/"/>
    
    <category term="团队合作" scheme="https://azzurebubble.github.io/tags/%E5%9B%A2%E9%98%9F%E5%90%88%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>结构型设计模式（Structural Design Patterns） - 7种</title>
    <link href="https://azzurebubble.github.io/posts/85a95c31.html"/>
    <id>https://azzurebubble.github.io/posts/85a95c31.html</id>
    <published>2023-04-11T02:00:00.000Z</published>
    <updated>2024-04-20T01:10:50.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="结构型设计模式（Structural-Design-Patterns）-7种">结构型设计模式（Structural Design Patterns） - 7种</h2><p>[TOC]</p><hr><h3 id="什么是结构型设计模式（Structural-Design-Patterns）">什么是结构型设计模式（Structural Design Patterns）</h3><blockquote><p>结构型设计模式（Structural Design Patterns）是一种软件设计模式，用于解决在软件系统中对象的组合、接口、类之间的关系和结构的问题。结构型设计模式可以帮助设计者创建更加灵活、可扩展和易于维护的软件系统。</p><p>结构型设计模式包括以下七种常见的模式<u><code>（桥代理组装适配器，享元回家装饰外观）</code></u>：</p><ol><li>适配器模式（Adapter Pattern）：将一个类的接口转换成另一个类的接口，使得原本不兼容的类能够一起工作。</li><li>桥接模式（Bridge Pattern）：将抽象部分与其实现部分分离，使它们可以独立地变化。</li><li>组合模式（Composite Pattern）：将对象组合成树形结构以表示&quot;部分-整体&quot;的层次结构，使客户端可以统一对待单个对象和组合对象。</li><li>装饰器模式（Decorator Pattern）：动态地为对象添加额外的行为，而不需要在对象之间使用继承关系。</li><li>外观模式（Facade Pattern）：提供一个简单的接口，隐藏一组复杂的子系统接口，使得客户端更加方便地使用这些子系统。</li><li>享元模式（Flyweight Pattern）：共享细粒度对象，以减少内存开销。</li><li>代理模式（Proxy Pattern）：为其他对象提供一种代理以控制对这个对象的访问。</li></ol></blockquote><hr><h3 id="一、适配器模式（Adapter-Pattern）">一、适配器模式（Adapter Pattern）</h3><blockquote><p>适配器模式（Adapter Pattern）是一种结构型设计模式，用于将一个类的接口转换成另一个类的接口，以便两者可以相互兼容。适配器模式通常用于解决不兼容的接口之间的问题，或者用于将现有类的功能与其他类进行集成。</p><p><u>意图：将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</u></p><p>适配器模式在现实生活中的应用非常广泛，例如在电子设备中的电源适配器、在软件开发中的数据库适配器等。它可以帮助解决不同接口之间的兼容性问题，实现系统的灵活扩展和复用。</p><p><code>Adapter Pattern适用于：</code></p><ol><li>想使用一个已经存在的类，而它的接口不符合要求。</li><li>想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。</li><li>（仅适用于对象Adapter）想使用一个已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</li></ol></blockquote><h5 id="适配器模式包含三个关键角色：">适配器模式包含三个关键角色：</h5><ol><li><p><strong>目标接口（Target）</strong></p><blockquote><p>定义了客户端期望的接口，是客户端调用的接口。</p></blockquote></li><li><p><strong>适配器（Adapter）</strong></p><blockquote><p>是将被适配者的接口转换成目标接口的类，它实现了目标接口，并持有一个对被适配者的引用。</p></blockquote></li><li><p><strong>被适配者（Adaptee）</strong></p><blockquote><p>是需要被适配的类或接口，其接口与目标接口不匹配。</p></blockquote></li></ol><h5 id="适配器模式包括以下几种类型：">适配器模式包括以下几种类型：</h5><ol><li><p><strong>类适配器</strong></p><blockquote><p>通过继承实现适配器，使得适配器类既具有目标接口的行为，又能够调用被适配类的方法。在C++中，可以通过多继承和虚继承实现类适配器模式。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="类适配器结构图"></p><p><strong>类适配器参考代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 类适配器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标接口类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">USB</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;USB数据线&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">USB</span>() &#123; ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要适配的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TypeC</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SpecificRequest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Type-C数据线&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">TypeC</span>() &#123; ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++多重继承实现类适配器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span> :<span class="keyword">public</span> USB, <span class="keyword">private</span> TypeC</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Request</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">SpecificRequest</span>();</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Adapter</span>() &#123; ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">USB* usb = <span class="keyword">new</span> <span class="built_in">Adapter</span>(); <span class="comment">// 创建适配器对象</span></span><br><span class="line">usb-&gt;<span class="built_in">Request</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>对象适配器</code></strong></p><blockquote><p>通过组合实现适配器，使得适配器类包含一个被适配类的对象，并实现目标接口的方法，通过调用被适配类的方法来完成适配。在C++中，可以通过对象组合和接口继承实现对象适配器模式。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="对象适配器结构图"></p><p><strong>对象适配器参考代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 对象适配器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标接口类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">USB</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;USB数据线&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">USB</span>() &#123; ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要适配的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TypeC</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SpecificRequest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Type-C数据线&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">TypeC</span>() &#123; ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span> :<span class="keyword">public</span> USB</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">TypeC* typeC; <span class="comment">// 定义一个需要适配的对象</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Adapter</span>(TypeC* tc) :<span class="built_in">typeC</span>(tc) &#123; ; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Request</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">typeC-&gt;<span class="built_in">SpecificRequest</span>(); <span class="comment">// 需要创建适配对象调用方法</span></span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Adapter</span>() &#123; ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TypeC* typeC = <span class="keyword">new</span> <span class="built_in">TypeC</span>();</span><br><span class="line">USB* usb = <span class="keyword">new</span> <span class="built_in">Adapter</span>(typeC);</span><br><span class="line">usb-&gt;<span class="built_in">Request</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>接口适配器</strong></p><blockquote><p>也称为缺省适配器模式，通过定义一个抽象适配器类，其中包含目标接口的所有方法，但方法体为空，子类可以选择性地覆盖其中的方法，从而实现适配。在C++中，可以通过接口继承和虚函数实现接口适配器模式。</p></blockquote></li></ol><h5 id="适配器的优缺点：">适配器的优缺点：</h5><blockquote><p>适配器模式的优点：</p><ol><li>解决接口不兼容问题：通过适配器，可以将不兼容的接口转换成兼容的接口，使得不同接口之间能够协同工作。</li><li>复用已有代码：可以复用已有的类或接口，而无需修改其源代码，只需实现适配器即可。</li><li>灵活性：可以通过适配器替换不同的实现，从而实现不同的适配逻辑。</li></ol><p>适配器模式的缺点：</p><ol><li>增加了系统的复杂性，引入了适配器类，需要进行额外的设计和编码工作。</li><li>在设计时需要注意选择适配器的类型（类适配器、对象适配器、接口适配器），以及适配器和目标接口的设计，以确保系统的结构清晰和易于理解。</li></ol></blockquote><hr><h3 id="二、桥接模式（Bridge-Pattern）">二、桥接模式（Bridge Pattern）</h3><blockquote><p>桥接模式（Bridge Pattern）是一种结构型设计模式，用于将抽象和实现部分解耦，使它们可以独立地变化。桥接模式通过使用组合关系，将抽象和实现部分分离成不同的类层次结构，从而实现抽象和实现的解耦。</p><p><u>意图：将抽象部分与其实现部分分离，使它们都可以独立地变化。</u></p><p>在传统的继承关系中，抽象类和具体实现类之间存在紧耦合关系，导致当抽象类或具体实现类发生变化时，可能会影响到彼此之间的稳定性和灵活性。而桥接模式通过将抽象和实现部分分离，使它们可以独立地演化和变化，从而实现了解耦和灵活性。</p><p><u><code>Bridge Pattern适用于：</code></u></p><ol><li>不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如：这种情况可能是因为在程序运行时刻实现部分应可以被选择或者切换。</li><li>类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这是 Bridge 模式使得开发者可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。</li><li>对 一个抽象的实现部分的修改应对客户不产生影响，即客户代码不必重新编译。</li><li>（C++）想对客户完全隐藏抽象的实现部分。</li><li>有许多类要生成的类层次结构。</li><li>想在多个对象间共享实现（可能使用引用技术），但同时要求客户并不知道这一点。</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="桥接模式结构图"></p><h5 id="桥接模式包含两个关键角色：">桥接模式包含两个关键角色：</h5><ol><li><p><strong>抽象部分（Abstraction）</strong></p><blockquote><p>抽象部分定义了高层接口，包含抽象方法，并持有一个对实现部分的引用；</p></blockquote></li><li><p><strong>实现部分（Implementor）</strong></p><blockquote><p>实现部分定义了底层接口，包含具体的实现方法。</p></blockquote></li></ol><ul><li><strong>抽象部分和实现部分通过组合关系连接在一起，而不是继承关系，从而实现了抽象和实现的解耦。</strong></li></ul><h5 id="桥接模式参考代码实现">桥接模式参考代码实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 桥接模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IColor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OperationImp</span><span class="params">(string name)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现类Red</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Red</span> :<span class="keyword">public</span> IColor</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OperationImp</span><span class="params">(string name)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; name &lt;&lt; <span class="string">&quot;：红色&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现类Blue</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Blue</span> :<span class="keyword">public</span> IColor</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OperationImp</span><span class="params">(string name)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; name &lt;&lt; <span class="string">&quot;：蓝色&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AProduct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string name;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">IColor* color;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">AProduct</span>() &#123; color = <span class="literal">NULL</span>; &#125;</span><br><span class="line"><span class="built_in">AProduct</span>(IColor* iColor) :<span class="built_in">color</span>(iColor) &#123; ; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetColor</span><span class="params">(IColor* iColor)</span> </span>&#123; color = iColor; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetName</span><span class="params">(string n)</span> </span>&#123; name = n; &#125;</span><br><span class="line"><span class="function">string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">AProduct</span>() &#123; ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA</span> :<span class="keyword">public</span> AProduct</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ProductA</span>() &#123; color = <span class="literal">NULL</span>; &#125;</span><br><span class="line"><span class="built_in">ProductA</span>(IColor* iColor) :<span class="built_in">AProduct</span>(iColor) &#123; ; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Operation</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">color-&gt;<span class="built_in">OperationImp</span>(<span class="keyword">this</span>-&gt;<span class="built_in">GetName</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB</span> :<span class="keyword">public</span> AProduct</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ProductB</span>() &#123; color = <span class="literal">NULL</span>; &#125;</span><br><span class="line"><span class="built_in">ProductB</span>(IColor* iColor) :<span class="built_in">AProduct</span>(iColor) &#123; ; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Operation</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">color-&gt;<span class="built_in">OperationImp</span>(<span class="keyword">this</span>-&gt;<span class="built_in">GetName</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IColor* red = <span class="keyword">new</span> <span class="built_in">Red</span>();</span><br><span class="line">AProduct* productA = <span class="keyword">new</span> <span class="built_in">ProductA</span>();</span><br><span class="line">productA-&gt;<span class="built_in">SetName</span>(<span class="string">&quot;产品A&quot;</span>);</span><br><span class="line">productA-&gt;<span class="built_in">SetColor</span>(red);</span><br><span class="line">productA-&gt;<span class="built_in">Operation</span>();</span><br><span class="line"></span><br><span class="line">IColor* blue = <span class="keyword">new</span> <span class="built_in">Blue</span>();</span><br><span class="line">AProduct* productB = <span class="keyword">new</span> <span class="built_in">ProductB</span>(blue);</span><br><span class="line">productB-&gt;<span class="built_in">SetName</span>(<span class="string">&quot;产品B&quot;</span>);</span><br><span class="line">productB-&gt;<span class="built_in">SetColor</span>(blue);</span><br><span class="line">productB-&gt;<span class="built_in">Operation</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="桥接模式的优缺点：">桥接模式的优缺点：</h5><blockquote><p>桥接模式的优点：</p><ol><li>解耦和灵活性：将抽象和实现部分解耦，使它们可以独立地演化和变化，互相之间不会影响，从而提高了系统的灵活性和可扩展性。</li><li>可复用性：可以通过组合不同的抽象和实现部分，构建不同的对象组合，从而实现复用性。</li><li>可扩展性：可以方便地扩展抽象和实现部分，而不影响其他部分的稳定性。</li><li>可替代性：可以方便地替换抽象和实现部分，从而实现不同的组合，而不需要修改抽象和实现部分的代码。</li></ol><p>桥接模式的缺点：</p><ol><li>增加了系统的复杂性，需要额外的设计和编码工作。</li><li>在设计时需要谨慎选择抽象和实现部分的接口，以确保系统的结构清晰和易于理解。</li></ol></blockquote><hr><h3 id="三、组合模式（Composite-Pattern）">三、组合模式（Composite Pattern）</h3><blockquote><p>组合模式（Composite Pattern）是一种结构型设计模式，用于将对象组织成树形结构以表示“整体-部分”的层次结构，使客户端能够以一致的方式处理单个对象和组合对象，对象的层次结构可以递归地进行组合，从而形成复杂的结构。</p><p><u>意图：将对象组合成树型结构以表示“部分-整体”的层次结构。Composite 使得用户对单个对象和组合对象的使用具有一致性。</u></p><p>组合模式的核心思想是将叶子节点和组合节点统一对待，使得客户端在使用组合对象时不需要关心其具体类型，而是通过统一的接口对待整体和部分。这样可以简化客户端的代码，并且在需要增加新的组合对象时不需要修改客户端代码。</p><p><u><code>Composite Pattern适用于：</code></u></p><ol><li>想表示对象的部分 - 整体层次结构。</li><li>希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="组合模式结构图"></p><h5 id="组合模式中通常有两种类型的对象：">组合模式中通常有两种类型的对象：</h5><ol><li><p><strong>叶子节点（Leaf）</strong></p><blockquote><p>表示组合中的叶子节点，它没有子节点，通常是最基本的单元。</p></blockquote></li><li><p><strong>组合节点（Composite）</strong></p><blockquote><p>表示组合中的组合节点，它可以包含子节点，通常实现了与叶子节点相同的接口，并在其中包含一个子节点列表。</p></blockquote></li></ol><h5 id="组合模式参考代码实现">组合模式参考代码实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 组合模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AFile</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string* name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">AFile</span>() &#123; ; &#125;</span><br><span class="line"><span class="built_in">AFile</span>(string* n) &#123; name = n; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PrintName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(AFile* file)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Remove</span><span class="params">(AFile* file)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> vector&lt;AFile*&gt;* <span class="title">GetChild</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; ; &#125;</span><br><span class="line">~<span class="built_in">AFile</span>() &#123; ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合文件夹</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Folder</span> :<span class="keyword">public</span> AFile</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;AFile*&gt; childrenList;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Folder</span>(string* n) :<span class="built_in">AFile</span>(n) &#123; ; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; *name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; *name &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(AFile* file)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">childrenList.<span class="built_in">push_back</span>(file);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Remove</span><span class="params">(AFile* file)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = childrenList.<span class="built_in">begin</span>(); it != childrenList.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*it == file)</span><br><span class="line">&#123;</span><br><span class="line">childrenList.<span class="built_in">erase</span>(it);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;AFile*&gt;* <span class="title">GetChild</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;childrenList;<span class="comment">// return new vector&lt;AFile*&gt;(childrenList)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; childrenList.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">childrenList[i]-&gt;<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Folder</span>() &#123; ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叶子文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> :<span class="keyword">public</span> AFile</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">File</span>(string* n) :<span class="built_in">AFile</span>(n) &#123; ; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; *name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; *name &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(AFile* file)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Remove</span><span class="params">(AFile* file)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;AFile*&gt;* <span class="title">GetChild</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">vector</span>&lt;AFile*&gt;();</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">File</span>() &#123; ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">(AFile* file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">file-&gt;<span class="built_in">Print</span>();</span><br><span class="line">vector&lt;AFile*&gt;* child = file-&gt;<span class="built_in">GetChild</span>();</span><br><span class="line"><span class="keyword">if</span> (!child-&gt;<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; child-&gt;<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">print</span>((*child)[i]);</span><br><span class="line"><span class="comment">//(*child)[i]-&gt;Print();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AFile* root = <span class="keyword">new</span> <span class="built_in">Folder</span>(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">AFile* folderA = <span class="keyword">new</span> <span class="built_in">Folder</span>(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;folderA&quot;</span>));</span><br><span class="line">folderA-&gt;<span class="built_in">PrintName</span>();</span><br><span class="line">AFile* fileB = <span class="keyword">new</span> <span class="built_in">File</span>(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;fileB&quot;</span>));</span><br><span class="line">fileB-&gt;<span class="built_in">PrintName</span>();</span><br><span class="line">root-&gt;<span class="built_in">Add</span>(folderA);</span><br><span class="line">root-&gt;<span class="built_in">Add</span>(fileB);</span><br><span class="line">root-&gt;<span class="built_in">Show</span>();</span><br><span class="line">root-&gt;<span class="built_in">Remove</span>(fileB);</span><br><span class="line">root-&gt;<span class="built_in">Show</span>();</span><br><span class="line">vector&lt;AFile*&gt;* child = root-&gt;<span class="built_in">GetChild</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; child-&gt;<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">(*child)[i]-&gt;<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">AFile* folderC = <span class="keyword">new</span> <span class="built_in">Folder</span>(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;folderC&quot;</span>));</span><br><span class="line">AFile* fileD = <span class="keyword">new</span> <span class="built_in">File</span>(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;fileD&quot;</span>));</span><br><span class="line">AFile* fileE = <span class="keyword">new</span> <span class="built_in">File</span>(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;fileE&quot;</span>));</span><br><span class="line">root-&gt;<span class="built_in">Add</span>(fileB);</span><br><span class="line">folderA-&gt;<span class="built_in">Add</span>(folderC);</span><br><span class="line">folderC-&gt;<span class="built_in">Add</span>(fileD);</span><br><span class="line">folderC-&gt;<span class="built_in">Add</span>(fileE);</span><br><span class="line"><span class="built_in">print</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="组合模式的优缺点：">组合模式的优缺点：</h5><blockquote><p>组合模式的优点：</p><ol><li>简化客户端代码：客户端可以一致地对待叶子节点和组合节点，无需进行额外的类型判断。</li><li>可扩展性：可以方便地增加、删除或修改组合对象，而无需修改客户端代码。</li><li>灵活性：可以通过组合不同的叶子节点和组合节点来构建复杂的树状结构。</li></ol><p>组合模式的缺点：</p><ol><li>可能导致系统过于复杂：如果组合对象的层次结构过于复杂，可能会导致系统的理解和维护变得困难。</li><li>不适合所有情况：组合模式适用于那些需要对整体和部分进行一致性处理的情况，不适用于所有情况。</li></ol></blockquote><hr><h3 id="四、装饰器模式（Decorator-Pattern）">四、装饰器模式（Decorator Pattern）</h3><blockquote><p>装饰器模式（Decorator Pattern）是一种结构型设计模式，用于动态地给对象添加新的行为或功能，而不需要修改其原有的接口或实现。</p><p><u>意图：动态地给一个对象添加一些额外的职责。就增加功能而言，Decorator 模式比生成子类更加灵活。</u></p><p>通过使用装饰器模式，可以灵活地在运行时动态地添加、删除或修改对象的行为，而不需要修改原有的对象代码。这使得装饰器模式在需要扩展对象功能，但又不希望修改现有代码的情况下，具有很好的适用性。</p><p><u><code>Decorator Pattern适用于：</code></u></p><ol><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li><li>处理那些可以撤销的职责。</li><li>当不能采用生成子类的方式进行扩充时。一种情况是：可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是：由于类定义被隐藏，或类定义不能用于生成子类。</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="装饰器模式结构图"></p><h5 id="装饰器模式有三个关键角色：">装饰器模式有三个关键角色：</h5><ol><li><p><strong>抽象组件（Component）</strong></p><blockquote><p>定义了对象的基本接口，可以是抽象类或接口，它是被装饰者和装饰者共同实现的接口。</p></blockquote></li><li><p><strong>具体组件（Concrete Component）</strong></p><blockquote><p>实现了抽象组件接口，是被装饰的对象，即被添加新行为的对象。</p></blockquote></li><li><p><strong>装饰器（Decorator）</strong></p><blockquote><p>继承自抽象组件，包含了一个抽象组件的引用，并且定义了与抽象组件接口相同的接口。装饰器可以添加新的行为，也可以在执行原有行为前后添加额外的处理逻辑。</p></blockquote></li></ol><h5 id="装饰器模式参考代码实现">装饰器模式参考代码实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 装饰器模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象人类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123; ; &#125;</span><br><span class="line"><span class="built_in">Person</span>(string n) :<span class="built_in">name</span>(n) &#123; ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Person</span>() &#123; ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象装饰器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decorator</span> :<span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Person* person;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Decorator</span>(Person* p) :<span class="built_in">person</span>(p) &#123; ; &#125;</span><br><span class="line">~<span class="built_in">Decorator</span>() &#123; ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体装饰器A类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecoratorA</span> :<span class="keyword">public</span> Decorator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">DecoratorA</span>(Person* p) :<span class="built_in">Decorator</span>(p) &#123; ; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Operation</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">person-&gt;<span class="built_in">Operation</span>(); <span class="comment">// 原本的职责</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;新增的职责：研究！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">DecoratorA</span>() &#123; ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体装饰器B类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecoratorB</span> :<span class="keyword">public</span> Decorator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">DecoratorB</span>(Person* p) :<span class="built_in">Decorator</span>(p) &#123; ; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Operation</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">person-&gt;<span class="built_in">Operation</span>(); <span class="comment">// 原本的职责</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;新增的职责：考试！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">DecoratorB</span>() &#123; ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> :<span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Student</span>(string n) :<span class="built_in">Person</span>(n) &#123; ; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Operation</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; name &lt;&lt; <span class="string">&quot;的职责：学习！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Student</span>() &#123; ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person* zhangsan = <span class="keyword">new</span> <span class="built_in">Student</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">zhangsan-&gt;<span class="built_in">Operation</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;==========分割线===========&quot;</span> &lt;&lt; endl;</span><br><span class="line">zhangsan = <span class="keyword">new</span> <span class="built_in">DecoratorA</span>(zhangsan);</span><br><span class="line">zhangsan-&gt;<span class="built_in">Operation</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;==========分割线===========&quot;</span> &lt;&lt; endl;</span><br><span class="line">zhangsan = <span class="keyword">new</span> <span class="built_in">DecoratorB</span>(zhangsan);</span><br><span class="line">zhangsan-&gt;<span class="built_in">Operation</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="装饰器模式的优缺点：">装饰器模式的优缺点：</h5><blockquote><p>装饰器模式优点:</p><ol><li>动态扩展功能：装饰器模式允许在不修改原有对象的情况下，动态地添加、删除或修改对象的行为，从而实现了功能的动态扩展，避免了继承的静态扩展方式可能引发的类爆炸问题。</li><li>单一职责原则：装饰器模式将功能的添加和原有对象的实现解耦，使得每个类只负责一个单一的职责，符合设计原则中的单一职责原则，提高了代码的可维护性和可扩展性。</li><li>灵活性和可组合性：由于装饰器模式通过组合的方式实现功能的扩展，因此可以灵活地组合多个装饰器对象，实现不同功能的组合，具有较高的灵活性和可组合性。</li></ol><p>装饰器模式缺点:</p><ol><li>多层嵌套：使用装饰器模式可能会导致多层嵌套的装饰器对象，从而增加了代码的复杂性和理解难度。</li><li>接口增多：每个装饰器都需要实现与抽象组件相同的接口，这可能导致接口的增多，使得系统更加复杂。</li><li>运行时性能损耗：由于装饰器模式采用了动态添加行为的方式，可能会在运行时引入一定的性能损耗，尤其是在装饰器链较长的情况下。</li></ol></blockquote><hr><h3 id="五、外观模式（Facade-Pattern）">五、外观模式（Facade Pattern）</h3><blockquote><p>外观模式（Facade Pattern）是一种设计模式，属于结构型设计模式。它提供了一个简化复杂系统接口的高层接口，用于简化客户端与系统之间的交互。外观模式通过隐藏系统的复杂性，将一组复杂的子系统接口封装成一个简单的接口，从而提供了一个更加简单、易于使用的接口供客户端使用。</p><p>外观模式通常包含一个外观类（Facade Class），该类作为客户端与子系统之间的中介，隐藏了子系统的复杂性，并提供了一个简单的接口供客户端使用。外观类可以理解为一个门面，将复杂的子系统的接口包装在一起，为客户端提供了一个统一的入口点。</p><p><u>意图：为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</u></p><p><u><code>Facade Pattern适用于：</code></u></p><ol><li><u>要为一个复杂子系统提供一个简单接口时</u>，子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类，这使得子系统更具有可重用性，也更容易对子系统进行定制，但也给那些不需要定制子系统的用户带来了一些使用上的困难。Facade 可以提供一个简单的默认视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制的用户可以越过 Facade 层。</li><li><u>客户程序与抽象类的实现部分之间存在着很大的依赖性</u>。引入 Facade 将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。</li><li><u>当需要构建一个层次结构的子系统时，使用 Facade 模式定义子系统中每层的入口点</u>。如果子系统之间是相互依赖的，则可以让它们仅通过 Facade 进行通信，从而简化了它们之间的依赖关系。</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="外观模式结构图"></p><h5 id="外观模式有三个关键角色：">外观模式有三个关键角色：</h5><ol><li><p><strong>外观（Facade）</strong></p><blockquote><p>外观类是外观模式的核心，提供了一个简单的接口供客户端使用，隐藏了子系统的复杂性。外观类通常包含对子系统的一系列调用，协调和管理子系统的功能。</p></blockquote></li><li><p><strong>子系统（Subsystem）</strong></p><blockquote><p>子系统是一组相关的类或对象，实现了复杂的功能，但对客户端来说是不可见的。子系统由外观类所封装，外观类通过调用子系统的接口来实现对其功能的访问。</p></blockquote></li><li><p><strong>客户端（Client）</strong></p><blockquote><p>客户端是使用外观模式的对象，通过调用外观类提供的简化接口来访问子系统的功能。客户端不直接与子系统进行交互，而是通过外观类来间接访问子系统的功能。</p></blockquote></li></ol><h5 id="外观模式参考代码实现">外观模式参考代码实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 外观模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubSystemA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;执行子系统A的功能。&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubSystemB</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;执行子系统B的功能。&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统C</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubSystemC</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;执行子系统C的功能。&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外观类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Facade</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">SubSystemA* sa;</span><br><span class="line">SubSystemB* sb;</span><br><span class="line">SubSystemC* sc;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Facade</span>()</span><br><span class="line">&#123;</span><br><span class="line">sa = <span class="keyword">new</span>  <span class="built_in">SubSystemA</span>();</span><br><span class="line">sb = <span class="keyword">new</span>  <span class="built_in">SubSystemB</span>();</span><br><span class="line">sc = <span class="keyword">new</span>  <span class="built_in">SubSystemC</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sa-&gt;<span class="built_in">printA</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sb-&gt;<span class="built_in">printB</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sc-&gt;<span class="built_in">printC</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Facade* facade = <span class="keyword">new</span> <span class="built_in">Facade</span>();</span><br><span class="line">facade-&gt;<span class="built_in">PrintA</span>();</span><br><span class="line">facade-&gt;<span class="built_in">PrintB</span>();</span><br><span class="line">facade-&gt;<span class="built_in">PrintC</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="外观模式的优缺点：">外观模式的优缺点：</h5><blockquote><p>外观模式的优点：</p><ol><li>简化客户端代码：外观模式提供了一个简单的接口，使得客户端调用子系统的功能变得简单和方便，减少了客户端与子系统之间的耦合，简化了客户端的代码。</li><li>封装复杂性：外观模式将子系统的复杂性封装在一个外观类中，对客户端来说，子系统的复杂性变得不可见，从而降低了客户端理解和使用子系统的难度。</li><li>提高系统灵活性：由于客户端只与外观类交互，而不直接与子系统交互，因此在不影响客户端的情况下，可以灵活地修改和扩展子系统的功能。</li></ol><p>外观模式的缺点：</p><ol><li>增加了一个外观类：引入了外观类作为客户端与子系统之间的中间层，可能会增加系统的复杂性和开发成本。</li><li>不符合开闭原则：如果需要修改或者扩展子系统的功能，可能需要修改外观类的接口或者实现，从而违反了开闭原则。</li><li>依赖子系统：外观模式依赖于子系统的稳定性，如果子系统发生变化，可能会导致外观类的修改，增加了系统的维护成本。</li></ol></blockquote><hr><h3 id="六、享元模式（Flyweight-Pattern）">六、享元模式（Flyweight Pattern）</h3><blockquote><p>享元模式（Flyweight Pattern）是一种结构型设计模式，用于通过共享对象以节省内存和提高性能。它的核心思想是共享细粒度的对象，以减少内存使用和对象创建的开销。</p><p>在享元模式中，对象分为两种类型：内部状态（Intrinsic State）和外部状态（Extrinsic State）。内部状态是可以被共享的，而外部状态是不可共享的。内部状态是对象固有的属性，它不会随着外部环境的变化而变化，因此可以被多个对象共享。外部状态是对象的一些变化较频繁的属性，它会随着外部环境的变化而变化，因此不适合被共享。</p><p>享元模式通过将内部状态和外部状态进行分离，将内部状态作为共享的部分，可以在多个对象之间共享使用，从而节省内存空间。而外部状态则通过参数的方式传递给对象，在需要时进行设置，使得多个对象可以共享内部状态，但可以有不同的外部状态。</p><p><u>意图：运用共享技术有效地支持大量细粒度的对象。</u></p><p><u><code>Flyweight Pattern适用于:</code></u></p><ol><li>一个应用程序使用了大量的对象。</li><li>完全由于大量的对象，造成很大的存储开销。</li><li>对象的大多数状态都可变为外部状态。</li><li>如果删除对象的外部状态，那么可以完全相对较少的共享对象取代很多组对象。</li><li>如果程序不依赖于对象标识。由于 Flyweight 对象可以被共享，所以对于概念上明显有别的对象，标识测试将返回真值。</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="享元模式结构图"></p><h5 id="享元模式通常包含以下角色：">享元模式通常包含以下角色：</h5><ol><li><p><strong>Flyweight（抽象享元类）</strong></p><blockquote><p>定义了享元对象的接口，包含了需要被共享的方法。</p></blockquote></li><li><p><strong>ConcreteFlyweight（具体享元类）</strong></p><blockquote><p>实现了抽象享元类的接口，实现了共享的方法。</p></blockquote></li><li><p><strong>UnsharedConcreteFlyweight（非共享具体享元类）</strong></p><blockquote><p>不可以被共享的具体享元类，一般不实现共享的方法。</p></blockquote></li><li><p><strong>FlyweightFactory（享元工厂类）</strong></p><blockquote><p>负责创建和管理享元对象，实现了享元对象的共享池，可以通过工厂方法获取享元对象。</p></blockquote></li><li><p><strong>Client（客户端）</strong></p><blockquote><p>使用享元对象的客户端，通过享元工厂获取享元对象，并通过外部状态对享元对象进行操作。</p></blockquote></li></ol><h5 id="享元模式参考代码实现">享元模式参考代码实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 享元模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象棋子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Piece</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string color;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Piece</span>() &#123; ; &#125;</span><br><span class="line"><span class="built_in">Piece</span>(string c) :<span class="built_in">color</span>(c) &#123; ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>= <span class="number">0</span>;</span><br><span class="line">~<span class="built_in">Piece</span>() &#123; ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体白棋类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WhitePiece</span> :<span class="keyword">public</span> Piece</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">WhitePiece</span>() :<span class="built_in">Piece</span>(<span class="string">&quot;white&quot;</span>) &#123; ; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Draw a Color: &quot;</span> &lt;&lt; color &lt;&lt; <span class="string">&quot;, Piece (x, y) : &quot;</span> &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="string">&quot;, Address: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">WhitePiece</span>() &#123; ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体黑棋类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyweightPiece</span> :<span class="keyword">public</span> Piece</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">FlyweightPiece</span>(string c)</span><br><span class="line">&#123;</span><br><span class="line">color = c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Draw a Color: &quot;</span> &lt;&lt; color &lt;&lt; <span class="string">&quot;, Piece (x, y) : &quot;</span> &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="string">&quot;, Address: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">FlyweightPiece</span>() &#123; ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 享元棋子工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PieceFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, Piece*&gt; pieces;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">Piece* <span class="title">GetPiece</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pieces.<span class="built_in">find</span>(key) == pieces.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">pieces[key] = <span class="keyword">new</span> <span class="built_in">WhitePiece</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;create color: &quot;</span> &lt;&lt; pieces[key] &lt;&lt; <span class="string">&quot; Piece.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Piece: &quot;</span> &lt;&lt; pieces[key] &lt;&lt; <span class="string">&quot; is exist.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pieces[key];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Piece* <span class="title">GetFlyweightPiece</span><span class="params">(string n, <span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pieces.<span class="built_in">find</span>(key) == pieces.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">pieces[key] = <span class="keyword">new</span> <span class="built_in">FlyweightPiece</span>(n);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;create color: &quot;</span> &lt;&lt; pieces[key] &lt;&lt; <span class="string">&quot; Piece.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Piece: &quot;</span> &lt;&lt; pieces[key] &lt;&lt; <span class="string">&quot; is exist.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pieces[key];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PieceFactory* factory = <span class="keyword">new</span> <span class="built_in">PieceFactory</span>();</span><br><span class="line">Piece* piece1 = factory-&gt;<span class="built_in">GetPiece</span>(<span class="number">1</span>);</span><br><span class="line">piece1-&gt;<span class="built_in">Draw</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Piece* piece2 = factory-&gt;<span class="built_in">GetPiece</span>(<span class="number">2</span>);</span><br><span class="line">piece2-&gt;<span class="built_in">Draw</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">Piece* piece3 = factory-&gt;<span class="built_in">GetPiece</span>(<span class="number">1</span>);</span><br><span class="line">piece3-&gt;<span class="built_in">Draw</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">Piece* piece4 = factory-&gt;<span class="built_in">GetPiece</span>(<span class="number">2</span>);</span><br><span class="line">piece4-&gt;<span class="built_in">Draw</span>(<span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;=======分割线========&quot;</span> &lt;&lt; endl;</span><br><span class="line">Piece* piece5 = factory-&gt;<span class="built_in">GetFlyweightPiece</span>(<span class="string">&quot;balck&quot;</span>, <span class="number">3</span>);</span><br><span class="line">piece5-&gt;<span class="built_in">Draw</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Piece* piece6 = factory-&gt;<span class="built_in">GetFlyweightPiece</span>(<span class="string">&quot;balck&quot;</span>, <span class="number">3</span>);</span><br><span class="line">piece6-&gt;<span class="built_in">Draw</span>(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 共享balck地址</span></span><br><span class="line">Piece* piece7 = factory-&gt;<span class="built_in">GetFlyweightPiece</span>(<span class="string">&quot;white&quot;</span>, <span class="number">4</span>);</span><br><span class="line">piece7-&gt;<span class="built_in">Draw</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">Piece* piece8 = factory-&gt;<span class="built_in">GetFlyweightPiece</span>(<span class="string">&quot;balck&quot;</span>, <span class="number">4</span>);</span><br><span class="line">piece8-&gt;<span class="built_in">Draw</span>(<span class="number">7</span>, <span class="number">8</span>); <span class="comment">// 共享white地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="享元模式的优缺点">享元模式的优缺点</h5><blockquote><p>享元模式的优点：</p><ol><li>节省内存：享元模式通过共享相同的对象实例来减少内存消耗。当多个对象需要相同的数据时，可以通过共享一个享元对象实例来避免创建多个相同的对象，从而减少内存使用。</li><li>提高性能：由于享元模式共享对象实例，可以减少对象的创建和销毁次数，从而提高系统的性能。特别是在需要频繁创建和销毁对象的情况下，使用享元模式可以显著提升性能。</li><li>简化对象管理：享元模式将共享对象的管理集中化，使得对象的创建和销毁更加简化和集中化。这有助于降低系统的复杂性，减少了对象管理的开销。</li><li>支持大量细粒度的对象：享元模式可以支持大量细粒度的对象共享，从而可以在需要处理大量对象时，有效地减少对象的数量，从而降低系统的开销。</li></ol><p>享元模式的缺点</p><ol><li>共享对象可能导致线程安全问题：如果多个线程同时访问共享的享元对象，并对其进行修改，可能会导致线程安全问题，需要进行适当的线程同步措施。</li><li>对象共享可能导致状态共享：享元模式中的对象共享可能导致不同对象之间共享状态，这可能会对系统的行为产生意外的影响，需要仔细设计和管理共享状态。</li><li>对象的复用可能受限：某些对象可能无法被复用，因为它们包含了不同的状态或行为，无法作为共享对象进行共享。</li><li>增加了系统复杂性：享元模式引入了共享对象的管理逻辑，可能会增加系统的复杂性，需要额外的管理和维护工作。</li></ol></blockquote><hr><h3 id="七、代理模式（Proxy-Pattern）">七、代理模式（Proxy Pattern）</h3><blockquote><p>代理模式（Proxy Pattern）是一种结构型设计模式，用于为其他对象提供一种代理或者占位符，以控制对原始对象的访问。</p><p><u>意图：为其他对象提供一种代理以控制对这个对象的访问。</u></p><p>在代理模式中，代理对象（Proxy）充当了客户端与原始对象之间的中介。客户端通过代理对象来访问原始对象，而不是直接访问原始对象。代理对象负责处理与原始对象相关的一些额外功能，例如权限控制、性能优化、延迟加载、缓存等。</p><p><u><code>Proxy Pattern适用于</code></u></p><ol><li>远程代理（Remote Proxy）：用于访问位于远程服务器上的对象，例如网络服务、Web服务等。</li><li>虚拟代理（Virtual Proxy）：用于延迟加载对象的创建，直到真正需要访问对象时才进行实际创建。</li><li>安全代理（Protection Proxy）：用于控制对敏感对象的访问权限，例如权限验证、身份验证等。</li><li>智能代理（Smart Proxy）：用于在访问对象时添加额外的行为，例如性能监控、日志记录、缓存管理等。</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AzureBubble/PicBed@main/showImg/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="代理模式结构图"></p><h5 id="代理模式有四个关键角色：">代理模式有四个关键角色：</h5><ol><li><p><strong>抽象主题（Subject）</strong></p><blockquote><p>定义了真实主题和代理主题共同的接口，可以是接口（Interface）或抽象类（Abstract Class）。抽象主题定义了真实主题和代理主题之间的公共操作，客户端通过抽象主题来访问真实主题或代理主题。</p></blockquote></li><li><p><strong>真实主题（Real Subject）</strong></p><blockquote><p>实现了抽象主题接口，是代理模式中真正执行业务逻辑的对象。真实主题是客户端想要访问的对象。</p></blockquote></li><li><p><strong>代理（Proxy）</strong></p><blockquote><p>实现了抽象主题接口，是客户端访问真实主题的代理对象。代理对象通常包含一个对真实主题的引用，同时负责在访问真实主题前后执行一些额外的操作，例如权限控制、性能优化、缓存管理等。</p></blockquote></li><li><p><strong>客户端（Client）</strong></p><blockquote><p>通过抽象主题接口来访问真实主题或代理对象，客户端通常不直接访问真实主题，而是通过代理对象来间接访问真实主题。</p></blockquote></li></ol><h5 id="代理模式参考代码实现">代理模式参考代码实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 代理模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象主题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Subject</span>() &#123; ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">request</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Subject</span>() &#123; ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真实主题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span> :<span class="keyword">public</span> Subject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">RealSubject</span>() &#123; ; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;执行真实主题的请求。&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">RealSubject</span>() &#123; ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> :<span class="keyword">public</span> Subject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">RealSubject* realSubject;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Proxy</span>()</span><br><span class="line">&#123;</span><br><span class="line">realSubject = <span class="keyword">new</span> <span class="built_in">RealSubject</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;执行代理的请求前的操作。&quot;</span> &lt;&lt; endl;</span><br><span class="line">realSubject-&gt;<span class="built_in">request</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;执行代理的请求后的操作。&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Proxy</span>() &#123; ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Subject* proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>();</span><br><span class="line">proxy-&gt;<span class="built_in">request</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代理模式的优缺点">代理模式的优缺点</h5><blockquote><p>代理模式的优点：</p><ol><li>代理对象可以控制对原始对象的访问，提供了一种间接的方式来管理对象，可以灵活地添加、删除或替换代理对象，而不会影响到客户端代码。</li><li>代理对象可以为原始对象添加额外的功能，例如权限控制、性能优化、缓存等，提高了系统的灵活性、可维护性和性能。</li><li>代理模式可以隐藏原始对象的实现细节，保护了原始对象的安全性。</li><li>代理模式可以在不修改原始对象的情况下对其进行扩展或改变。</li></ol><p>代理模式的缺点：</p><ol><li>代理模式引入了额外的间接层，可能会导致系统的复杂性增加。</li><li>代理模式可能会引入一定的性能开销，特别是在远程代理和虚拟代理中，由于涉及到网络通信或延迟加载的操作。</li><li>代理模式需要额外的代码来实现代理对象，增加了系统的开发和维护成本。</li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;结构型设计模式（Structural-Design-Patterns）-7种&quot;&gt;结构型设计模式（Structural Design Patterns） - 7种&lt;/h2&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;什么是结构型设计模式（Structura</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://azzurebubble.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="设计模式" scheme="https://azzurebubble.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="C++" scheme="https://azzurebubble.github.io/tags/C/"/>
    
    <category term="结构型设计模式" scheme="https://azzurebubble.github.io/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
